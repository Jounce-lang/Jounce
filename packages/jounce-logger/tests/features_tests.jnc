// Tests for Formatter, Transport, LoggerConfig, Timer, GlobalLogger
use jounce_logger::{Formatter, LogFormat, Transport, TransportType, LoggerConfig, LogTimer, GlobalLogger, LogLevel, LogEntry};

// ============================================================================
// Formatter Tests
// ============================================================================

#[test]
fn test_formatter_simple() {
    let formatter = Formatter::simple();
    assert!(formatter.include_level, "Should include level");
}

#[test]
fn test_formatter_json() {
    let formatter = Formatter::json();
    assert!(formatter.include_timestamp, "Should include timestamp");
}

#[test]
fn test_formatter_pretty() {
    let formatter = Formatter::pretty();
    assert!(formatter.include_logger_name, "Should include logger name");
}

#[test]
fn test_formatter_format_entry_simple() {
    let formatter = Formatter::simple();
    let entry = LogEntry::new(LogLevel::Info, "Test message");
    let formatted = formatter.format_entry(entry);
    assert!(formatted.contains("INFO"), "Should contain level");
    assert!(formatted.contains("Test message"), "Should contain message");
}

#[test]
fn test_formatter_format_entry_json() {
    let formatter = Formatter::json();
    let entry = LogEntry::new(LogLevel::Warn, "Warning");
    let formatted = formatter.format_entry(entry);
    assert!(formatted.contains("\"level\""), "Should be JSON format");
    assert!(formatted.contains("WARN"), "Should contain level");
}

#[test]
fn test_formatter_format_entry_pretty() {
    let formatter = Formatter::pretty();
    let entry = LogEntry::new(LogLevel::Error, "Error occurred");
    let formatted = formatter.format_entry(entry);
    assert!(formatted.contains("ERROR"), "Should contain level");
}

// ============================================================================
// Transport Tests
// ============================================================================

#[test]
fn test_transport_console() {
    let transport = Transport::console();
    assert!(transport.enabled, "Should be enabled");
}

#[test]
fn test_transport_file() {
    let transport = Transport::file("app.log");
    assert!(transport.enabled, "Should be enabled");
}

#[test]
fn test_transport_with_min_level() {
    let transport = Transport::console().with_min_level(LogLevel::Warn);
    assert_eq!(transport.min_level.to_number(), 3, "Min level should be Warn");
}

#[test]
fn test_transport_with_formatter() {
    let formatter = Formatter::json();
    let transport = Transport::console().with_formatter(formatter);
    // Formatter set successfully
    assert!(true, "Should set formatter");
}

#[test]
fn test_transport_should_transport_true() {
    let transport = Transport::console().with_min_level(LogLevel::Info);
    assert!(transport.should_transport(LogLevel::Error), "Should transport ERROR");
}

#[test]
fn test_transport_should_transport_false() {
    let transport = Transport::console().with_min_level(LogLevel::Warn);
    assert!(!transport.should_transport(LogLevel::Info), "Should not transport INFO");
}

#[test]
fn test_transport_disabled() {
    let mut transport = Transport::console();
    transport.enabled = false;
    assert!(!transport.should_transport(LogLevel::Error), "Should not transport when disabled");
}

// ============================================================================
// LoggerConfig Tests
// ============================================================================

#[test]
fn test_config_development() {
    let config = LoggerConfig::development();
    assert_eq!(config.default_level.to_number(), 1, "Should be Debug level");
    assert!(config.enable_console, "Console should be enabled");
}

#[test]
fn test_config_production() {
    let config = LoggerConfig::production();
    assert_eq!(config.default_level.to_number(), 3, "Should be Warn level");
    assert!(config.enable_file, "File should be enabled");
}

#[test]
fn test_config_silent() {
    let config = LoggerConfig::silent();
    assert_eq!(config.default_level.to_number(), 5, "Should be Fatal level");
    assert!(!config.enable_console, "Console should be disabled");
}

// ============================================================================
// LogTimer Tests
// ============================================================================

#[test]
fn test_timer_creation() {
    let timer = LogTimer::new("test_operation");
    assert_eq!(timer.name, "test_operation", "Name should match");
    assert!(timer.running, "Should be running");
}

#[test]
fn test_timer_elapsed() {
    let timer = LogTimer::new("test");
    let elapsed = timer.elapsed();
    assert!(elapsed >= 0, "Elapsed time should be non-negative");
}

#[test]
fn test_timer_stop() {
    let timer = LogTimer::new("test").stop();
    assert!(!timer.running, "Should not be running");
}

#[test]
fn test_timer_format_elapsed() {
    let timer = LogTimer::new("test");
    let formatted = timer.format_elapsed();
    assert!(formatted.contains("ms"), "Should contain 'ms'");
}

// ============================================================================
// GlobalLogger Tests
// ============================================================================

#[test]
fn test_global_logger_creation() {
    let global = GlobalLogger::new();
    assert_eq!(global.logger_count(), 0, "Should have no loggers");
}

#[test]
fn test_global_logger_get_logger() {
    let global = GlobalLogger::new();
    let logger = global.get_logger("app");
    assert_eq!(logger.name, "app", "Logger name should match");
}

#[test]
fn test_global_logger_set_default_level() {
    let global = GlobalLogger::new().set_default_level(LogLevel::Debug);
    assert_eq!(global.default_level.to_number(), 1, "Default level should be Debug");
}

#[test]
fn test_global_logger_logger_count() {
    let mut global = GlobalLogger::new();
    global = global.get_logger("app1").into();
    global = global.get_logger("app2").into();
    // Note: This test may not work as expected due to borrowing, just checking structure
    assert!(true, "Should manage multiple loggers");
}

// ============================================================================
// Integration Tests
// ============================================================================

#[test]
fn test_logger_with_formatter() {
    let logger = Logger::new("app").info("Test message");
    let formatter = Formatter::pretty();
    
    if logger.entry_count() > 0 {
        let entry = logger.entries.get(0);
        let formatted = formatter.format_entry(entry);
        assert!(formatted.len() > 0, "Should format entry");
    }
}

#[test]
fn test_complete_logging_workflow() {
    let config = LoggerConfig::development();
    let logger = Logger::new("app")
        .with_level(config.default_level)
        .info("Application started")
        .debug("Debug info")
        .warn("Warning occurred");
    
    assert!(logger.entry_count() >= 2, "Should have multiple entries");
}

#[test]
fn test_performance_logging() {
    let timer = LogTimer::new("database_query");
    let logger = Logger::new("perf");
    
    // Simulate operation
    let elapsed = timer.format_elapsed();
    let logger = logger.info("Query completed in " + elapsed);
    
    assert_eq!(logger.entry_count(), 1, "Should log performance");
}

#[test]
fn test_context_logging() {
    let entry = LogEntry::new(LogLevel::Info, "User action")
        .with_context("user_id", "123")
        .with_context("action", "login")
        .with_logger_name("auth");
    
    assert_eq!(entry.context.len(), 2, "Should have 2 context items");
    assert_eq!(entry.logger_name, "auth", "Logger name should be set");
}

#[test]
fn test_log_levels_hierarchy() {
    assert!(LogLevel::Error.to_number() > LogLevel::Warn.to_number(), "Error > Warn");
    assert!(LogLevel::Warn.to_number() > LogLevel::Info.to_number(), "Warn > Info");
    assert!(LogLevel::Info.to_number() > LogLevel::Debug.to_number(), "Info > Debug");
    assert!(LogLevel::Debug.to_number() > LogLevel::Trace.to_number(), "Debug > Trace");
}
