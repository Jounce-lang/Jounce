// Tests for Logger, LogLevel, LogEntry
use jounce_logger::{Logger, LogLevel, LogEntry};

#[test]
fn test_log_level_to_string() {
    assert_eq!(LogLevel::Info.to_string(), "INFO", "Should be INFO");
    assert_eq!(LogLevel::Error.to_string(), "ERROR", "Should be ERROR");
}

#[test]
fn test_log_level_to_number() {
    assert_eq!(LogLevel::Trace.to_number(), 0, "Trace should be 0");
    assert_eq!(LogLevel::Fatal.to_number(), 5, "Fatal should be 5");
}

#[test]
fn test_log_level_from_string() {
    let level = LogLevel::from_string("WARN");
    assert_eq!(level.to_string(), "WARN", "Should parse WARN");
}

#[test]
fn test_log_entry_creation() {
    let entry = LogEntry::new(LogLevel::Info, "Test message");
    assert_eq!(entry.message, "Test message", "Message should match");
}

#[test]
fn test_log_entry_with_context() {
    let entry = LogEntry::new(LogLevel::Info, "Test")
        .with_context("user_id", "123");
    assert_eq!(entry.context.len(), 1, "Should have 1 context item");
}

#[test]
fn test_log_entry_with_logger_name() {
    let entry = LogEntry::new(LogLevel::Info, "Test")
        .with_logger_name("MyLogger");
    assert_eq!(entry.logger_name, "MyLogger", "Logger name should match");
}

#[test]
fn test_logger_creation() {
    let logger = Logger::new("test");
    assert_eq!(logger.name, "test", "Name should match");
    assert!(logger.enabled, "Should be enabled by default");
}

#[test]
fn test_logger_with_level() {
    let logger = Logger::new("test").with_level(LogLevel::Debug);
    assert_eq!(logger.level.to_number(), 1, "Level should be Debug");
}

#[test]
fn test_logger_with_max_entries() {
    let logger = Logger::new("test").with_max_entries(100);
    assert_eq!(logger.max_entries, 100, "Max entries should be 100");
}

#[test]
fn test_logger_disable() {
    let logger = Logger::new("test").disable();
    assert!(!logger.enabled, "Should be disabled");
}

#[test]
fn test_logger_enable() {
    let logger = Logger::new("test").disable().enable();
    assert!(logger.enabled, "Should be enabled");
}

#[test]
fn test_logger_should_log_enabled() {
    let logger = Logger::new("test").with_level(LogLevel::Info);
    assert!(logger.should_log(LogLevel::Warn), "Should log WARN");
    assert!(!logger.should_log(LogLevel::Debug), "Should not log DEBUG");
}

#[test]
fn test_logger_should_log_disabled() {
    let logger = Logger::new("test").disable();
    assert!(!logger.should_log(LogLevel::Error), "Should not log when disabled");
}

#[test]
fn test_logger_info() {
    let logger = Logger::new("test").info("Info message");
    assert_eq!(logger.entry_count(), 1, "Should have 1 entry");
}

#[test]
fn test_logger_warn() {
    let logger = Logger::new("test").warn("Warning message");
    assert_eq!(logger.entry_count(), 1, "Should have 1 entry");
}

#[test]
fn test_logger_error() {
    let logger = Logger::new("test").error("Error message");
    assert_eq!(logger.entry_count(), 1, "Should have 1 entry");
}

#[test]
fn test_logger_debug() {
    let logger = Logger::new("test")
        .with_level(LogLevel::Debug)
        .debug("Debug message");
    assert_eq!(logger.entry_count(), 1, "Should have 1 entry");
}

#[test]
fn test_logger_trace() {
    let logger = Logger::new("test")
        .with_level(LogLevel::Trace)
        .trace("Trace message");
    assert_eq!(logger.entry_count(), 1, "Should have 1 entry");
}

#[test]
fn test_logger_fatal() {
    let logger = Logger::new("test").fatal("Fatal message");
    assert_eq!(logger.entry_count(), 1, "Should have 1 entry");
}

#[test]
fn test_logger_multiple_entries() {
    let logger = Logger::new("test")
        .info("Message 1")
        .info("Message 2")
        .warn("Message 3");
    assert_eq!(logger.entry_count(), 3, "Should have 3 entries");
}

#[test]
fn test_logger_max_entries_limit() {
    let mut logger = Logger::new("test").with_max_entries(2);
    logger = logger.info("1").info("2").info("3");
    assert_eq!(logger.entry_count(), 2, "Should only keep 2 entries");
}

#[test]
fn test_logger_get_entries() {
    let logger = Logger::new("test")
        .info("Info 1")
        .warn("Warning 1")
        .info("Info 2");
    let info_entries = logger.get_entries(LogLevel::Info);
    assert_eq!(info_entries.len(), 2, "Should have 2 info entries");
}

#[test]
fn test_logger_clear() {
    let logger = Logger::new("test")
        .info("Message 1")
        .info("Message 2")
        .clear();
    assert_eq!(logger.entry_count(), 0, "Should have no entries");
}

#[test]
fn test_logger_respects_level() {
    let logger = Logger::new("test")
        .with_level(LogLevel::Warn)
        .debug("Should not log")
        .info("Should not log")
        .warn("Should log");
    assert_eq!(logger.entry_count(), 1, "Should only log WARN and above");
}

#[test]
fn test_logger_chaining() {
    let logger = Logger::new("app")
        .with_level(LogLevel::Debug)
        .with_max_entries(500)
        .info("Test");
    assert_eq!(logger.max_entries, 500, "Should set max entries");
    assert_eq!(logger.entry_count(), 1, "Should have logged");
}
