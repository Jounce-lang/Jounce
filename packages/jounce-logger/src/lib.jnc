// Logging and debugging utilities for Jounce
// Structured logging with levels, formatters, and transports

// ============================================================================
// Log Levels
// ============================================================================

pub enum LogLevel {
    Trace,
    Debug,
    Info,
    Warn,
    Error,
    Fatal,
}

impl LogLevel {
    pub fn to_string(&self) -> string {
        match self {
            LogLevel::Trace => "TRACE",
            LogLevel::Debug => "DEBUG",
            LogLevel::Info => "INFO",
            LogLevel::Warn => "WARN",
            LogLevel::Error => "ERROR",
            LogLevel::Fatal => "FATAL",
        }
    }

    pub fn to_number(&self) -> int {
        match self {
            LogLevel::Trace => 0,
            LogLevel::Debug => 1,
            LogLevel::Info => 2,
            LogLevel::Warn => 3,
            LogLevel::Error => 4,
            LogLevel::Fatal => 5,
        }
    }

    pub fn from_string(level: string) -> LogLevel {
        if level == "TRACE" {
            LogLevel::Trace
        } else if level == "DEBUG" {
            LogLevel::Debug
        } else if level == "INFO" {
            LogLevel::Info
        } else if level == "WARN" {
            LogLevel::Warn
        } else if level == "ERROR" {
            LogLevel::Error
        } else if level == "FATAL" {
            LogLevel::Fatal
        } else {
            LogLevel::Info
        }
    }
}

// ============================================================================
// Log Entry
// ============================================================================

pub struct LogEntry {
    pub level: LogLevel,
    pub message: string,
    pub timestamp: int,
    pub context: Map<string, string>,
    pub logger_name: string,
}

impl LogEntry {
    pub fn new(level: LogLevel, message: string) -> LogEntry {
        LogEntry {
            level: level,
            message: message,
            timestamp: get_timestamp(),
            context: Map::new(),
            logger_name: "default",
        }
    }

    pub fn with_context(mut self, key: string, value: string) -> LogEntry {
        self.context.set(key, value);
        self
    }

    pub fn with_logger_name(mut self, name: string) -> LogEntry {
        self.logger_name = name;
        self
    }
}

// ============================================================================
// Logger
// ============================================================================

pub struct Logger {
    pub name: string,
    pub level: LogLevel,
    pub enabled: bool,
    pub entries: Array<LogEntry>,
    pub max_entries: int,
}

impl Logger {
    pub fn new(name: string) -> Logger {
        Logger {
            name: name,
            level: LogLevel::Info,
            enabled: true,
            entries: Array::new(),
            max_entries: 1000,
        }
    }

    pub fn with_level(mut self, level: LogLevel) -> Logger {
        self.level = level;
        self
    }

    pub fn with_max_entries(mut self, max: int) -> Logger {
        self.max_entries = max;
        self
    }

    pub fn disable(mut self) -> Logger {
        self.enabled = false;
        self
    }

    pub fn enable(mut self) -> Logger {
        self.enabled = true;
        self
    }

    pub fn should_log(&self, level: LogLevel) -> bool {
        if !self.enabled {
            return false;
        }
        level.to_number() >= self.level.to_number()
    }

    pub fn log(mut self, level: LogLevel, message: string) -> Logger {
        if !self.should_log(level) {
            return self;
        }

        let mut entry = LogEntry::new(level, message);
        entry = entry.with_logger_name(self.name.clone());

        if self.entries.len() >= self.max_entries {
            self.entries.remove(0);
        }

        self.entries.push(entry);
        self
    }

    pub fn trace(mut self, message: string) -> Logger {
        self.log(LogLevel::Trace, message)
    }

    pub fn debug(mut self, message: string) -> Logger {
        self.log(LogLevel::Debug, message)
    }

    pub fn info(mut self, message: string) -> Logger {
        self.log(LogLevel::Info, message)
    }

    pub fn warn(mut self, message: string) -> Logger {
        self.log(LogLevel::Warn, message)
    }

    pub fn error(mut self, message: string) -> Logger {
        self.log(LogLevel::Error, message)
    }

    pub fn fatal(mut self, message: string) -> Logger {
        self.log(LogLevel::Fatal, message)
    }

    pub fn entry_count(&self) -> int {
        self.entries.len()
    }

    pub fn get_entries(&self, level: LogLevel) -> Array<LogEntry> {
        let mut filtered = Array::new();
        let mut i = 0;
        while i < self.entries.len() {
            let entry = self.entries.get(i);
            if entry.level.to_number() == level.to_number() {
                filtered.push(entry);
            }
            i = i + 1;
        }
        filtered
    }

    pub fn clear(mut self) -> Logger {
        self.entries = Array::new();
        self
    }
}

// ============================================================================
// Formatter
// ============================================================================

pub enum LogFormat {
    Simple,
    JSON,
    Pretty,
    Timestamp,
}

pub struct Formatter {
    pub format: LogFormat,
    pub include_timestamp: bool,
    pub include_level: bool,
    pub include_logger_name: bool,
}

impl Formatter {
    pub fn simple() -> Formatter {
        Formatter {
            format: LogFormat::Simple,
            include_timestamp: false,
            include_level: true,
            include_logger_name: false,
        }
    }

    pub fn json() -> Formatter {
        Formatter {
            format: LogFormat::JSON,
            include_timestamp: true,
            include_level: true,
            include_logger_name: true,
        }
    }

    pub fn pretty() -> Formatter {
        Formatter {
            format: LogFormat::Pretty,
            include_timestamp: true,
            include_level: true,
            include_logger_name: true,
        }
    }

    pub fn format_entry(&self, entry: LogEntry) -> string {
        match self.format {
            LogFormat::Simple => {
                let level_str = if self.include_level {
                    "[" + entry.level.to_string() + "] "
                } else {
                    ""
                };
                level_str + entry.message
            },
            LogFormat::JSON => {
                "{\"level\":\"" + entry.level.to_string() + 
                "\",\"message\":\"" + entry.message + "\"}"
            },
            LogFormat::Pretty => {
                let timestamp_str = if self.include_timestamp {
                    entry.timestamp.to_string() + " "
                } else {
                    ""
                };
                timestamp_str + "[" + entry.level.to_string() + "] " + entry.message
            },
            LogFormat::Timestamp => {
                entry.timestamp.to_string() + " " + entry.message
            },
        }
    }
}

// ============================================================================
// Transport (output destination)
// ============================================================================

pub enum TransportType {
    Console,
    File,
    Memory,
}

pub struct Transport {
    pub transport_type: TransportType,
    pub min_level: LogLevel,
    pub formatter: Formatter,
    pub enabled: bool,
}

impl Transport {
    pub fn console() -> Transport {
        Transport {
            transport_type: TransportType::Console,
            min_level: LogLevel::Info,
            formatter: Formatter::simple(),
            enabled: true,
        }
    }

    pub fn file(path: string) -> Transport {
        Transport {
            transport_type: TransportType::File,
            min_level: LogLevel::Debug,
            formatter: Formatter::json(),
            enabled: true,
        }
    }

    pub fn with_min_level(mut self, level: LogLevel) -> Transport {
        self.min_level = level;
        self
    }

    pub fn with_formatter(mut self, formatter: Formatter) -> Transport {
        self.formatter = formatter;
        self
    }

    pub fn should_transport(&self, level: LogLevel) -> bool {
        if !self.enabled {
            return false;
        }
        level.to_number() >= self.min_level.to_number()
    }
}

// ============================================================================
// LoggerConfig
// ============================================================================

pub struct LoggerConfig {
    pub default_level: LogLevel,
    pub enable_console: bool,
    pub enable_file: bool,
    pub file_path: string,
    pub format: LogFormat,
}

impl LoggerConfig {
    pub fn development() -> LoggerConfig {
        LoggerConfig {
            default_level: LogLevel::Debug,
            enable_console: true,
            enable_file: false,
            file_path: "",
            format: LogFormat::Pretty,
        }
    }

    pub fn production() -> LoggerConfig {
        LoggerConfig {
            default_level: LogLevel::Warn,
            enable_console: true,
            enable_file: true,
            file_path: "logs/app.log",
            format: LogFormat::JSON,
        }
    }

    pub fn silent() -> LoggerConfig {
        LoggerConfig {
            default_level: LogLevel::Fatal,
            enable_console: false,
            enable_file: false,
            file_path: "",
            format: LogFormat::Simple,
        }
    }
}

// ============================================================================
// Timer for performance logging
// ============================================================================

pub struct LogTimer {
    pub name: string,
    pub start_time: int,
    pub running: bool,
}

impl LogTimer {
    pub fn new(name: string) -> LogTimer {
        LogTimer {
            name: name,
            start_time: get_timestamp(),
            running: true,
        }
    }

    pub fn elapsed(&self) -> int {
        if self.running {
            get_timestamp() - self.start_time
        } else {
            0
        }
    }

    pub fn stop(mut self) -> LogTimer {
        self.running = false;
        self
    }

    pub fn format_elapsed(&self) -> string {
        self.elapsed().to_string() + "ms"
    }
}

// ============================================================================
// Global Logger
// ============================================================================

pub struct GlobalLogger {
    pub loggers: Map<string, Logger>,
    pub default_level: LogLevel,
}

impl GlobalLogger {
    pub fn new() -> GlobalLogger {
        GlobalLogger {
            loggers: Map::new(),
            default_level: LogLevel::Info,
        }
    }

    pub fn get_logger(mut self, name: string) -> Logger {
        if let Some(logger) = self.loggers.get(name.clone()) {
            logger
        } else {
            let logger = Logger::new(name.clone()).with_level(self.default_level.clone());
            self.loggers.set(name, logger.clone());
            logger
        }
    }

    pub fn set_default_level(mut self, level: LogLevel) -> GlobalLogger {
        self.default_level = level;
        self
    }

    pub fn logger_count(&self) -> int {
        self.loggers.len()
    }
}

// ============================================================================
// Utility Functions
// ============================================================================

pub fn get_timestamp() -> int {
    // In production, would return actual timestamp
    1729800000
}

pub fn log_memory_usage() -> string {
    // In production, would return actual memory usage
    "Memory: 42MB"
}

pub fn log_system_info() -> string {
    // In production, would return system info
    "System: Jounce v0.1.0"
}
