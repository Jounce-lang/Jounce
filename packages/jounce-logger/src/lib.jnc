// jounce-logger - Structured Logging Package
// Version: 0.1.0
//
// Provides structured logging with log levels, JSON output,
// file rotation, and filtering for Jounce applications.

use jounce_utils::{format_date, now};

// ============================================================================
// Log Levels
// ============================================================================

/// Log level enum
pub enum LogLevel {
    DEBUG,
    INFO,
    WARN,
    ERROR,
    FATAL,
}

impl LogLevel {
    /// Convert to string
    pub fn to_string(self) -> string {
        match self {
            LogLevel::DEBUG => "DEBUG",
            LogLevel::INFO => "INFO",
            LogLevel::WARN => "WARN",
            LogLevel::ERROR => "ERROR",
            LogLevel::FATAL => "FATAL",
        }
    }

    /// Convert to numeric value for comparison
    pub fn to_int(self) -> int {
        match self {
            LogLevel::DEBUG => 0,
            LogLevel::INFO => 1,
            LogLevel::WARN => 2,
            LogLevel::ERROR => 3,
            LogLevel::FATAL => 4,
        }
    }

    /// Compare levels
    pub fn gte(self, other: LogLevel) -> bool {
        return self.to_int() >= other.to_int();
    }
}

// ============================================================================
// Log Entry
// ============================================================================

/// Log entry with metadata
pub struct LogEntry {
    timestamp: string,
    level: LogLevel,
    message: string,
    logger_name: string,
    fields: Map<string, string>,
}

impl LogEntry {
    /// Format as JSON
    pub fn to_json(self) -> string {
        let mut json = "{";
        json = json + "\"timestamp\":\"" + self.timestamp + "\",";
        json = json + "\"level\":\"" + self.level.to_string() + "\",";
        json = json + "\"logger\":\"" + self.logger_name + "\",";
        json = json + "\"message\":\"" + self.message + "\"";

        if self.fields.len() > 0 {
            json = json + ",\"fields\":{";
            let mut first = true;
            for (key, value) in self.fields {
                if !first {
                    json = json + ",";
                }
                json = json + "\"" + key + "\":\"" + value + "\"";
                first = false;
            }
            json = json + "}";
        }

        json = json + "}";
        return json;
    }

    /// Format as human-readable text
    pub fn to_text(self) -> string {
        let level_str = self.level.to_string();
        let mut text = "[" + self.timestamp + "] " + level_str + " [" + self.logger_name + "] " + self.message;

        if self.fields.len() > 0 {
            text = text + " {";
            let mut first = true;
            for (key, value) in self.fields {
                if !first {
                    text = text + ", ";
                }
                text = text + key + "=" + value;
                first = false;
            }
            text = text + "}";
        }

        return text;
    }
}

// ============================================================================
// Logger Configuration
// ============================================================================

/// Output format
pub enum OutputFormat {
    JSON,
    Text,
}

/// Output target
pub enum OutputTarget {
    Console,
    File,
    Both,
}

/// Logger configuration
pub struct LoggerConfig {
    name: string,
    min_level: LogLevel,
    format: OutputFormat,
    target: OutputTarget,
    file_path: string,
    max_file_size: int, // in bytes
    max_files: int,      // number of rotated files to keep
}

// ============================================================================
// Logger
// ============================================================================

/// Logger instance
pub struct Logger {
    config: LoggerConfig,
    context_fields: Map<string, string>,
}

impl Logger {
    /// Create new logger
    pub fn new(config: LoggerConfig) -> Logger {
        return Logger {
            config: config,
            context_fields: Map::new(),
        };
    }

    /// Add context field (appears in all logs from this logger)
    pub fn with_field(mut self, key: string, value: string) -> Logger {
        self.context_fields.insert(key, value);
        return self;
    }

    /// Log at DEBUG level
    pub fn debug(self, message: string) {
        self.log(LogLevel::DEBUG, message, Map::new());
    }

    /// Log at DEBUG level with fields
    pub fn debug_with_fields(self, message: string, fields: Map<string, string>) {
        self.log(LogLevel::DEBUG, message, fields);
    }

    /// Log at INFO level
    pub fn info(self, message: string) {
        self.log(LogLevel::INFO, message, Map::new());
    }

    /// Log at INFO level with fields
    pub fn info_with_fields(self, message: string, fields: Map<string, string>) {
        self.log(LogLevel::INFO, message, fields);
    }

    /// Log at WARN level
    pub fn warn(self, message: string) {
        self.log(LogLevel::WARN, message, Map::new());
    }

    /// Log at WARN level with fields
    pub fn warn_with_fields(self, message: string, fields: Map<string, string>) {
        self.log(LogLevel::WARN, message, fields);
    }

    /// Log at ERROR level
    pub fn error(self, message: string) {
        self.log(LogLevel::ERROR, message, Map::new());
    }

    /// Log at ERROR level with fields
    pub fn error_with_fields(self, message: string, fields: Map<string, string>) {
        self.log(LogLevel::ERROR, message, fields);
    }

    /// Log at FATAL level
    pub fn fatal(self, message: string) {
        self.log(LogLevel::FATAL, message, Map::new());
    }

    /// Log at FATAL level with fields
    pub fn fatal_with_fields(self, message: string, fields: Map<string, string>) {
        self.log(LogLevel::FATAL, message, fields);
    }

    /// Core logging function
    fn log(self, level: LogLevel, message: string, fields: Map<string, string>) {
        // Check if level passes filter
        if !level.gte(self.config.min_level) {
            return;
        }

        // Merge context fields with log fields
        let mut all_fields = self.context_fields.clone();
        for (key, value) in fields {
            all_fields.insert(key, value);
        }

        // Create log entry
        let entry = LogEntry {
            timestamp: get_timestamp(),
            level: level,
            message: message,
            logger_name: self.config.name.clone(),
            fields: all_fields,
        };

        // Format output
        let output = match self.config.format {
            OutputFormat::JSON => entry.to_json(),
            OutputFormat::Text => entry.to_text(),
        };

        // Write to targets
        match self.config.target {
            OutputTarget::Console => {
                write_to_console(output);
            },
            OutputTarget::File => {
                write_to_file(self.config.file_path.clone(), output, self.config.max_file_size, self.config.max_files);
            },
            OutputTarget::Both => {
                write_to_console(output.clone());
                write_to_file(self.config.file_path.clone(), output, self.config.max_file_size, self.config.max_files);
            },
        }
    }
}

// ============================================================================
// Global Logger Registry
// ============================================================================

/// Global logger registry
static mut LOGGERS: Map<string, Logger> = Map::new();

/// Get or create logger
pub fn get_logger(name: string) -> Logger {
    unsafe {
        if LOGGERS.contains_key(&name) {
            return LOGGERS.get(&name).clone();
        } else {
            // Create default logger
            let config = LoggerConfig {
                name: name.clone(),
                min_level: LogLevel::INFO,
                format: OutputFormat::Text,
                target: OutputTarget::Console,
                file_path: "",
                max_file_size: 10 * 1024 * 1024, // 10MB
                max_files: 5,
            };

            let logger = Logger::new(config);
            LOGGERS.insert(name.clone(), logger.clone());
            return logger;
        }
    }
}

/// Register custom logger
pub fn register_logger(logger: Logger) {
    unsafe {
        LOGGERS.insert(logger.config.name.clone(), logger);
    }
}

// ============================================================================
// Default Logger Functions
// ============================================================================

/// Get default logger
pub fn default_logger() -> Logger {
    return get_logger("default");
}

/// Log DEBUG to default logger
pub fn debug(message: string) {
    default_logger().debug(message);
}

/// Log INFO to default logger
pub fn info(message: string) {
    default_logger().info(message);
}

/// Log WARN to default logger
pub fn warn(message: string) {
    default_logger().warn(message);
}

/// Log ERROR to default logger
pub fn error(message: string) {
    default_logger().error(message);
}

/// Log FATAL to default logger
pub fn fatal(message: string) {
    default_logger().fatal(message);
}

// ============================================================================
// File Rotation
// ============================================================================

/// Check if file needs rotation
fn should_rotate(file_path: string, max_size: int) -> bool {
    let size = get_file_size(file_path);
    return size >= max_size;
}

/// Rotate log files
fn rotate_files(file_path: string, max_files: int) {
    // Rotate existing files: file.log.1 -> file.log.2, etc.
    for i in (max_files - 1)..0 {
        let old_file = file_path + "." + i.to_string();
        let new_file = file_path + "." + (i + 1).to_string();

        if file_exists(old_file) {
            rename_file(old_file, new_file);
        }
    }

    // Rename current file to .1
    if file_exists(file_path) {
        rename_file(file_path, file_path + ".1");
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

fn get_timestamp() -> string {
    let dt = now();
    return format_date(dt, "YYYY-MM-DD HH:mm:ss");
}

fn write_to_console(message: string) {
    println!("{}", message);
}

fn write_to_file(file_path: string, message: string, max_size: int, max_files: int) {
    // Check for rotation
    if should_rotate(file_path.clone(), max_size) {
        rotate_files(file_path.clone(), max_files);
    }

    // Append to file
    append_to_file(file_path, message + "\n");
}

fn get_file_size(path: string) -> int {
    // Platform-specific file size check
    return 0; // Placeholder
}

fn file_exists(path: string) -> bool {
    // Platform-specific file existence check
    return false; // Placeholder
}

fn rename_file(old_path: string, new_path: string) {
    // Platform-specific file rename
}

fn append_to_file(path: string, content: string) {
    // Platform-specific file append
}

// Export main types and functions
pub use LogLevel;
pub use LogEntry;
pub use OutputFormat;
pub use OutputTarget;
pub use LoggerConfig;
pub use Logger;

pub use get_logger;
pub use register_logger;
pub use default_logger;

pub use debug;
pub use info;
pub use warn;
pub use error;
pub use fatal;
