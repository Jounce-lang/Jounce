// Tests for connection pooling in jounce-db
use jounce_db::{
    DbConfig, create_pool, get_connection, release_connection, close_pool
};

#[test]
fn test_create_pool() {
    let config = DbConfig {
        driver: "sqlite",
        host: "",
        port: 0,
        database: ":memory:",
        username: "",
        password: "",
        pool_size: 5,
        timeout: 10,
    };

    let pool = create_pool(config);

    assert_eq!(pool.connections.len(), 5, "Should create 5 connections");
    assert_eq!(pool.available.len(), 5, "All connections should be available");
    assert_eq!(pool.in_use.len(), 0, "No connections in use");
}

#[test]
fn test_get_connection_from_pool() {
    let config = DbConfig {
        driver: "sqlite",
        host: "",
        port: 0,
        database: ":memory:",
        username: "",
        password: "",
        pool_size: 3,
        timeout: 10,
    };

    let mut pool = create_pool(config);

    match get_connection(pool) {
        Ok(conn) => {
            assert!(conn.is_open, "Connection should be open");
            assert_eq!(conn.driver, "sqlite", "Should be SQLite connection");
            assert_eq!(pool.available.len(), 2, "Should have 2 available connections");
            assert_eq!(pool.in_use.len(), 1, "Should have 1 in-use connection");
        },
        Err(error) => {
            panic!("Should get connection: {}", error);
        }
    }
}

#[test]
fn test_release_connection_to_pool() {
    let config = DbConfig {
        driver: "sqlite",
        host: "",
        port: 0,
        database: ":memory:",
        username: "",
        password: "",
        pool_size: 3,
        timeout: 10,
    };

    let mut pool = create_pool(config);
    let conn = get_connection(pool).unwrap();

    // Release connection
    release_connection(pool, conn);

    assert_eq!(pool.available.len(), 3, "All connections should be available");
    assert_eq!(pool.in_use.len(), 0, "No connections in use");
}

#[test]
fn test_pool_exhaustion() {
    let config = DbConfig {
        driver: "sqlite",
        host: "",
        port: 0,
        database: ":memory:",
        username: "",
        password: "",
        pool_size: 2,
        timeout: 10,
    };

    let mut pool = create_pool(config);

    // Get both connections
    let conn1 = get_connection(pool).unwrap();
    let conn2 = get_connection(pool).unwrap();

    assert_eq!(pool.available.len(), 0, "No connections available");

    // Try to get third connection
    match get_connection(pool) {
        Ok(_) => panic!("Should not get connection from exhausted pool"),
        Err(error) => {
            assert_eq!(error, "No available connections in pool", "Should error on exhaustion");
        }
    }
}

#[test]
fn test_close_pool() {
    let config = DbConfig {
        driver: "sqlite",
        host: "",
        port: 0,
        database: ":memory:",
        username: "",
        password: "",
        pool_size: 3,
        timeout: 10,
    };

    let mut pool = create_pool(config);

    close_pool(pool);

    assert_eq!(pool.connections.len(), 0, "All connections should be closed");
    assert_eq!(pool.available.len(), 0, "Available list should be empty");
    assert_eq!(pool.in_use.len(), 0, "In-use list should be empty");
}

#[test]
fn test_postgres_pool_config() {
    let config = DbConfig {
        driver: "postgres",
        host: "localhost",
        port: 5432,
        database: "testdb",
        username: "user",
        password: "pass",
        pool_size: 10,
        timeout: 30,
    };

    let pool = create_pool(config);

    assert_eq!(pool.config.driver, "postgres", "Should be postgres");
    assert_eq!(pool.config.host, "localhost", "Should have correct host");
    assert_eq!(pool.config.port, 5432, "Should have correct port");
    assert_eq!(pool.config.pool_size, 10, "Should have 10 connections");
}

#[test]
fn test_multiple_get_release_cycles() {
    let config = DbConfig {
        driver: "sqlite",
        host: "",
        port: 0,
        database: ":memory:",
        username: "",
        password: "",
        pool_size: 2,
        timeout: 10,
    };

    let mut pool = create_pool(config);

    // Cycle 1
    let conn1 = get_connection(pool).unwrap();
    assert_eq!(pool.available.len(), 1, "1 available");
    release_connection(pool, conn1);
    assert_eq!(pool.available.len(), 2, "2 available");

    // Cycle 2
    let conn2 = get_connection(pool).unwrap();
    assert_eq!(pool.available.len(), 1, "1 available");
    release_connection(pool, conn2);
    assert_eq!(pool.available.len(), 2, "2 available");
}

#[test]
fn test_pool_config_validation() {
    let config = DbConfig {
        driver: "sqlite",
        host: "",
        port: 0,
        database: ":memory:",
        username: "",
        password: "",
        pool_size: 0, // Invalid pool size
        timeout: 10,
    };

    // In real implementation, would validate config
    // For now, just create with invalid size
    let pool = create_pool(config);

    assert_eq!(pool.connections.len(), 0, "Should have 0 connections");
}

#[test]
fn test_connection_properties() {
    let config = DbConfig {
        driver: "sqlite",
        host: "",
        port: 0,
        database: ":memory:",
        username: "",
        password: "",
        pool_size: 1,
        timeout: 10,
    };

    let mut pool = create_pool(config);
    let conn = get_connection(pool).unwrap();

    assert!(conn.id.len() > 0, "Connection should have ID");
    assert!(conn.is_open, "Connection should be open");
    assert!(!conn.in_transaction, "Connection should not be in transaction");
    assert_eq!(conn.driver, "sqlite", "Should be SQLite");
}
