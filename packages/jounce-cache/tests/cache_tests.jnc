// Tests for in-memory cache in jounce-cache
use jounce_cache::{Cache, CacheConfig, CacheEntry, EvictionPolicy};

#[test]
fn test_cache_config_creation() {
    let config = CacheConfig::default();

    assert_eq!(config.max_size, 100, "Default max size should be 100");
    assert_eq!(config.default_ttl, 0, "Default TTL should be 0");
}

#[test]
fn test_cache_config_builder() {
    let config = CacheConfig::default()
        .with_max_size(50)
        .with_ttl(3600)
        .with_policy(EvictionPolicy::LFU);

    assert_eq!(config.max_size, 50, "Max size should be 50");
    assert_eq!(config.default_ttl, 3600, "TTL should be 3600");
}

#[test]
fn test_cache_entry_creation() {
    let entry = CacheEntry::new("value", 0);

    assert_eq!(entry.value, "value", "Value should match");
    assert_eq!(entry.access_count, 1, "Access count should be 1");
    assert!(!entry.is_expired(), "Should not be expired");
}

#[test]
fn test_cache_entry_with_ttl() {
    let entry = CacheEntry::new("value", 3600);

    assert_eq!(entry.expires_at > 0, true, "Should have expiration");
    assert!(!entry.is_expired(), "Should not be expired yet");
}

#[test]
fn test_cache_creation() {
    let config = CacheConfig::default();
    let cache = Cache::new(config);

    assert_eq!(cache.size(), 0, "Cache should be empty");
}

#[test]
fn test_cache_set_and_get() {
    let config = CacheConfig::default();
    let mut cache = Cache::new(config);

    cache.set("key1", "value1");

    assert_eq!(cache.size(), 1, "Should have 1 entry");

    let value = cache.get("key1");
    assert!(value.is_some(), "Should have value");
    assert_eq!(value.unwrap(), "value1", "Value should match");
}

#[test]
fn test_cache_get_nonexistent() {
    let config = CacheConfig::default();
    let mut cache = Cache::new(config);

    let value = cache.get("missing");
    assert!(value.is_none(), "Should be None for missing key");
}

#[test]
fn test_cache_remove() {
    let config = CacheConfig::default();
    let mut cache = Cache::new(config);

    cache.set("key1", "value1");
    assert_eq!(cache.size(), 1, "Should have 1 entry");

    let removed = cache.remove("key1");
    assert!(removed, "Should return true");
    assert_eq!(cache.size(), 0, "Should be empty");
}

#[test]
fn test_cache_clear() {
    let config = CacheConfig::default();
    let mut cache = Cache::new(config);

    cache.set("key1", "value1");
    cache.set("key2", "value2");
    assert_eq!(cache.size(), 2, "Should have 2 entries");

    cache.clear();
    assert_eq!(cache.size(), 0, "Should be empty");
}

#[test]
fn test_cache_has() {
    let config = CacheConfig::default();
    let mut cache = Cache::new(config);

    cache.set("key1", "value1");

    assert!(cache.has("key1"), "Should have key1");
    assert!(!cache.has("key2"), "Should not have key2");
}

#[test]
fn test_cache_keys() {
    let config = CacheConfig::default();
    let mut cache = Cache::new(config);

    cache.set("key1", "value1");
    cache.set("key2", "value2");

    let keys = cache.keys();
    assert_eq!(keys.len(), 2, "Should have 2 keys");
}

#[test]
fn test_cache_set_with_ttl() {
    let config = CacheConfig::default();
    let mut cache = Cache::new(config);

    cache.set_with_ttl("key1", "value1", 3600);

    assert!(cache.has("key1"), "Should have key1");
}

#[test]
fn test_cache_update_existing() {
    let config = CacheConfig::default();
    let mut cache = Cache::new(config);

    cache.set("key1", "value1");
    cache.set("key1", "value2");

    let value = cache.get("key1");
    assert_eq!(value.unwrap(), "value2", "Should have updated value");
    assert_eq!(cache.size(), 1, "Should still have 1 entry");
}

#[test]
fn test_cache_max_size() {
    let config = CacheConfig::default().with_max_size(2);
    let mut cache = Cache::new(config);

    cache.set("key1", "value1");
    cache.set("key2", "value2");
    cache.set("key3", "value3");  // Should evict key1

    assert_eq!(cache.size(), 2, "Should have max 2 entries");
    assert!(!cache.has("key1"), "key1 should be evicted");
    assert!(cache.has("key2"), "key2 should exist");
    assert!(cache.has("key3"), "key3 should exist");
}

#[test]
fn test_cache_lru_eviction() {
    let config = CacheConfig::default()
        .with_max_size(2)
        .with_policy(EvictionPolicy::LRU);
    let mut cache = Cache::new(config);

    cache.set("key1", "value1");
    cache.set("key2", "value2");

    // Access key1 to make it recently used
    cache.get("key1");

    cache.set("key3", "value3");  // Should evict key2 (least recently used)

    assert!(cache.has("key1"), "key1 should exist");
    assert!(!cache.has("key2"), "key2 should be evicted");
    assert!(cache.has("key3"), "key3 should exist");
}

#[test]
fn test_cache_fifo_eviction() {
    let config = CacheConfig::default()
        .with_max_size(2)
        .with_policy(EvictionPolicy::FIFO);
    let mut cache = Cache::new(config);

    cache.set("key1", "value1");
    cache.set("key2", "value2");
    cache.set("key3", "value3");  // Should evict key1 (first in)

    assert!(!cache.has("key1"), "key1 should be evicted");
    assert!(cache.has("key2"), "key2 should exist");
    assert!(cache.has("key3"), "key3 should exist");
}

#[test]
fn test_cache_lfu_eviction() {
    let config = CacheConfig::default()
        .with_max_size(2)
        .with_policy(EvictionPolicy::LFU);
    let mut cache = Cache::new(config);

    cache.set("key1", "value1");
    cache.set("key2", "value2");

    // Access key1 multiple times
    cache.get("key1");
    cache.get("key1");

    cache.set("key3", "value3");  // Should evict key2 (least frequently used)

    assert!(cache.has("key1"), "key1 should exist");
    assert!(!cache.has("key2"), "key2 should be evicted");
    assert!(cache.has("key3"), "key3 should exist");
}

#[test]
fn test_cache_evict_expired() {
    let config = CacheConfig::default();
    let mut cache = Cache::new(config);

    // In real tests, would set TTL to 1 second and sleep
    // For now, just test the function exists
    let removed = cache.evict_expired();
    assert_eq!(removed >= 0, true, "Should return count");
}

#[test]
fn test_cache_multiple_operations() {
    let config = CacheConfig::default().with_max_size(5);
    let mut cache = Cache::new(config);

    cache.set("key1", "value1");
    cache.set("key2", "value2");
    cache.set("key3", "value3");

    assert_eq!(cache.size(), 3, "Should have 3 entries");

    cache.remove("key2");
    assert_eq!(cache.size(), 2, "Should have 2 entries");

    cache.set("key4", "value4");
    assert_eq!(cache.size(), 3, "Should have 3 entries");

    cache.clear();
    assert_eq!(cache.size(), 0, "Should be empty");
}

#[test]
fn test_cache_entry_touch() {
    let mut entry = CacheEntry::new("value", 0);
    let initial_count = entry.access_count;

    entry.touch();

    assert_eq!(entry.access_count, initial_count + 1, "Access count should increase");
}
