// jounce-cli - Command-line interface utilities
// Provides argument parsing, commands, flags, and formatted output

// ============================================================================
// CLI Arguments
// ============================================================================

pub struct CliArgs {
    pub args: Array<string>,
    pub flags: Map<string, string>,
    pub command: string,
}

impl CliArgs {
    pub fn new() -> CliArgs {
        return CliArgs {
            args: Array::new(),
            flags: Map::new(),
            command: "",
        };
    }

    pub fn parse(argv: Array<string>) -> CliArgs {
        let mut args = CliArgs::new();
        let mut i = 0;

        while i < argv.len() {
            let arg = argv.get(i);

            if arg.starts_with("--") {
                // Long flag: --name=value or --name value
                let name = arg.substring(2);
                if name.contains("=") {
                    let parts = name.split("=");
                    args.flags.insert(parts.get(0), parts.get(1));
                } else if i + 1 < argv.len() {
                    i = i + 1;
                    args.flags.insert(name, argv.get(i));
                } else {
                    args.flags.insert(name, "true");
                }
            } else if arg.starts_with("-") {
                // Short flag: -n value
                let name = arg.substring(1);
                if i + 1 < argv.len() && !argv.get(i + 1).starts_with("-") {
                    i = i + 1;
                    args.flags.insert(name, argv.get(i));
                } else {
                    args.flags.insert(name, "true");
                }
            } else {
                // Command or argument
                if args.command.is_empty() {
                    args.command = arg;
                } else {
                    args.args.push(arg);
                }
            }

            i = i + 1;
        }

        return args;
    }

    pub fn get_flag(self, name: string) -> Option<string> {
        return self.flags.get(name);
    }

    pub fn has_flag(self, name: string) -> bool {
        return self.flags.contains_key(name);
    }

    pub fn get_arg(self, index: int) -> Option<string> {
        if index < self.args.len() {
            return Some(self.args.get(index));
        }
        return None;
    }
}

// ============================================================================
// CLI Command
// ============================================================================

pub struct CliCommand {
    pub name: string,
    pub description: string,
    pub usage: string,
    pub handler: Option<fn(CliArgs)>,
    pub subcommands: Array<CliCommand>,
}

impl CliCommand {
    pub fn new(name: string, description: string) -> CliCommand {
        return CliCommand {
            name: name,
            description: description,
            usage: "",
            handler: None,
            subcommands: Array::new(),
        };
    }

    pub fn with_usage(mut self, usage: string) -> CliCommand {
        self.usage = usage;
        return self;
    }

    pub fn with_handler(mut self, handler: fn(CliArgs)) -> CliCommand {
        self.handler = Some(handler);
        return self;
    }

    pub fn add_subcommand(mut self, subcommand: CliCommand) -> CliCommand {
        self.subcommands.push(subcommand);
        return self;
    }

    pub fn execute(self, args: CliArgs) {
        if let Some(handler) = self.handler {
            handler(args);
        }
    }

    pub fn help(self) -> string {
        let mut help = "USAGE:\n  " + self.name;
        if !self.usage.is_empty() {
            help = help + " " + self.usage;
        }
        help = help + "\n\n";

        help = help + "DESCRIPTION:\n  " + self.description + "\n\n";

        if self.subcommands.len() > 0 {
            help = help + "SUBCOMMANDS:\n";
            for cmd in self.subcommands {
                help = help + "  " + cmd.name + " - " + cmd.description + "\n";
            }
        }

        return help;
    }
}

// ============================================================================
// CLI App
// ============================================================================

pub struct CliApp {
    pub name: string,
    pub version: string,
    pub description: string,
    pub commands: Array<CliCommand>,
}

impl CliApp {
    pub fn new(name: string, version: string) -> CliApp {
        return CliApp {
            name: name,
            version: version,
            description: "",
            commands: Array::new(),
        };
    }

    pub fn with_description(mut self, description: string) -> CliApp {
        self.description = description;
        return self;
    }

    pub fn add_command(mut self, command: CliCommand) -> CliApp {
        self.commands.push(command);
        return self;
    }

    pub fn run(self, argv: Array<string>) {
        let args = CliArgs::parse(argv);

        if args.has_flag("version") {
            println(self.name + " v" + self.version);
            return;
        }

        if args.has_flag("help") || args.command.is_empty() {
            println(self.help());
            return;
        }

        // Find and execute command
        for cmd in self.commands {
            if cmd.name == args.command {
                cmd.execute(args);
                return;
            }
        }

        println("Unknown command: " + args.command);
        println(self.help());
    }

    pub fn help(self) -> string {
        let mut help = self.name + " v" + self.version + "\n";
        if !self.description.is_empty() {
            help = help + self.description + "\n";
        }
        help = help + "\n";

        help = help + "USAGE:\n  " + self.name + " [COMMAND] [OPTIONS]\n\n";

        help = help + "COMMANDS:\n";
        for cmd in self.commands {
            help = help + "  " + cmd.name + " - " + cmd.description + "\n";
        }

        help = help + "\nOPTIONS:\n";
        help = help + "  --help     Show help message\n";
        help = help + "  --version  Show version\n";

        return help;
    }
}

// ============================================================================
// Output Formatting
// ============================================================================

pub enum Color {
    Reset,
    Red,
    Green,
    Yellow,
    Blue,
    Magenta,
    Cyan,
}

impl Color {
    pub fn code(self) -> string {
        return match self {
            Color::Reset => "\x1b[0m",
            Color::Red => "\x1b[31m",
            Color::Green => "\x1b[32m",
            Color::Yellow => "\x1b[33m",
            Color::Blue => "\x1b[34m",
            Color::Magenta => "\x1b[35m",
            Color::Cyan => "\x1b[36m",
        };
    }
}

pub fn colorize(text: string, color: Color) -> string {
    return color.code() + text + Color::Reset.code();
}

pub fn success(message: string) {
    println(colorize(" " + message, Color::Green));
}

pub fn error(message: string) {
    println(colorize(" " + message, Color::Red));
}

pub fn warning(message: string) {
    println(colorize("  " + message, Color::Yellow));
}

pub fn info(message: string) {
    println(colorize("9 " + message, Color::Blue));
}

// ============================================================================
// Progress Bar
// ============================================================================

pub struct ProgressBar {
    pub total: int,
    pub current: int,
    pub width: int,
    pub label: string,
}

impl ProgressBar {
    pub fn new(total: int) -> ProgressBar {
        return ProgressBar {
            total: total,
            current: 0,
            width: 50,
            label: "",
        };
    }

    pub fn with_label(mut self, label: string) -> ProgressBar {
        self.label = label;
        return self;
    }

    pub fn update(mut self, current: int) -> ProgressBar {
        self.current = current;
        self.render();
        return self;
    }

    pub fn increment(mut self) -> ProgressBar {
        self.current = self.current + 1;
        self.render();
        return self;
    }

    fn render(self) {
        let percent = (self.current as float) / (self.total as float);
        let filled = (percent * (self.width as float)) as int;

        let mut bar = "[";
        let mut i = 0;
        while i < self.width {
            if i < filled {
                bar = bar + "=";
            } else {
                bar = bar + " ";
            }
            i = i + 1;
        }
        bar = bar + "] ";

        let percent_str = ((percent * 100.0) as int).to_string() + "%";
        let status = self.current.to_string() + "/" + self.total.to_string();

        print("\r" + self.label + " " + bar + percent_str + " " + status);
    }

    pub fn finish(self) {
        println("");
    }
}

// ============================================================================
// Table Formatting
// ============================================================================

pub struct Table {
    pub headers: Array<string>,
    pub rows: Array<Array<string>>,
}

impl Table {
    pub fn new(headers: Array<string>) -> Table {
        return Table {
            headers: headers,
            rows: Array::new(),
        };
    }

    pub fn add_row(mut self, row: Array<string>) -> Table {
        self.rows.push(row);
        return self;
    }

    pub fn render(self) -> string {
        let mut output = "";

        // Render headers
        output = output + "| ";
        for header in self.headers {
            output = output + header + " | ";
        }
        output = output + "\n";

        // Render separator
        output = output + "|";
        for _ in self.headers {
            output = output + "---|";
        }
        output = output + "\n";

        // Render rows
        for row in self.rows {
            output = output + "| ";
            for cell in row {
                output = output + cell + " | ";
            }
            output = output + "\n";
        }

        return output;
    }
}

// ============================================================================
// Interactive Prompts
// ============================================================================

pub fn prompt(message: string) -> string {
    print(message + ": ");
    return read_line();
}

pub fn confirm(message: string) -> bool {
    let response = prompt(message + " (y/n)");
    return response == "y" || response == "yes";
}

pub fn select(message: string, options: Array<string>) -> int {
    println(message);
    let mut i = 0;
    for option in options {
        println((i + 1).to_string() + ") " + option);
        i = i + 1;
    }

    let response = prompt("Select option");
    return response.to_int() - 1;
}

// ============================================================================
// Helper Functions
// ============================================================================

fn read_line() -> string {
    // In production, would read from stdin
    return "";
}

fn print(text: string) {
    // In production, would write to stdout without newline
}

fn println(text: string) {
    // In production, would write to stdout with newline
}
