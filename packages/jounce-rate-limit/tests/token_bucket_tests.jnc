// Tests for TokenBucketLimiter in jounce-rate-limit
use jounce_rate_limit::TokenBucketLimiter;

#[test]
fn test_token_bucket_creation() {
    let limiter = TokenBucketLimiter::new(10, 5, 1000);

    assert_eq!(limiter.capacity, 10, "Capacity should be 10");
    assert_eq!(limiter.refill_rate, 5, "Refill rate should be 5");
    assert_eq!(limiter.refill_interval, 1000, "Refill interval should be 1000");
}

#[test]
fn test_token_bucket_first_request() {
    let mut limiter = TokenBucketLimiter::new(10, 1, 1000);
    let (updated, result) = limiter.check("user1", 1000);

    limiter = updated;
    assert!(result.allowed, "First request should be allowed");
    assert_eq!(result.remaining, 9, "Should have 9 remaining tokens");
}

#[test]
fn test_token_bucket_consume_tokens() {
    let mut limiter = TokenBucketLimiter::new(5, 1, 1000);

    let (updated, result1) = limiter.check("user1", 1000);
    limiter = updated;
    assert_eq!(result1.remaining, 4, "Should have 4 tokens");

    let (updated, result2) = limiter.check("user1", 1100);
    limiter = updated;
    assert_eq!(result2.remaining, 3, "Should have 3 tokens");

    let (updated, result3) = limiter.check("user1", 1200);
    limiter = updated;
    assert_eq!(result3.remaining, 2, "Should have 2 tokens");
}

#[test]
fn test_token_bucket_empty() {
    let mut limiter = TokenBucketLimiter::new(2, 1, 1000);

    let (updated, _) = limiter.check("user1", 1000);
    limiter = updated;

    let (updated, _) = limiter.check("user1", 1100);
    limiter = updated;

    // Bucket is empty
    let (updated, result) = limiter.check("user1", 1200);
    limiter = updated;

    assert!(!result.allowed, "Should be denied when bucket is empty");
}

#[test]
fn test_token_bucket_refill() {
    let mut limiter = TokenBucketLimiter::new(10, 5, 1000);

    // Use 5 tokens
    let (updated, _) = limiter.check("user1", 1000);
    limiter = updated;
    let (updated, _) = limiter.check("user1", 1100);
    limiter = updated;
    let (updated, _) = limiter.check("user1", 1200);
    limiter = updated;
    let (updated, _) = limiter.check("user1", 1300);
    limiter = updated;
    let (updated, result5) = limiter.check("user1", 1400);
    limiter = updated;
    assert_eq!(result5.remaining, 5, "Should have 5 tokens");

    // Wait for refill (1 interval = 5 tokens)
    let (updated, result) = limiter.check("user1", 2500);
    limiter = updated;

    assert!(result.allowed, "Should be allowed after refill");
    assert_eq!(result.remaining, 9, "Should have refilled tokens");
}

#[test]
fn test_token_bucket_multiple_refills() {
    let mut limiter = TokenBucketLimiter::new(10, 2, 1000);

    let (updated, result1) = limiter.check("user1", 1000);
    limiter = updated;
    assert_eq!(result1.remaining, 9, "Should have 9 tokens");

    // Wait for 2 refills (2000ms = 2 intervals = 4 tokens)
    let (updated, result2) = limiter.check("user1", 3000);
    limiter = updated;

    // Started with 9, waited 2s = +4, total = 13 but capped at 10, -1 for this request = 9
    assert_eq!(result2.remaining, 9, "Should be at capacity after refill");
}

#[test]
fn test_token_bucket_cap_at_capacity() {
    let mut limiter = TokenBucketLimiter::new(5, 10, 1000);

    let (updated, result1) = limiter.check("user1", 1000);
    limiter = updated;
    assert_eq!(result1.remaining, 4, "Should have 4 tokens");

    // Wait for refill (would add 10 but capped at 5)
    let (updated, result2) = limiter.check("user1", 2000);
    limiter = updated;

    assert_eq!(result2.remaining, 4, "Should be capped at capacity");
}

#[test]
fn test_token_bucket_burst() {
    let mut limiter = TokenBucketLimiter::new(10, 1, 1000);

    // Burst of 10 requests
    let mut i = 0;
    while i < 10 {
        let (updated, result) = limiter.check("user1", 1000 + i);
        limiter = updated;
        assert!(result.allowed, "Burst request " + i.to_string() + " should be allowed");
        i = i + 1;
    }

    // 11th request should be denied
    let (updated, result) = limiter.check("user1", 1010);
    limiter = updated;
    assert!(!result.allowed, "Should be denied after burst");
}

#[test]
fn test_token_bucket_reset() {
    let mut limiter = TokenBucketLimiter::new(2, 1, 1000);

    let (updated, _) = limiter.check("user1", 1000);
    limiter = updated;

    let (updated, _) = limiter.check("user1", 1100);
    limiter = updated;

    // Reset
    limiter = limiter.reset("user1");

    // Should have full bucket after reset
    let (updated, result) = limiter.check("user1", 1200);
    limiter = updated;
    assert!(result.allowed, "Should be allowed after reset");
    assert_eq!(result.remaining, 1, "Should have fresh tokens");
}

#[test]
fn test_token_bucket_multiple_users() {
    let mut limiter = TokenBucketLimiter::new(5, 1, 1000);

    let (updated, result1) = limiter.check("user1", 1000);
    limiter = updated;
    assert_eq!(result1.remaining, 4, "User1 should have 4 tokens");

    let (updated, result2) = limiter.check("user2", 1000);
    limiter = updated;
    assert_eq!(result2.remaining, 4, "User2 should have 4 tokens");

    // Users have independent buckets
    let mut i = 0;
    while i < 4 {
        let (updated, _) = limiter.check("user1", 1100 + i);
        limiter = updated;
        i = i + 1;
    }

    let (updated, result3) = limiter.check("user1", 1200);
    limiter = updated;
    assert!(!result3.allowed, "User1 should be denied");

    let (updated, result4) = limiter.check("user2", 1200);
    limiter = updated;
    assert!(result4.allowed, "User2 should still be allowed");
}

#[test]
fn test_token_bucket_partial_refill() {
    let mut limiter = TokenBucketLimiter::new(10, 3, 1000);

    let (updated, result1) = limiter.check("user1", 1000);
    limiter = updated;

    // Use all tokens
    let mut i = 0;
    while i < 9 {
        let (updated, _) = limiter.check("user1", 1100 + i);
        limiter = updated;
        i = i + 1;
    }

    // Wait for partial refill (500ms = 0 intervals, no refill)
    let (updated, result2) = limiter.check("user1", 1500);
    limiter = updated;
    assert!(!result2.allowed, "Should be denied without full interval");

    // Wait for full refill (1000ms = 1 interval = 3 tokens)
    let (updated, result3) = limiter.check("user1", 2000);
    limiter = updated;
    assert!(result3.allowed, "Should be allowed after full interval");
}

#[test]
fn test_token_bucket_high_refill_rate() {
    let mut limiter = TokenBucketLimiter::new(100, 50, 1000);

    // Use 50 tokens
    let mut i = 0;
    while i < 50 {
        let (updated, _) = limiter.check("user1", 1000 + i);
        limiter = updated;
        i = i + 1;
    }

    // Refill
    let (updated, result) = limiter.check("user1", 2000);
    limiter = updated;
    assert!(result.allowed, "Should be allowed after high refill rate");
}
