// Auto-generated Jounce Client Bundle
// DO NOT EDIT - Generated by Jounce compiler

import { RPCClient, mountComponent } from '../dist/client-runtime.js';

// Node.js crypto module (for tests and server-side code)
let __nodeCrypto;
try {
  if (typeof require !== 'undefined') {
    __nodeCrypto = require('crypto');
  }
} catch (e) {
  // crypto module not available (browser environment)
}

// Crypto helpers - use Node.js crypto module when available
const __crypto_sha256 = function(data) {
  if (__nodeCrypto) return __nodeCrypto.createHash('sha256').update(data).digest('hex');
  return ''; // fallback
};
const __crypto_sha1 = function(data) {
  if (__nodeCrypto) return __nodeCrypto.createHash('sha1').update(data).digest('hex');
  return ''; // fallback
};
const __crypto_md5 = function(data) {
  if (__nodeCrypto) return __nodeCrypto.createHash('md5').update(data).digest('hex');
  return ''; // fallback
};
const __crypto_hmac = function(algo, key, data) {
  if (__nodeCrypto) return __nodeCrypto.createHmac(algo, key).update(data).digest('hex');
  return ''; // fallback
};
const __crypto_random_bytes = function(len) {
  if (__nodeCrypto) return Array.from(__nodeCrypto.randomBytes(len));
  return Array(len).fill(0); // fallback
};
const __crypto_pbkdf2 = function(password, salt, iterations, keylen, digest) {
  if (__nodeCrypto) return __nodeCrypto.pbkdf2Sync(password, salt, iterations, keylen, digest).toString('hex');
  return ''; // fallback
};

// Node.js fs module (for server-side file I/O)
let __nodeFs;
try {
  if (typeof require !== 'undefined') {
    __nodeFs = require('fs');
  }
} catch (e) {
  // fs module not available (browser environment)
}

// File system helpers - use Node.js fs module when available
const __fs_read_to_string = function(path) {
  if (__nodeFs) return __nodeFs.readFileSync(path, 'utf8');
  throw new Error('File I/O not available in browser');
};
const __fs_read_bytes = function(path) {
  if (__nodeFs) return Array.from(__nodeFs.readFileSync(path));
  throw new Error('File I/O not available in browser');
};
const __fs_write_string = function(path, data) {
  if (__nodeFs) { __nodeFs.writeFileSync(path, data, 'utf8'); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_write_bytes = function(path, data) {
  if (__nodeFs) { __nodeFs.writeFileSync(path, Buffer.from(data)); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_append_string = function(path, data) {
  if (__nodeFs) { __nodeFs.appendFileSync(path, data, 'utf8'); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_exists = function(path) {
  if (__nodeFs) return __nodeFs.existsSync(path);
  return false;
};
const __fs_metadata = function(path) {
  if (__nodeFs) {
    const stats = __nodeFs.statSync(path);
    return {
      size: stats.size,
      is_file: stats.isFile(),
      is_directory: stats.isDirectory(),
      created: stats.birthtimeMs,
      modified: stats.mtimeMs,
      accessed: stats.atimeMs,
      permissions: stats.mode & 0o777
    };
  }
  throw new Error('File I/O not available in browser');
};
const __fs_read_dir = function(path) {
  if (__nodeFs) {
    const entries = __nodeFs.readdirSync(path, { withFileTypes: true });
    return entries.map(entry => {
      const fullPath = path + '/' + entry.name;
      const stats = __nodeFs.statSync(fullPath);
      return {
        name: entry.name,
        path: fullPath,
        metadata: {
          size: stats.size,
          is_file: stats.isFile(),
          is_directory: stats.isDirectory(),
          created: stats.birthtimeMs,
          modified: stats.mtimeMs,
          accessed: stats.atimeMs,
          permissions: stats.mode & 0o777
        }
      };
    });
  }
  throw new Error('File I/O not available in browser');
};
const __fs_create_dir = function(path) {
  if (__nodeFs) { __nodeFs.mkdirSync(path); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_create_dir_all = function(path) {
  if (__nodeFs) { __nodeFs.mkdirSync(path, { recursive: true }); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_remove_file = function(path) {
  if (__nodeFs) { __nodeFs.unlinkSync(path); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_remove_dir = function(path) {
  if (__nodeFs) { __nodeFs.rmdirSync(path); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_remove_dir_all = function(path) {
  if (__nodeFs) { __nodeFs.rmSync(path, { recursive: true, force: true }); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_rename = function(from, to) {
  if (__nodeFs) { __nodeFs.renameSync(from, to); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_read_to_string_safe = function(path) {
  try { return Ok(__fs_read_to_string(path)); } catch (e) { return Err(e.message); }
};
const __fs_read_bytes_safe = function(path) {
  try { return Ok(__fs_read_bytes(path)); } catch (e) { return Err(e.message); }
};
const __fs_write_string_safe = function(path, data) {
  try { __fs_write_string(path, data); return Ok(undefined); } catch (e) { return Err(e.message); }
};
const __fs_write_bytes_safe = function(path, data) {
  try { __fs_write_bytes(path, data); return Ok(undefined); } catch (e) { return Err(e.message); }
};
const __fs_append_string_safe = function(path, data) {
  try { __fs_append_string(path, data); return Ok(undefined); } catch (e) { return Err(e.message); }
};
const __fs_metadata_safe = function(path) {
  try { return Ok(__fs_metadata(path)); } catch (e) { return Err(e.message); }
};
const __fs_read_dir_safe = function(path) {
  try { return Ok(__fs_read_dir(path)); } catch (e) { return Err(e.message); }
};
const __fs_create_dir_safe = function(path) {
  try { __fs_create_dir(path); return Ok(undefined); } catch (e) { return Err(e.message); }
};
const __fs_create_dir_all_safe = function(path) {
  try { __fs_create_dir_all(path); return Ok(undefined); } catch (e) { return Err(e.message); }
};
const __fs_remove_file_safe = function(path) {
  try { __fs_remove_file(path); return Ok(undefined); } catch (e) { return Err(e.message); }
};
const __fs_remove_dir_safe = function(path) {
  try { __fs_remove_dir(path); return Ok(undefined); } catch (e) { return Err(e.message); }
};
const __fs_remove_dir_all_safe = function(path) {
  try { __fs_remove_dir_all(path); return Ok(undefined); } catch (e) { return Err(e.message); }
};
const __fs_rename_safe = function(from, to) {
  try { __fs_rename(from, to); return Ok(undefined); } catch (e) { return Err(e.message); }
};

// Built-in type extensions
const Vec = Array; // Vec<T> is Array in JavaScript
Vec.new = function() { return []; }; // Vec::new() creates empty array
// String methods - ensure they work on both primitives and String objects
if (!String.prototype.len) {
  String.prototype.len = function() { return this.length; };
}
if (!String.prototype.is_empty) {
  String.prototype.is_empty = function() { return this.length === 0; };
}
if (!String.prototype.chars) {
  String.prototype.chars = function() { return this.split(''); };
}
if (!String.prototype.contains) {
  String.prototype.contains = function(substr) { return this.includes(substr); };
}
if (!String.prototype.starts_with) {
  String.prototype.starts_with = function(prefix) { return this.startsWith(prefix); };
}
if (!String.prototype.to_lowercase) {
  String.prototype.to_lowercase = function() { return this.toLowerCase(); };
}
if (!String.prototype.char_code_at) {
  String.prototype.char_code_at = function(index) { return this.charCodeAt(index); };
}
if (!String.prototype.char_at) {
  String.prototype.char_at = function(index) { return this.charAt(index); };
}
if (!String.prototype.parse_int) {
  String.prototype.parse_int = function() { return parseInt(this, 10); };
}
if (!String.prototype.parse_float) {
  String.prototype.parse_float = function() { return parseFloat(this); };
}
if (!String.prototype.index_of) {
  String.prototype.index_of = function(substr) { return this.indexOf(substr); };
}
if (!String.prototype.clone) {
  String.prototype.clone = function() { return this.toString(); };
}
if (!Number.prototype.to_string) {
  Number.prototype.to_string = function() { return this.toString(); };
}
if (!Array.prototype.len) {
  Array.prototype.len = function() { return this.length; };
}
if (!Array.prototype.is_empty) {
  Array.prototype.is_empty = function() { return this.length === 0; };
}
if (!Array.prototype.clone) {
  Array.prototype.clone = function() { return this.slice(); };
}
if (!Object.prototype.keys) {
  Object.prototype.keys = function() { return Object.keys(this); };
}
if (!String.from_char_code) {
  String.from_char_code = function(code) { return String.fromCharCode(code); };
}

// Result<T, E> enum - represents success (Ok) or failure (Err)
const Result = { __proto__: null };
Result.prototype = {};
function Ok(data) { const v = { variant: "Ok", data: data }; v.__proto__ = Result.prototype; return v; }
function Err(data) { const v = { variant: "Err", data: data }; v.__proto__ = Result.prototype; return v; }
Result.prototype.is_ok = function() { return this.variant === "Ok"; };
Result.prototype.is_err = function() { return this.variant === "Err"; };
Result.prototype.unwrap = function() { if (this.variant === "Ok") return this.data; throw new Error("Called unwrap on Err"); };
Result.prototype.unwrap_err = function() { if (this.variant === "Err") return this.data; throw new Error("Called unwrap_err on Ok"); };
Result.prototype.unwrap_or = function(default_val) { return this.variant === "Ok" ? this.data : default_val; };

// Option<T> enum - represents Some value or None
const Option = { __proto__: null };
Option.prototype = {};
function Some(data) { const v = { variant: "Some", data: data }; v.__proto__ = Option.prototype; return v; }
const None = (() => { const v = { variant: "None" }; v.__proto__ = Option.prototype; return v; })();
Option.Some = Some;
Option.None = None;
Option.prototype.is_some = function() { return this.variant === "Some"; };
Option.prototype.is_none = function() { return this.variant === "None"; };
Option.prototype.unwrap = function() { if (this.variant === "Some") return this.data; throw new Error("Called unwrap on None"); };
Option.prototype.unwrap_or = function(default_val) { return this.variant === "Some" ? this.data : default_val; };

// HashMap<K, V> is a JavaScript Map
const HashMap = Map;
HashMap.new = function() { return new Map(); };
if (!Map.prototype.insert) {
  Map.prototype.insert = function(k, v) { this.set(k, v); };
}
if (!Map.prototype.contains_key) {
  Map.prototype.contains_key = function(k) { return this.has(k); };
}
if (!Map.prototype.get_or_default) {
  Map.prototype.get_or_default = function(k, def) { return this.has(k) ? this.get(k) : def; };
}

// RPC Client Setup
// Auto-generated RPC client stubs
import { RPCClient } from '../dist/client-runtime.js';

const client = new RPCClient(window.location.origin + '/_rpc');


// Struct definitions
// Enum definitions
// Implementations
// Client function implementations
// Shared utility functions
export function test_method_with_string() {
  let s = "hello";
  let parts = s.split(".");
  return parts;

}

// Stdlib module namespaces
const json = {
  parse: typeof parse !== 'undefined' ? parse : undefined,
  stringify: typeof stringify !== 'undefined' ? stringify : undefined,
  stringify_pretty: typeof stringify_pretty !== 'undefined' ? stringify_pretty : undefined,
  // Helper functions for creating JSON values
  null_: () => ({ variant: 'Null' }),
  bool: (b) => ({ variant: 'Bool', data: b }),
  number: (n) => ({ variant: 'Number', data: n }),
  string: (s) => ({ variant: 'String', data: s }),
  array: (arr) => ({ variant: 'Array', data: arr || [] }),
  object: (obj) => ({ variant: 'Object', data: obj || {} }),
};

const crypto = {
  sha256: typeof sha256 !== 'undefined' ? sha256 : undefined,
  sha1: typeof sha1 !== 'undefined' ? sha1 : undefined,
  md5: typeof md5 !== 'undefined' ? md5 : undefined,
  hmac_sha256: typeof hmac_sha256 !== 'undefined' ? hmac_sha256 : undefined,
  random_bytes: typeof random_bytes !== 'undefined' ? random_bytes : undefined,
  random_int: typeof random_int !== 'undefined' ? random_int : undefined,
  random_float: typeof random_float !== 'undefined' ? random_float : undefined,
  random_string: typeof random_string !== 'undefined' ? random_string : undefined,
  random_alphanumeric: typeof random_alphanumeric !== 'undefined' ? random_alphanumeric : undefined,
  random_hex: typeof random_hex !== 'undefined' ? random_hex : undefined,
  uuid_v4: typeof uuid_v4 !== 'undefined' ? uuid_v4 : undefined,
  base64_encode: typeof base64_encode !== 'undefined' ? base64_encode : undefined,
  base64_decode: typeof base64_decode !== 'undefined' ? base64_decode : undefined,
  hex_encode: typeof hex_encode !== 'undefined' ? hex_encode : undefined,
  hex_decode: typeof hex_decode !== 'undefined' ? hex_decode : undefined,
  hash_password_auto: typeof hash_password_auto !== 'undefined' ? hash_password_auto : undefined,
  generate_salt: typeof generate_salt !== 'undefined' ? generate_salt : undefined,
};

// UI Components
// Initialize application
window.addEventListener('DOMContentLoaded', () => {
  console.log('Jounce client initialized');
});

//# sourceMappingURL=client.js.map
