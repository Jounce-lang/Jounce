// JS Emitter - Generates complete JavaScript files for server and client
//
// This module combines:
// 1. RPC stubs/handlers from RPCGenerator
// 2. Actual function implementations (converted from WASM or AST)
// 3. Runtime imports and setup code
// 4. Main entry point code
//
// Output:
// - server.js: Server-side code with HTTP server and RPC handlers
// - client.js: Client-side code with RPC stubs and UI components

use crate::ast::{Program, Statement, FunctionDefinition, ComponentDefinition, Expression, BlockStatement, Pattern, TypeExpression, ForInStatement, ForStatement, ImplBlock};
use crate::code_splitter::CodeSplitter;
use crate::rpc_generator::RPCGenerator;
use crate::source_map::SourceMapBuilder;

#[derive(Debug, Clone)]
pub struct JSEmitter {
    pub splitter: CodeSplitter,
    pub source_file: String,  // Original .jnc source file path
    #[allow(dead_code)] // Used in future source map implementation
    current_line: usize,  // Track current line number during generation
}

impl JSEmitter {
    pub fn new(program: &Program) -> Self {
        let mut splitter = CodeSplitter::new();
        splitter.split(program);
        JSEmitter {
            splitter,
            source_file: "input.jnc".to_string(),
            current_line: 1,
        }
    }

    /// Create a new JSEmitter with a custom source file path
    pub fn with_source_file(program: &Program, source_file: String) -> Self {
        let mut splitter = CodeSplitter::new();
        splitter.split(program);
        JSEmitter {
            splitter,
            source_file,
            current_line: 1,
        }
    }

    /// Escape JavaScript reserved words by adding underscore suffix
    fn escape_js_reserved_word(name: &str) -> String {
        // JavaScript reserved words and global identifiers that can't be used as function names
        const RESERVED: &[&str] = &[
            "null", "undefined", "true", "false",
            "break", "case", "catch", "continue", "debugger", "default", "delete", "do",
            "else", "finally", "for", "function", "if", "in", "instanceof", "new",
            "return", "switch", "this", "throw", "try", "typeof", "var", "void", "while", "with",
            "class", "const", "enum", "export", "extends", "import", "super",
            "let", "static", "yield", "await", "async",
            "eval", "arguments"
        ];

        if RESERVED.contains(&name) {
            format!("{}_", name)
        } else {
            name.to_string()
        }
    }

    /// Generates the complete server.js file
    pub fn generate_server_js(&self) -> String {
        let mut output = String::new();
        let source_map = SourceMapBuilder::new("server.js".to_string());

        // Header comment
        output.push_str("// Auto-generated Jounce Server Bundle\n");
        output.push_str("// DO NOT EDIT - Generated by Jounce compiler\n\n");

        // Import runtime
        output.push_str("const { HttpServer, loadWasm } = require('../dist/server-runtime.js');\n");
        output.push_str("const fs = require('fs');\n");
        output.push_str("const path = require('path');\n\n");

        // Generate struct constructors
        if !self.splitter.structs.is_empty() {
            output.push_str("// Struct definitions\n");
            for struct_def in &self.splitter.structs {
                let params: Vec<String> = struct_def.fields.iter()
                    .map(|(name, _)| name.value.clone())
                    .collect();
                output.push_str(&format!(
                    "function {}({}) {{\n",
                    struct_def.name.value,
                    params.join(", ")
                ));
                for (field_name, _) in &struct_def.fields {
                    output.push_str(&format!("  this.{} = {};\n", field_name.value, field_name.value));
                }
                output.push_str("}\n\n");
            }
        }

        // Generate enum definitions (BEFORE impl blocks!)
        if !self.splitter.enums.is_empty() {
            output.push_str("// Enum definitions\n");
            for enum_def in &self.splitter.enums {
                output.push_str(&self.generate_enum_js(enum_def));
                output.push_str("\n");
            }
        }

        // Generate impl blocks (after enums and structs are defined)
        if !self.splitter.impl_blocks.is_empty() {
            output.push_str("// Implementations\n");
            for impl_block in &self.splitter.impl_blocks {
                output.push_str(&self.generate_impl_block_js(impl_block));
            }
            output.push_str("\n");
        }

        // Load WASM module
        output.push_str("// Load WebAssembly module\n");
        output.push_str("const wasmPath = path.join(__dirname, 'app.wasm');\n");
        output.push_str("const wasmBytes = fs.readFileSync(wasmPath);\n");
        output.push_str("const wasmModule = new WebAssembly.Module(wasmBytes);\n");
        output.push_str("const wasmInstance = new WebAssembly.Instance(wasmModule, {\n");
        output.push_str("  env: {\n");
        output.push_str("    memory: new WebAssembly.Memory({ initial: 256, maximum: 256 }),\n");
        output.push_str("  }\n");
        output.push_str("});\n\n");

        // Generate server function implementations
        output.push_str("// Server function implementations\n");
        for func in &self.splitter.server_functions {
            output.push_str(&self.generate_function_impl(func, true));
            output.push_str("\n\n");
        }

        // Generate shared function implementations
        output.push_str("// Shared utility functions\n");
        for func in &self.splitter.shared_functions {
            output.push_str(&self.generate_function_impl(func, true));
            output.push_str("\n\n");
        }

        // Generate RPC handlers
        output.push_str("// RPC Server Setup\n");
        let rpc_gen = RPCGenerator::new(self.splitter.server_functions.clone());
        output.push_str(&rpc_gen.generate_server_handlers());

        // Add source map reference comment
        output.push('\n');
        output.push_str(&source_map.generate_reference_comment());
        output.push('\n');

        output
    }

    /// Generates the complete server.js file with source map
    #[allow(unused_assignments)] // current_line used for future source map implementation
    pub fn generate_server_js_with_sourcemap(&self) -> (String, String) {
        let mut output = String::new();
        let mut source_map = SourceMapBuilder::new("server.js".to_string());
        let mut current_line = 1;

        // Header comment
        output.push_str("// Auto-generated Jounce Server Bundle\n");
        current_line += 1;
        output.push_str("// DO NOT EDIT - Generated by Jounce compiler\n\n");
        current_line += 2;

        // Import runtime
        output.push_str("const { HttpServer, loadWasm } = require('../dist/server-runtime.js');\n");
        current_line += 1;
        output.push_str("const fs = require('fs');\n");
        current_line += 1;
        output.push_str("const path = require('path');\n\n");
        current_line += 2;

        // Load WASM module
        output.push_str("// Load WebAssembly module\n");
        current_line += 1;
        output.push_str("const wasmPath = path.join(__dirname, 'app.wasm');\n");
        current_line += 1;
        output.push_str("const wasmBytes = fs.readFileSync(wasmPath);\n");
        current_line += 1;
        output.push_str("const wasmModule = new WebAssembly.Module(wasmBytes);\n");
        current_line += 1;
        output.push_str("const wasmInstance = new WebAssembly.Instance(wasmModule, {\n");
        current_line += 1;
        output.push_str("  env: {\n");
        current_line += 1;
        output.push_str("    memory: new WebAssembly.Memory({ initial: 256, maximum: 256 }),\n");
        current_line += 1;
        output.push_str("  }\n");
        current_line += 1;
        output.push_str("});\n\n");
        current_line += 2;

        // Generate server function implementations
        output.push_str("// Server function implementations\n");
        current_line += 1;
        for func in &self.splitter.server_functions {
            let func_code = self.generate_function_impl(func, true);

            // Add source mapping for function declaration
            // Note: Would ideally use actual source location from AST
            source_map.add_mapping(
                current_line,
                0,
                &self.source_file,
                1,  // Placeholder - would need location tracking in AST
                0,
                Some(&func.name.value),
            );

            output.push_str(&func_code);
            current_line += func_code.lines().count();
            output.push_str("\n\n");
            current_line += 2;
        }

        // Generate shared function implementations
        output.push_str("// Shared utility functions\n");
        current_line += 1;
        for func in &self.splitter.shared_functions {
            let func_code = self.generate_function_impl(func, true);

            // Add source mapping for function declaration
            source_map.add_mapping(
                current_line,
                0,
                &self.source_file,
                1,  // Placeholder - would need location tracking in AST
                0,
                Some(&func.name.value),
            );

            output.push_str(&func_code);
            current_line += func_code.lines().count();
            output.push_str("\n\n");
            current_line += 2;
        }

        // Generate RPC handlers
        output.push_str("// RPC Server Setup\n");
        current_line += 1;
        let rpc_gen = RPCGenerator::new(self.splitter.server_functions.clone());
        let rpc_code = rpc_gen.generate_server_handlers();
        output.push_str(&rpc_code);
        current_line += rpc_code.lines().count();

        // Add source map reference comment
        output.push('\n');
        output.push_str(&source_map.generate_reference_comment());
        output.push('\n');

        (output, source_map.generate())
    }

    /// Generates the complete client.js file
    pub fn generate_client_js(&self) -> String {
        let mut output = String::new();
        let source_map = SourceMapBuilder::new("client.js".to_string());

        // Header comment
        output.push_str("// Auto-generated Jounce Client Bundle\n");
        output.push_str("// DO NOT EDIT - Generated by Jounce compiler\n\n");

        // Import runtime
        output.push_str("import { RPCClient, mountComponent } from '../dist/client-runtime.js';\n\n");

        // Node.js crypto module for hashing and random functions
        output.push_str("// Node.js crypto module (for tests and server-side code)\n");
        output.push_str("let __nodeCrypto;\n");
        output.push_str("try {\n");
        output.push_str("  if (typeof require !== 'undefined') {\n");
        output.push_str("    __nodeCrypto = require('crypto');\n");
        output.push_str("  }\n");
        output.push_str("} catch (e) {\n");
        output.push_str("  // crypto module not available (browser environment)\n");
        output.push_str("}\n\n");

        // Crypto helper functions (use Node.js crypto when available)
        output.push_str("// Crypto helpers - use Node.js crypto module when available\n");
        output.push_str("const __crypto_sha256 = function(data) {\n");
        output.push_str("  if (__nodeCrypto) return __nodeCrypto.createHash('sha256').update(data).digest('hex');\n");
        output.push_str("  return ''; // fallback\n");
        output.push_str("};\n");
        output.push_str("const __crypto_sha1 = function(data) {\n");
        output.push_str("  if (__nodeCrypto) return __nodeCrypto.createHash('sha1').update(data).digest('hex');\n");
        output.push_str("  return ''; // fallback\n");
        output.push_str("};\n");
        output.push_str("const __crypto_md5 = function(data) {\n");
        output.push_str("  if (__nodeCrypto) return __nodeCrypto.createHash('md5').update(data).digest('hex');\n");
        output.push_str("  return ''; // fallback\n");
        output.push_str("};\n");
        output.push_str("const __crypto_hmac = function(algo, key, data) {\n");
        output.push_str("  if (__nodeCrypto) return __nodeCrypto.createHmac(algo, key).update(data).digest('hex');\n");
        output.push_str("  return ''; // fallback\n");
        output.push_str("};\n");
        output.push_str("const __crypto_random_bytes = function(len) {\n");
        output.push_str("  if (__nodeCrypto) return Array.from(__nodeCrypto.randomBytes(len));\n");
        output.push_str("  return Array(len).fill(0); // fallback\n");
        output.push_str("};\n");
        output.push_str("const __crypto_pbkdf2 = function(password, salt, iterations, keylen, digest) {\n");
        output.push_str("  if (__nodeCrypto) return __nodeCrypto.pbkdf2Sync(password, salt, iterations, keylen, digest).toString('hex');\n");
        output.push_str("  return ''; // fallback\n");
        output.push_str("};\n\n");

        // Node.js fs module for file system operations
        output.push_str("// Node.js fs module (for server-side file I/O)\n");
        output.push_str("let __nodeFs;\n");
        output.push_str("try {\n");
        output.push_str("  if (typeof require !== 'undefined') {\n");
        output.push_str("    __nodeFs = require('fs');\n");
        output.push_str("  }\n");
        output.push_str("} catch (e) {\n");
        output.push_str("  // fs module not available (browser environment)\n");
        output.push_str("}\n\n");

        // File system helper functions
        output.push_str("// File system helpers - use Node.js fs module when available\n");
        output.push_str("const __fs_read_to_string = function(path) {\n");
        output.push_str("  if (__nodeFs) return __nodeFs.readFileSync(path, 'utf8');\n");
        output.push_str("  throw new Error('File I/O not available in browser');\n");
        output.push_str("};\n");
        output.push_str("const __fs_read_bytes = function(path) {\n");
        output.push_str("  if (__nodeFs) return Array.from(__nodeFs.readFileSync(path));\n");
        output.push_str("  throw new Error('File I/O not available in browser');\n");
        output.push_str("};\n");
        output.push_str("const __fs_write_string = function(path, data) {\n");
        output.push_str("  if (__nodeFs) { __nodeFs.writeFileSync(path, data, 'utf8'); return; }\n");
        output.push_str("  throw new Error('File I/O not available in browser');\n");
        output.push_str("};\n");
        output.push_str("const __fs_write_bytes = function(path, data) {\n");
        output.push_str("  if (__nodeFs) { __nodeFs.writeFileSync(path, Buffer.from(data)); return; }\n");
        output.push_str("  throw new Error('File I/O not available in browser');\n");
        output.push_str("};\n");
        output.push_str("const __fs_append_string = function(path, data) {\n");
        output.push_str("  if (__nodeFs) { __nodeFs.appendFileSync(path, data, 'utf8'); return; }\n");
        output.push_str("  throw new Error('File I/O not available in browser');\n");
        output.push_str("};\n");
        output.push_str("const __fs_exists = function(path) {\n");
        output.push_str("  if (__nodeFs) return __nodeFs.existsSync(path);\n");
        output.push_str("  return false;\n");
        output.push_str("};\n");
        output.push_str("const __fs_metadata = function(path) {\n");
        output.push_str("  if (__nodeFs) {\n");
        output.push_str("    const stats = __nodeFs.statSync(path);\n");
        output.push_str("    const _size = stats.size;\n");
        output.push_str("    const _is_file = stats.isFile();\n");
        output.push_str("    const _is_directory = stats.isDirectory();\n");
        output.push_str("    const _created = stats.birthtimeMs;\n");
        output.push_str("    const _modified = stats.mtimeMs;\n");
        output.push_str("    const _accessed = stats.atimeMs;\n");
        output.push_str("    const _permissions = stats.mode & 0o777;\n");
        output.push_str("    return {\n");
        output.push_str("      size: _size,\n");
        output.push_str("      is_file: () => _is_file,\n");
        output.push_str("      is_directory: () => _is_directory,\n");
        output.push_str("      created: _created,\n");
        output.push_str("      modified: _modified,\n");
        output.push_str("      accessed: _accessed,\n");
        output.push_str("      permissions: _permissions,\n");
        output.push_str("      len: () => _size,\n");
        output.push_str("      is_readonly: () => (_permissions & 128) === 0\n");
        output.push_str("    };\n");
        output.push_str("  }\n");
        output.push_str("  throw new Error('File I/O not available in browser');\n");
        output.push_str("};\n");
        output.push_str("const __fs_read_dir = function(path) {\n");
        output.push_str("  if (__nodeFs) {\n");
        output.push_str("    const entries = __nodeFs.readdirSync(path, { withFileTypes: true });\n");
        output.push_str("    return entries.map(entry => {\n");
        output.push_str("      const fullPath = path + '/' + entry.name;\n");
        output.push_str("      const stats = __nodeFs.statSync(fullPath);\n");
        output.push_str("      const _size = stats.size;\n");
        output.push_str("      const _is_file = stats.isFile();\n");
        output.push_str("      const _is_directory = stats.isDirectory();\n");
        output.push_str("      const metadata = {\n");
        output.push_str("        size: _size,\n");
        output.push_str("        is_file: _is_file,\n");
        output.push_str("        is_directory: _is_directory,\n");
        output.push_str("        created: stats.birthtimeMs,\n");
        output.push_str("        modified: stats.mtimeMs,\n");
        output.push_str("        accessed: stats.atimeMs,\n");
        output.push_str("        permissions: stats.mode & 0o777\n");
        output.push_str("      };\n");
        output.push_str("      return {\n");
        output.push_str("        name: entry.name,\n");
        output.push_str("        path: fullPath,\n");
        output.push_str("        metadata: metadata,\n");
        output.push_str("        is_file: () => _is_file,\n");
        output.push_str("        is_directory: () => _is_directory\n");
        output.push_str("      };\n");
        output.push_str("    });\n");
        output.push_str("  }\n");
        output.push_str("  throw new Error('File I/O not available in browser');\n");
        output.push_str("};\n");
        output.push_str("const __fs_create_dir = function(path) {\n");
        output.push_str("  if (__nodeFs) { __nodeFs.mkdirSync(path); return; }\n");
        output.push_str("  throw new Error('File I/O not available in browser');\n");
        output.push_str("};\n");
        output.push_str("const __fs_create_dir_all = function(path) {\n");
        output.push_str("  if (__nodeFs) { __nodeFs.mkdirSync(path, { recursive: true }); return; }\n");
        output.push_str("  throw new Error('File I/O not available in browser');\n");
        output.push_str("};\n");
        output.push_str("const __fs_remove_file = function(path) {\n");
        output.push_str("  if (__nodeFs) { __nodeFs.unlinkSync(path); return; }\n");
        output.push_str("  throw new Error('File I/O not available in browser');\n");
        output.push_str("};\n");
        output.push_str("const __fs_remove_dir = function(path) {\n");
        output.push_str("  if (__nodeFs) { __nodeFs.rmdirSync(path); return; }\n");
        output.push_str("  throw new Error('File I/O not available in browser');\n");
        output.push_str("};\n");
        output.push_str("const __fs_remove_dir_all = function(path) {\n");
        output.push_str("  if (__nodeFs) { __nodeFs.rmSync(path, { recursive: true, force: true }); return; }\n");
        output.push_str("  throw new Error('File I/O not available in browser');\n");
        output.push_str("};\n");
        output.push_str("const __fs_rename = function(from, to) {\n");
        output.push_str("  if (__nodeFs) { __nodeFs.renameSync(from, to); return; }\n");
        output.push_str("  throw new Error('File I/O not available in browser');\n");
        output.push_str("};\n");
        // Safe wrappers that return Result types
        output.push_str("const __fs_read_to_string_safe = function(path) {\n");
        output.push_str("  try { return Ok(__fs_read_to_string(path)); } catch (e) { return Err(e.message); }\n");
        output.push_str("};\n");
        output.push_str("const __fs_read_bytes_safe = function(path) {\n");
        output.push_str("  try { return Ok(__fs_read_bytes(path)); } catch (e) { return Err(e.message); }\n");
        output.push_str("};\n");
        output.push_str("const __fs_write_string_safe = function(path, data) {\n");
        output.push_str("  try { __fs_write_string(path, data); return Ok(undefined); } catch (e) { return Err(e.message); }\n");
        output.push_str("};\n");
        output.push_str("const __fs_write_bytes_safe = function(path, data) {\n");
        output.push_str("  try { __fs_write_bytes(path, data); return Ok(undefined); } catch (e) { return Err(e.message); }\n");
        output.push_str("};\n");
        output.push_str("const __fs_append_string_safe = function(path, data) {\n");
        output.push_str("  try { __fs_append_string(path, data); return Ok(undefined); } catch (e) { return Err(e.message); }\n");
        output.push_str("};\n");
        output.push_str("const __fs_metadata_safe = function(path) {\n");
        output.push_str("  try { return Ok(__fs_metadata(path)); } catch (e) { return Err(e.message); }\n");
        output.push_str("};\n");
        output.push_str("const __fs_read_dir_safe = function(path) {\n");
        output.push_str("  try { return Ok(__fs_read_dir(path)); } catch (e) { return Err(e.message); }\n");
        output.push_str("};\n");
        output.push_str("const __fs_create_dir_safe = function(path) {\n");
        output.push_str("  try { __fs_create_dir(path); return Ok(undefined); } catch (e) { return Err(e.message); }\n");
        output.push_str("};\n");
        output.push_str("const __fs_create_dir_all_safe = function(path) {\n");
        output.push_str("  try { __fs_create_dir_all(path); return Ok(undefined); } catch (e) { return Err(e.message); }\n");
        output.push_str("};\n");
        output.push_str("const __fs_remove_file_safe = function(path) {\n");
        output.push_str("  try { __fs_remove_file(path); return Ok(undefined); } catch (e) { return Err(e.message); }\n");
        output.push_str("};\n");
        output.push_str("const __fs_remove_dir_safe = function(path) {\n");
        output.push_str("  try { __fs_remove_dir(path); return Ok(undefined); } catch (e) { return Err(e.message); }\n");
        output.push_str("};\n");
        output.push_str("const __fs_remove_dir_all_safe = function(path) {\n");
        output.push_str("  try { __fs_remove_dir_all(path); return Ok(undefined); } catch (e) { return Err(e.message); }\n");
        output.push_str("};\n");
        output.push_str("const __fs_rename_safe = function(from, to) {\n");
        output.push_str("  try { __fs_rename(from, to); return Ok(undefined); } catch (e) { return Err(e.message); }\n");
        output.push_str("};\n\n");

        // Built-in type extensions and aliases
        output.push_str("// Built-in type extensions\n");
        output.push_str("const Vec = Array; // Vec<T> is Array in JavaScript\n");
        output.push_str("Vec.new = function() { return []; }; // Vec::new() creates empty array\n");
        output.push_str("// String methods - ensure they work on both primitives and String objects\n");
        output.push_str("if (!String.prototype.len) {\n");
        output.push_str("  String.prototype.len = function() { return this.length; };\n");
        output.push_str("}\n");
        output.push_str("if (!String.prototype.is_empty) {\n");
        output.push_str("  String.prototype.is_empty = function() { return this.length === 0; };\n");
        output.push_str("}\n");
        output.push_str("if (!String.prototype.chars) {\n");
        output.push_str("  String.prototype.chars = function() { return this.split(''); };\n");
        output.push_str("}\n");
        output.push_str("if (!String.prototype.contains) {\n");
        output.push_str("  String.prototype.contains = function(substr) { return this.includes(substr); };\n");
        output.push_str("}\n");
        output.push_str("if (!String.prototype.starts_with) {\n");
        output.push_str("  String.prototype.starts_with = function(prefix) { return this.startsWith(prefix); };\n");
        output.push_str("}\n");
        output.push_str("if (!String.prototype.ends_with) {\n");
        output.push_str("  String.prototype.ends_with = function(suffix) { return this.endsWith(suffix); };\n");
        output.push_str("}\n");
        output.push_str("if (!String.prototype.to_lowercase) {\n");
        output.push_str("  String.prototype.to_lowercase = function() { return this.toLowerCase(); };\n");
        output.push_str("}\n");
        output.push_str("if (!String.prototype.char_code_at) {\n");
        output.push_str("  String.prototype.char_code_at = function(index) { return this.charCodeAt(index); };\n");
        output.push_str("}\n");
        output.push_str("if (!String.prototype.char_at) {\n");
        output.push_str("  String.prototype.char_at = function(index) { return this.charAt(index); };\n");
        output.push_str("}\n");
        output.push_str("if (!String.prototype.parse_int) {\n");
        output.push_str("  String.prototype.parse_int = function() { return parseInt(this, 10); };\n");
        output.push_str("}\n");
        output.push_str("if (!String.prototype.parse_float) {\n");
        output.push_str("  String.prototype.parse_float = function() { return parseFloat(this); };\n");
        output.push_str("}\n");
        output.push_str("if (!String.prototype.index_of) {\n");
        output.push_str("  String.prototype.index_of = function(substr) { return this.indexOf(substr); };\n");
        output.push_str("}\n");
        output.push_str("if (!String.prototype.clone) {\n");
        output.push_str("  String.prototype.clone = function() { return this.toString(); };\n");
        output.push_str("}\n");
        output.push_str("if (!String.prototype.push_str) {\n");
        output.push_str("  String.prototype.push_str = function(s) { return this + s; };\n");
        output.push_str("}\n");
        output.push_str("if (!String.prototype.to_string) {\n");
        output.push_str("  String.prototype.to_string = function() { return this.toString(); };\n");
        output.push_str("}\n");
        output.push_str("if (!Number.prototype.to_string) {\n");
        output.push_str("  Number.prototype.to_string = function() { return this.toString(); };\n");
        output.push_str("}\n");
        output.push_str("if (!Array.prototype.len) {\n");
        output.push_str("  Array.prototype.len = function() { return this.length; };\n");
        output.push_str("}\n");
        output.push_str("if (!Array.prototype.is_empty) {\n");
        output.push_str("  Array.prototype.is_empty = function() { return this.length === 0; };\n");
        output.push_str("}\n");
        output.push_str("if (!Array.prototype.clone) {\n");
        output.push_str("  Array.prototype.clone = function() { return this.slice(); };\n");
        output.push_str("}\n");
        output.push_str("if (!Object.prototype.keys) {\n");
        output.push_str("  Object.prototype.keys = function() { return Object.keys(this); };\n");
        output.push_str("}\n");
        output.push_str("if (!Object.prototype.clone) {\n");
        output.push_str("  Object.prototype.clone = function() { return JSON.parse(JSON.stringify(this)); };\n");
        output.push_str("}\n");
        output.push_str("if (!String.from_char_code) {\n");
        output.push_str("  String.from_char_code = function(code) { return String.fromCharCode(code); };\n");
        output.push_str("}\n");
        output.push_str("if (!String.new) {\n");
        output.push_str("  String.new = function() {\n");
        output.push_str("    const sb = { __value: \"\" };\n");
        output.push_str("    sb.push_str = function(s) { this.__value += s; };\n");
        output.push_str("    sb.toString = function() { return this.__value; };\n");
        output.push_str("    sb.valueOf = function() { return this.__value; };\n");
        output.push_str("    sb.clone = function() { return this.__value; };\n");
        output.push_str("    sb.len = function() { return this.__value.length; };\n");
        output.push_str("    sb.is_empty = function() { return this.__value.length === 0; };\n");
        output.push_str("    sb.contains = function(s) { return this.__value.includes(s); };\n");
        output.push_str("    sb.trim = function() { return this.__value.trim(); };\n");
        output.push_str("    sb.starts_with = function(s) { return this.__value.startsWith(s); };\n");
        output.push_str("    sb.ends_with = function(s) { return this.__value.endsWith(s); };\n");
        output.push_str("    sb.substring = function(start, end) { return this.__value.substring(start, end); };\n");
        output.push_str("    return sb;\n");
        output.push_str("  };\n");
        output.push_str("}\n");
        output.push_str("if (!String.from) {\n");
        output.push_str("  String.from = function(s) { return String(s); };\n");
        output.push_str("}\n\n");

        // Built-in Result and Option enums (Rust-style error handling)
        output.push_str("// Result<T, E> enum - represents success (Ok) or failure (Err)\n");
        output.push_str("const Result = { __proto__: null };\n");
        output.push_str("Result.prototype = {};\n");
        output.push_str("function Ok(data) { const v = { variant: \"Ok\", data: data }; v.__proto__ = Result.prototype; return v; }\n");
        output.push_str("function Err(data) { const v = { variant: \"Err\", data: data }; v.__proto__ = Result.prototype; return v; }\n");
        output.push_str("Result.prototype.is_ok = function() { return this.variant === \"Ok\"; };\n");
        output.push_str("Result.prototype.is_err = function() { return this.variant === \"Err\"; };\n");
        output.push_str("Result.prototype.unwrap = function() { if (this.variant === \"Ok\") return this.data; throw new Error(\"Called unwrap on Err\"); };\n");
        output.push_str("Result.prototype.unwrap_err = function() { if (this.variant === \"Err\") return this.data; throw new Error(\"Called unwrap_err on Ok\"); };\n");
        output.push_str("Result.prototype.unwrap_or = function(default_val) { return this.variant === \"Ok\" ? this.data : default_val; };\n");
        output.push_str("Result.Ok = Ok;\n");
        output.push_str("Result.Err = Err;\n\n");

        output.push_str("// Option<T> enum - represents Some value or None\n");
        output.push_str("const Option = { __proto__: null };\n");
        output.push_str("Option.prototype = {};\n");
        output.push_str("function Some(data) { const v = { variant: \"Some\", data: data }; v.__proto__ = Option.prototype; return v; }\n");
        output.push_str("const None = (() => { const v = { variant: \"None\" }; v.__proto__ = Option.prototype; return v; })();\n");
        output.push_str("Option.Some = Some;\n");
        output.push_str("Option.None = None;\n");
        output.push_str("Option.prototype.is_some = function() { return this.variant === \"Some\"; };\n");
        output.push_str("Option.prototype.is_none = function() { return this.variant === \"None\"; };\n");
        output.push_str("Option.prototype.unwrap = function() { if (this.variant === \"Some\") return this.data; throw new Error(\"Called unwrap on None\"); };\n");
        output.push_str("Option.prototype.unwrap_or = function(default_val) { return this.variant === \"Some\" ? this.data : default_val; };\n\n");

        // HashMap type alias (JavaScript Map)
        output.push_str("// HashMap<K, V> is a JavaScript Map\n");
        output.push_str("const HashMap = Map;\n");
        output.push_str("HashMap.new = function() { return new Map(); };\n");
        output.push_str("if (!Map.prototype.insert) {\n");
        output.push_str("  Map.prototype.insert = function(k, v) { this.set(k, v); };\n");
        output.push_str("}\n");
        output.push_str("if (!Map.prototype.contains_key) {\n");
        output.push_str("  Map.prototype.contains_key = function(k) { return this.has(k); };\n");
        output.push_str("}\n");
        output.push_str("if (!Map.prototype.get_or_default) {\n");
        output.push_str("  Map.prototype.get_or_default = function(k, def) { return this.has(k) ? this.get(k) : def; };\n");
        output.push_str("}\n");
        output.push_str("if (!Map.prototype.len) {\n");
        output.push_str("  Map.prototype.len = function() { return this.size; };\n");
        output.push_str("}\n");
        output.push_str("if (!Map.prototype.is_empty) {\n");
        output.push_str("  Map.prototype.is_empty = function() { return this.size === 0; };\n");
        output.push_str("}\n\n");

        // Generate RPC client stubs
        output.push_str("// RPC Client Setup\n");
        let rpc_gen = RPCGenerator::new(self.splitter.server_functions.clone());
        output.push_str(&rpc_gen.generate_client_stubs());
        output.push('\n');

        // Generate shared constants
        if !self.splitter.shared_constants.is_empty() {
            output.push_str("// Shared constants\n");
            for const_decl in &self.splitter.shared_constants {
                let value = self.generate_expression_js(&const_decl.value);
                output.push_str(&format!("const {} = {};\n", const_decl.name.value, value));
            }
            output.push_str("\n");
        }

        // Generate struct constructors
        output.push_str("// Struct definitions\n");
        for struct_def in &self.splitter.structs {
            // Generate constructor function
            let params: Vec<String> = struct_def.fields.iter()
                .map(|(name, _)| name.value.clone())
                .collect();
            output.push_str(&format!(
                "function {}({}) {{\n",
                struct_def.name.value,
                params.join(", ")
            ));
            for (field_name, _) in &struct_def.fields {
                output.push_str(&format!("  this.{} = {};\n", field_name.value, field_name.value));
            }
            output.push_str("}\n\n");
        }

        // Generate enum definitions (BEFORE impl blocks!)
        output.push_str("// Enum definitions\n");
        for enum_def in &self.splitter.enums {
            output.push_str(&self.generate_enum_js(enum_def));
            output.push_str("\n");
        }

        // Generate impl blocks (after enums and structs are defined)
        output.push_str("// Implementations\n");
        for impl_block in &self.splitter.impl_blocks {
            output.push_str(&self.generate_impl_block_js(impl_block));
        }

        // Generate client function implementations
        output.push_str("// Client function implementations\n");
        for func in &self.splitter.client_functions {
            output.push_str(&self.generate_function_impl(func, false));
            output.push_str("\n\n");
        }

        // Generate shared function implementations
        output.push_str("// Shared utility functions\n");
        for func in &self.splitter.shared_functions {
            output.push_str(&self.generate_function_impl(func, false));
            output.push_str("\n\n");
        }

        // Create namespace objects for stdlib modules
        output.push_str("// Stdlib module namespaces\n");
        output.push_str("const json = {\n");
        output.push_str("  parse: typeof parse !== 'undefined' ? parse : undefined,\n");
        output.push_str("  stringify: typeof stringify !== 'undefined' ? stringify : undefined,\n");
        output.push_str("  stringify_pretty: typeof stringify_pretty !== 'undefined' ? stringify_pretty : undefined,\n");
        output.push_str("  // Helper functions for creating JSON values\n");
        output.push_str("  null_: () => ({ variant: 'Null' }),\n");
        output.push_str("  bool: (b) => ({ variant: 'Bool', data: b }),\n");
        output.push_str("  number: (n) => ({ variant: 'Number', data: n }),\n");
        output.push_str("  string: (s) => ({ variant: 'String', data: s }),\n");
        output.push_str("  array: (arr) => ({ variant: 'Array', data: arr || [] }),\n");
        output.push_str("  object: (obj) => ({ variant: 'Object', data: obj || {} }),\n");
        output.push_str("};\n\n");

        output.push_str("const crypto = {\n");
        output.push_str("  sha256: typeof sha256 !== 'undefined' ? sha256 : undefined,\n");
        output.push_str("  sha1: typeof sha1 !== 'undefined' ? sha1 : undefined,\n");
        output.push_str("  md5: typeof md5 !== 'undefined' ? md5 : undefined,\n");
        output.push_str("  hmac_sha256: typeof hmac_sha256 !== 'undefined' ? hmac_sha256 : undefined,\n");
        output.push_str("  random_bytes: typeof random_bytes !== 'undefined' ? random_bytes : undefined,\n");
        output.push_str("  random_int: typeof random_int !== 'undefined' ? random_int : undefined,\n");
        output.push_str("  random_float: typeof random_float !== 'undefined' ? random_float : undefined,\n");
        output.push_str("  random_string: typeof random_string !== 'undefined' ? random_string : undefined,\n");
        output.push_str("  random_alphanumeric: typeof random_alphanumeric !== 'undefined' ? random_alphanumeric : undefined,\n");
        output.push_str("  random_hex: typeof random_hex !== 'undefined' ? random_hex : undefined,\n");
        output.push_str("  uuid_v4: typeof uuid_v4 !== 'undefined' ? uuid_v4 : undefined,\n");
        output.push_str("  base64_encode: typeof base64_encode !== 'undefined' ? base64_encode : undefined,\n");
        output.push_str("  base64_decode: typeof base64_decode !== 'undefined' ? base64_decode : undefined,\n");
        output.push_str("  hex_encode: typeof hex_encode !== 'undefined' ? hex_encode : undefined,\n");
        output.push_str("  hex_decode: typeof hex_decode !== 'undefined' ? hex_decode : undefined,\n");
        output.push_str("  hash_password_auto: typeof hash_password_auto !== 'undefined' ? hash_password_auto : undefined,\n");
        output.push_str("  generate_salt: typeof generate_salt !== 'undefined' ? generate_salt : undefined,\n");
        output.push_str("};\n\n");

        output.push_str("const fs = {\n");
        output.push_str("  read_to_string: typeof read_to_string !== 'undefined' ? read_to_string : undefined,\n");
        output.push_str("  read: typeof read !== 'undefined' ? read : undefined,\n");
        output.push_str("  write: typeof write !== 'undefined' ? write : undefined,\n");
        output.push_str("  write_bytes: typeof write_bytes !== 'undefined' ? write_bytes : undefined,\n");
        output.push_str("  append: typeof append !== 'undefined' ? append : undefined,\n");
        output.push_str("  exists: typeof exists !== 'undefined' ? exists : undefined,\n");
        output.push_str("  is_file: typeof is_file !== 'undefined' ? is_file : undefined,\n");
        output.push_str("  is_directory: typeof is_directory !== 'undefined' ? is_directory : undefined,\n");
        output.push_str("  metadata: typeof metadata !== 'undefined' ? metadata : undefined,\n");
        output.push_str("  create_dir: typeof create_dir !== 'undefined' ? create_dir : undefined,\n");
        output.push_str("  create_dir_all: typeof create_dir_all !== 'undefined' ? create_dir_all : undefined,\n");
        output.push_str("  remove_file: typeof remove_file !== 'undefined' ? remove_file : undefined,\n");
        output.push_str("  remove_dir: typeof remove_dir !== 'undefined' ? remove_dir : undefined,\n");
        output.push_str("  remove_dir_all: typeof remove_dir_all !== 'undefined' ? remove_dir_all : undefined,\n");
        output.push_str("  read_dir: typeof read_dir !== 'undefined' ? read_dir : undefined,\n");
        output.push_str("  copy: typeof copy !== 'undefined' ? copy : undefined,\n");
        output.push_str("  rename: typeof rename !== 'undefined' ? rename : undefined,\n");
        output.push_str("  current_dir: typeof current_dir !== 'undefined' ? current_dir : undefined,\n");
        output.push_str("  set_current_dir: typeof set_current_dir !== 'undefined' ? set_current_dir : undefined,\n");
        output.push_str("  canonicalize: typeof canonicalize !== 'undefined' ? canonicalize : undefined,\n");
        output.push_str("  symlink: typeof symlink !== 'undefined' ? symlink : undefined,\n");
        output.push_str("  read_link: typeof read_link !== 'undefined' ? read_link : undefined,\n");
        output.push_str("  set_permissions: typeof set_permissions !== 'undefined' ? set_permissions : undefined,\n");
        output.push_str("  walk_dir: typeof walk_dir !== 'undefined' ? walk_dir : undefined,\n");
        output.push_str("  glob: typeof glob !== 'undefined' ? glob : undefined,\n");
        output.push_str("};\n\n");

        output.push_str("const yaml = {\n");
        output.push_str("  parse: typeof yaml_parse !== 'undefined' ? yaml_parse : undefined,\n");
        output.push_str("  stringify: typeof yaml_stringify !== 'undefined' ? yaml_stringify : undefined,\n");
        output.push_str("  // Helper functions for creating YAML values\n");
        output.push_str("  yaml_null: typeof yaml_null !== 'undefined' ? yaml_null : undefined,\n");
        output.push_str("  yaml_bool: typeof yaml_bool !== 'undefined' ? yaml_bool : undefined,\n");
        output.push_str("  yaml_number: typeof yaml_number !== 'undefined' ? yaml_number : undefined,\n");
        output.push_str("  yaml_string: typeof yaml_string !== 'undefined' ? yaml_string : undefined,\n");
        output.push_str("  yaml_sequence: typeof yaml_sequence !== 'undefined' ? yaml_sequence : undefined,\n");
        output.push_str("  yaml_mapping: typeof yaml_mapping !== 'undefined' ? yaml_mapping : undefined,\n");
        output.push_str("};\n\n");

        // Generate component implementations
        output.push_str("// UI Components\n");
        for comp in &self.splitter.client_components {
            output.push_str(&self.generate_component_impl(comp));
            output.push_str("\n\n");
        }

        // Generate main entry point
        output.push_str("// Initialize application\n");
        output.push_str("window.addEventListener('DOMContentLoaded', () => {\n");
        output.push_str("  console.log('Jounce client initialized');\n");

        // Auto-mount first component if exists
        if let Some(comp) = self.splitter.client_components.first() {
            output.push_str(&format!("  mountComponent({}, document.getElementById('app'));\n", comp.name.value));
        }

        output.push_str("});\n");

        // Add source map reference comment
        output.push('\n');
        output.push_str(&source_map.generate_reference_comment());
        output.push('\n');

        output
    }

    /// Generates the complete client.js file with source map
    #[allow(unused_assignments)] // current_line used for future source map implementation
    pub fn generate_client_js_with_sourcemap(&self) -> (String, String) {
        let mut output = String::new();
        let mut source_map = SourceMapBuilder::new("client.js".to_string());
        let mut current_line = 1;

        // Header comment
        output.push_str("// Auto-generated Jounce Client Bundle\n");
        current_line += 1;
        output.push_str("// DO NOT EDIT - Generated by Jounce compiler\n\n");
        current_line += 2;

        // Import runtime
        output.push_str("import { RPCClient, mountComponent } from '../dist/client-runtime.js';\n\n");
        current_line += 2;

        // Generate RPC client stubs
        output.push_str("// RPC Client Setup\n");
        current_line += 1;
        let rpc_gen = RPCGenerator::new(self.splitter.server_functions.clone());
        let rpc_code = rpc_gen.generate_client_stubs();
        output.push_str(&rpc_code);
        current_line += rpc_code.lines().count();
        output.push('\n');
        current_line += 1;

        // Generate client function implementations
        output.push_str("// Client function implementations\n");
        current_line += 1;
        for func in &self.splitter.client_functions {
            let func_code = self.generate_function_impl(func, false);

            // Add source mapping for function declaration
            source_map.add_mapping(
                current_line,
                0,
                &self.source_file,
                1,  // Placeholder - would need location tracking in AST
                0,
                Some(&func.name.value),
            );

            output.push_str(&func_code);
            current_line += func_code.lines().count();
            output.push_str("\n\n");
            current_line += 2;
        }

        // Generate shared function implementations
        output.push_str("// Shared utility functions\n");
        current_line += 1;
        for func in &self.splitter.shared_functions {
            let func_code = self.generate_function_impl(func, false);

            // Add source mapping for function declaration
            source_map.add_mapping(
                current_line,
                0,
                &self.source_file,
                1,  // Placeholder - would need location tracking in AST
                0,
                Some(&func.name.value),
            );

            output.push_str(&func_code);
            current_line += func_code.lines().count();
            output.push_str("\n\n");
            current_line += 2;
        }

        // Generate component implementations
        output.push_str("// UI Components\n");
        current_line += 1;
        for comp in &self.splitter.client_components {
            let comp_code = self.generate_component_impl(comp);

            // Add source mapping for component declaration
            source_map.add_mapping(
                current_line,
                0,
                &self.source_file,
                1,  // Placeholder - would need location tracking in AST
                0,
                Some(&comp.name.value),
            );

            output.push_str(&comp_code);
            current_line += comp_code.lines().count();
            output.push_str("\n\n");
            current_line += 2;
        }

        // Generate main entry point
        output.push_str("// Initialize application\n");
        current_line += 1;
        output.push_str("window.addEventListener('DOMContentLoaded', () => {\n");
        current_line += 1;
        output.push_str("  console.log('Jounce client initialized');\n");
        current_line += 1;

        // Auto-mount first component if exists
        if let Some(comp) = self.splitter.client_components.first() {
            output.push_str(&format!("  mountComponent({}, document.getElementById('app'));\n", comp.name.value));
            current_line += 1;
        }

        output.push_str("});\n");
        current_line += 1;

        // Add source map reference comment
        output.push('\n');
        output.push_str(&source_map.generate_reference_comment());
        output.push('\n');

        (output, source_map.generate())
    }

    /// Generates a JavaScript function implementation from AST
    fn generate_function_impl(&self, func: &FunctionDefinition, is_server: bool) -> String {
        let name = Self::escape_js_reserved_word(&func.name.value);
        let params = func.parameters
            .iter()
            .map(|p| Self::escape_js_reserved_word(&p.name.value))
            .collect::<Vec<_>>()
            .join(", ");

        let async_keyword = if func.is_async { "async " } else { "" };
        // Use generate_block_js_impl with is_function_body=true to handle implicit returns
        let body = self.generate_block_js_impl(&func.body, true);

        if is_server {
            // Server-side: module.exports.name = function() { ... }
            format!(
                "module.exports.{} = {}function({}) {{\n{}\n}}",
                name, async_keyword, params, body
            )
        } else {
            // Client-side: export function name() { ... }
            format!(
                "export {}function {}({}) {{\n{}\n}}",
                async_keyword, name, params, body
            )
        }
    }

    /// Generates a JavaScript component implementation from AST
    fn generate_component_impl(&self, comp: &ComponentDefinition) -> String {
        let name = Self::escape_js_reserved_word(&comp.name.value);
        let params = comp.parameters
            .iter()
            .map(|p| Self::escape_js_reserved_word(&p.name.value))
            .collect::<Vec<_>>()
            .join(", ");

        let body = self.generate_block_js(&comp.body);

        format!(
            "export function {}({}) {{\n{}\n}}",
            name, params, body
        )
    }

    /// Generates JavaScript code for a block statement
    /// If is_function_body is true, the last expression will be converted to a return statement
    fn generate_block_js_impl(&self, block: &BlockStatement, is_function_body: bool) -> String {
        let mut output = String::new();

        for (i, stmt) in block.statements.iter().enumerate() {
            let is_last = i == block.statements.len() - 1;

            output.push_str("  ");

            // If this is a function body and the last statement, handle implicit returns
            if is_function_body && is_last {
                match stmt {
                    Statement::Expression(expr) => {
                        // Last expression becomes a return
                        output.push_str(&format!("return {};", self.generate_expression_js(expr)));
                    }
                    Statement::If(if_stmt) => {
                        // Convert if/else branches to returns
                        output.push_str(&self.generate_if_with_returns(if_stmt));
                    }
                    _ => {
                        // Other statements (return, let, etc.) stay as-is
                        output.push_str(&self.generate_statement_js(stmt));
                    }
                }
            } else {
                output.push_str(&self.generate_statement_js(stmt));
            }

            output.push('\n');
        }

        output
    }

    /// Generates JavaScript code for a block statement (normal blocks, not function bodies)
    fn generate_block_js(&self, block: &BlockStatement) -> String {
        self.generate_block_js_impl(block, false)
    }

    /// Generates an if statement with return statements in each branch (for implicit returns)
    fn generate_if_with_returns(&self, if_stmt: &crate::ast::IfStatement) -> String {
        let condition = self.generate_expression_js(&if_stmt.condition);

        // Generate then branch with returns
        let mut then_code = String::new();
        for (i, stmt) in if_stmt.then_branch.statements.iter().enumerate() {
            let is_last = i == if_stmt.then_branch.statements.len() - 1;
            then_code.push_str("  ");

            if is_last {
                match stmt {
                    Statement::Expression(expr) => {
                        then_code.push_str(&format!("return {};", self.generate_expression_js(expr)));
                    }
                    Statement::If(nested_if) => {
                        then_code.push_str(&self.generate_if_with_returns(nested_if));
                    }
                    _ => {
                        then_code.push_str(&self.generate_statement_js(stmt));
                    }
                }
            } else {
                then_code.push_str(&self.generate_statement_js(stmt));
            }
            then_code.push('\n');
        }

        if let Some(else_branch) = &if_stmt.else_branch {
            let else_code = match &**else_branch {
                Statement::If(nested_if) => {
                    self.generate_if_with_returns(nested_if)
                }
                Statement::Expression(Expression::Block(block)) => {
                    let mut code = String::new();
                    for (i, stmt) in block.statements.iter().enumerate() {
                        let is_last = i == block.statements.len() - 1;
                        code.push_str("  ");

                        if is_last {
                            match stmt {
                                Statement::Expression(expr) => {
                                    code.push_str(&format!("return {};", self.generate_expression_js(expr)));
                                }
                                Statement::If(nested_if) => {
                                    code.push_str(&self.generate_if_with_returns(nested_if));
                                }
                                _ => {
                                    code.push_str(&self.generate_statement_js(stmt));
                                }
                            }
                        } else {
                            code.push_str(&self.generate_statement_js(stmt));
                        }
                        code.push('\n');
                    }
                    code
                }
                _ => {
                    format!("  {}\n", self.generate_statement_js(else_branch))
                }
            };

            format!("if ({}) {{\n{}\n  }} else {{\n{}\n  }}", condition, then_code, else_code)
        } else {
            format!("if ({}) {{\n{}\n  }}", condition, then_code)
        }
    }

    /// Generates JavaScript code for a statement
    fn generate_statement_js(&self, stmt: &Statement) -> String {
        match stmt {
            Statement::Let(let_stmt) => {
                use crate::ast::Pattern;

                // All let statements become 'let' in JS (Jounce tracks mutability)
                let value = self.generate_expression_js(&let_stmt.value);

                // Generate pattern for left-hand side
                let pattern_str = match &let_stmt.pattern {
                    Pattern::Identifier(id) => id.value.clone(),
                    Pattern::Tuple(patterns) => {
                        // Generate tuple destructuring: let [a, b, c] = value;
                        let names: Vec<String> = patterns.iter().map(|p| {
                            match p {
                                Pattern::Identifier(id) => id.value.clone(),
                                _ => "_".to_string(),  // Nested patterns become wildcards for now
                            }
                        }).collect();
                        format!("[{}]", names.join(", "))
                    }
                    _ => "_".to_string(),  // Other patterns become wildcards
                };

                // Special case: if pattern is "_", just execute the expression (discard result)
                if pattern_str == "_" {
                    format!("{};", value)
                } else {
                    format!("let {} = {};", pattern_str, value)
                }
            }
            Statement::Const(const_decl) => {
                // Emit const declarations as JavaScript const
                let value = self.generate_expression_js(&const_decl.value);
                format!("const {} = {};", const_decl.name.value, value)
            }
            Statement::Assignment(assign_stmt) => {
                let target = self.generate_expression_js(&assign_stmt.target);
                let value = self.generate_expression_js(&assign_stmt.value);
                format!("{} = {};", target, value)
            }
            Statement::Return(ret_stmt) => {
                let value = self.generate_expression_js(&ret_stmt.value);
                format!("return {};", value)
            }
            Statement::Expression(expr) => {
                format!("{};", self.generate_expression_js(expr))
            }
            Statement::If(if_stmt) => {
                let condition = self.generate_expression_js(&if_stmt.condition);
                let then_body = self.generate_block_js(&if_stmt.then_branch);

                if let Some(else_branch) = &if_stmt.else_branch {
                    let else_body = match &**else_branch {
                        Statement::If(_) => self.generate_statement_js(else_branch),
                        _ => format!("{{\n{}\n  }}", self.generate_statement_js(else_branch)),
                    };
                    format!("if ({}) {{\n{}\n  }} else {}", condition, then_body, else_body)
                } else {
                    format!("if ({}) {{\n{}\n  }}", condition, then_body)
                }
            }
            Statement::While(while_stmt) => {
                let condition = self.generate_expression_js(&while_stmt.condition);
                let body = self.generate_block_js(&while_stmt.body);
                format!("while ({}) {{\n{}\n  }}", condition, body)
            }
            Statement::Loop(loop_stmt) => {
                let body = self.generate_block_js(&loop_stmt.body);
                format!("while (true) {{\n{}\n  }}", body)
            }
            Statement::Break => "break".to_string(),
            Statement::Continue => "continue".to_string(),
            Statement::Enum(enum_def) => {
                self.generate_enum_js(enum_def)
            }
            Statement::ForIn(for_in_stmt) => {
                self.generate_for_in_js(for_in_stmt)
            }
            Statement::For(for_stmt) => {
                self.generate_for_js(for_stmt)
            }
            Statement::Trait(_) => {
                // Traits are compile-time only, don't generate any JavaScript
                String::new()
            }
            Statement::ImplBlock(impl_block) => {
                self.generate_impl_block_js(impl_block)
            }
            _ => "// Unsupported statement".to_string(),
        }
    }

    /// Generates JavaScript for a for-in loop
    fn generate_for_in_js(&self, stmt: &ForInStatement) -> String {
        // Check if the iterator is a range expression
        if let Expression::Range(range) = &stmt.iterator {
            // Generate a JavaScript for loop from the range
            let start = if let Some(start_expr) = &range.start {
                self.generate_expression_js(start_expr)
            } else {
                "0".to_string()
            };

            let end = if let Some(end_expr) = &range.end {
                self.generate_expression_js(end_expr)
            } else {
                return "// ERROR: Range must have an end value".to_string();
            };

            let comparison = if range.inclusive { "<=" } else { "<" };
            let body = self.generate_block_js(&stmt.body);

            format!(
                "for (let {} = {}; {} {} {}; {}++) {{\n{}\n  }}",
                stmt.variable.value, start, stmt.variable.value, comparison, end, stmt.variable.value, body
            )
        } else {
            // Regular for-in loop over an iterable
            let iterator = self.generate_expression_js(&stmt.iterator);
            let body = self.generate_block_js(&stmt.body);
            format!("for (const {} of {}) {{\n{}\n  }}", stmt.variable.value, iterator, body)
        }
    }

    /// Generates JavaScript for a C-style for loop
    fn generate_for_js(&self, stmt: &ForStatement) -> String {
        let init = if let Some(init_stmt) = &stmt.init {
            // Strip semicolon from init statement if present
            let init_str = self.generate_statement_js(init_stmt);
            init_str.trim_end_matches(';').to_string()
        } else {
            "".to_string()
        };

        let condition = self.generate_expression_js(&stmt.condition);

        let update = if let Some(update_stmt) = &stmt.update {
            // Strip semicolon from update statement if present
            let update_str = self.generate_statement_js(update_stmt);
            update_str.trim_end_matches(';').to_string()
        } else {
            "".to_string()
        };

        let body = self.generate_block_js(&stmt.body);

        format!("for ({}; {}; {}) {{\n{}\n  }}", init, condition, update, body)
    }

    /// Generates JavaScript helper functions for enum variants
    /// Collect all variant names from all enums to detect conflicts
    fn collect_variant_conflicts(&self) -> std::collections::HashMap<String, Vec<String>> {
        use std::collections::HashMap;
        let mut variant_to_enums: HashMap<String, Vec<String>> = HashMap::new();

        for enum_def in &self.splitter.enums {
            for variant in &enum_def.variants {
                let variant_name = variant.name.value.clone();
                variant_to_enums
                    .entry(variant_name)
                    .or_insert_with(Vec::new)
                    .push(enum_def.name.value.clone());
            }
        }

        // Filter to only conflicts (variants used in multiple enums)
        variant_to_enums.retain(|_, enums| enums.len() > 1);
        variant_to_enums
    }

    fn generate_enum_js(&self, enum_def: &crate::ast::EnumDefinition) -> String {
        let mut code = String::new();
        let enum_name = &enum_def.name.value;

        code.push_str(&format!("// Enum: {}\n", enum_name));

        // Create a base constructor for the enum to enable prototype methods
        code.push_str(&format!("function {}() {{}}\n", enum_name));

        // List of JavaScript built-in identifiers that should not be shadowed
        const JS_BUILTINS: &[&str] = &[
            "String", "Number", "Boolean", "Array", "Object", "Function",
            "Date", "RegExp", "Error", "Math", "JSON", "Promise",
            "Map", "Set", "WeakMap", "WeakSet", "Symbol", "BigInt",
        ];

        // Collect cross-enum conflicts
        let variant_conflicts = self.collect_variant_conflicts();

        for variant in &enum_def.variants {
            let variant_name = &variant.name.value;

            // Check if variant name conflicts with:
            // 1. JS built-ins, or
            // 2. Variants from other enums (cross-enum conflict)
            let needs_prefix = JS_BUILTINS.contains(&variant_name.as_str())
                || variant_conflicts.contains_key(variant_name);

            let safe_variant_name = if needs_prefix {
                // Prefix with enum name to avoid shadowing
                format!("{}_{}", enum_name, variant_name)
            } else {
                variant_name.clone()
            };

            if let Some(fields) = &variant.fields {
                // Variant with data - generate constructor function
                if fields.len() == 1 {
                    // Single field - simple constructor
                    // Set __proto__ to enable instance methods
                    code.push_str(&format!(
                        "function {}(data) {{ const v = {{ variant: \"{}\", data: data }}; v.__proto__ = {}.prototype; return v; }}\n",
                        safe_variant_name, variant_name, enum_name
                    ));
                } else {
                    // Multiple fields - use spread/array
                    code.push_str(&format!(
                        "function {}(...data) {{ const v = {{ variant: \"{}\", data: data }}; v.__proto__ = {}.prototype; return v; }}\n",
                        safe_variant_name, variant_name, enum_name
                    ));
                }
                // Also assign as property on the enum namespace
                code.push_str(&format!("{}.{} = {};\n", enum_name, variant_name, safe_variant_name));
            } else {
                // Unit variant - no data
                // Create object with prototype and variant property
                code.push_str(&format!(
                    "const {} = (() => {{ const v = {{ variant: \"{}\" }}; v.__proto__ = {}.prototype; return v; }})();\n",
                    safe_variant_name, variant_name, enum_name
                ));
                // Also assign as property on the enum namespace
                code.push_str(&format!("{}.{} = {};\n", enum_name, variant_name, safe_variant_name));
            }
        }

        code
    }

    /// Generates JavaScript code for an expression
    fn generate_expression_js(&self, expr: &Expression) -> String {
        match expr {
            Expression::Identifier(ident) => {
                // Handle namespaced identifiers (e.g., Stopwatch::new, json::parse)
                // Convert :: to . for JavaScript (e.g., Stopwatch.new, json.parse)
                ident.value.replace("::", ".")
            }
            Expression::IntegerLiteral(value) => value.to_string(),
            Expression::FloatLiteral(value) => value.clone(),
            Expression::StringLiteral(value) => {
                // Escape string for JavaScript output
                let escaped = value
                    .replace('\\', "\\\\")  // Backslash must be first
                    .replace('"', "\\\"")   // Escape quotes
                    .replace('\n', "\\n")   // Escape newlines
                    .replace('\r', "\\r")   // Escape carriage returns
                    .replace('\t', "\\t");  // Escape tabs
                format!("\"{}\"", escaped)
            }
            Expression::BoolLiteral(value) => value.to_string(),
            Expression::UnitLiteral => "undefined".to_string(),  // () maps to undefined in JS
            Expression::Infix(infix) => {
                let left = self.generate_expression_js(&infix.left);
                let right = self.generate_expression_js(&infix.right);
                let op = &infix.operator.lexeme;
                format!("({} {} {})", left, op, right)
            }
            Expression::Prefix(prefix) => {
                let operand = self.generate_expression_js(&prefix.right);
                format!("({}{})", prefix.operator.lexeme, operand)
            }
            Expression::Spread(spread) => {
                // Generate JavaScript spread operator: ...expr
                let expr = self.generate_expression_js(&spread.expression);
                format!("...{}", expr)
            }
            Expression::FunctionCall(call) => {
                let func = self.generate_expression_js(&call.function);
                let args = call.arguments
                    .iter()
                    .map(|arg| self.generate_expression_js(arg))
                    .collect::<Vec<_>>()
                    .join(", ");

                // Check if this is a server function call from client-side
                if let Expression::Identifier(ident) = &*call.function {
                    if self.is_server_function(&ident.value) {
                        return format!("await {}({})", func, args);
                    }
                }

                format!("{}({})", func, args)
            }
            Expression::MacroCall(macro_call) => {
                // Generate JavaScript for macro calls
                let args = macro_call.arguments
                    .iter()
                    .map(|arg| self.generate_expression_js(arg))
                    .collect::<Vec<_>>();

                // Map Rust-like macros to JavaScript equivalents
                match macro_call.name.value.as_str() {
                    "vec" => format!("[{}]", args.join(", ")),
                    "println" => {
                        // Handle println! with format string support
                        if args.is_empty() {
                            "console.log()".to_string()
                        } else if args.len() == 1 {
                            // Single argument - just print it
                            format!("console.log({})", args[0])
                        } else {
                            // Multiple arguments - format string + args
                            let format_str = args[0].trim_matches('"');
                            let mut result = format_str.to_string();

                            // Replace each {} with ${arg}
                            for arg in args.iter().skip(1) {
                                result = result.replacen("{}", &format!("${{{}}}", arg), 1);
                            }

                            format!("console.log(`{}`)", result)
                        }
                    }
                    "format" => {
                        // Handle format! macro with string interpolation
                        if args.is_empty() {
                            "``".to_string()
                        } else if args.len() == 1 {
                            // Just a format string, no interpolation
                            format!("`{}`", args[0].trim_matches('"'))
                        } else {
                            // Format string + arguments to interpolate
                            let format_str = args[0].trim_matches('"');
                            let mut result = format_str.to_string();

                            // Replace each {} with ${arg}
                            for arg in args.iter().skip(1) {
                                result = result.replacen("{}", &format!("${{{}}}", arg), 1);
                            }

                            format!("`{}`", result)
                        }
                    }
                    "panic" => format!("throw new Error({})", args.join(", ")),
                    _ => format!("{}({})", macro_call.name.value, args.join(", ")),
                }
            }
            Expression::IndexAccess(index) => {
                let array = self.generate_expression_js(&index.array);

                // Check if the index is a Range expression (for slicing)
                if let Expression::Range(range) = &*index.index {
                    // Generate arr.slice(start, end) for slicing
                    let start = if let Some(start_expr) = &range.start {
                        self.generate_expression_js(start_expr)
                    } else {
                        "0".to_string()
                    };

                    let end = if let Some(end_expr) = &range.end {
                        let end_code = self.generate_expression_js(end_expr);
                        // For inclusive range (..=), we need to add 1 to the end
                        if range.inclusive {
                            format!("({} + 1)", end_code)
                        } else {
                            end_code
                        }
                    } else {
                        "undefined".to_string()
                    };

                    format!("{}.slice({}, {})", array, start, end)
                } else {
                    // Regular index access
                    let idx = self.generate_expression_js(&index.index);
                    format!("{}[{}]", array, idx)
                }
            }
            Expression::ArrayLiteral(array) => {
                let elements = array.elements
                    .iter()
                    .map(|elem| self.generate_expression_js(elem))
                    .collect::<Vec<_>>()
                    .join(", ");
                format!("[{}]", elements)
            }
            Expression::StructLiteral(struct_lit) => {
                // Generate constructor call: new StructName(field1, field2, ...)
                // Extract field values in the order they appear
                let struct_name = &struct_lit.name.value;
                let field_values = struct_lit.fields
                    .iter()
                    .map(|(_name, value)| self.generate_expression_js(value))
                    .collect::<Vec<_>>()
                    .join(", ");
                format!("new {}({})", struct_name, field_values)
            }
            Expression::FieldAccess(field) => {
                let object = self.generate_expression_js(&field.object);
                format!("{}.{}", object, field.field.value)
            }
            Expression::JsxElement(jsx) => {
                self.generate_jsx_js(jsx)
            }
            Expression::Await(await_expr) => {
                // Generate JavaScript await expression
                let inner = self.generate_expression_js(&await_expr.expression);
                format!("await {}", inner)
            }
            Expression::TryOperator(try_expr) => {
                // Generate JavaScript for ? operator (error propagation)
                // For now, use unwrap() - proper early return requires statement-level transformation
                // TODO: Implement proper early return at function body level
                let inner = self.generate_expression_js(&try_expr.expression);
                format!("({}.unwrap())", inner)
            }
            Expression::Ternary(ternary) => {
                // Generate JavaScript ternary expression: condition ? true_expr : false_expr
                let condition = self.generate_expression_js(&ternary.condition);
                let true_expr = self.generate_expression_js(&ternary.true_expr);
                let false_expr = self.generate_expression_js(&ternary.false_expr);
                format!("({} ? {} : {})", condition, true_expr, false_expr)
            }
            Expression::TypeCast(type_cast) => {
                // Generate JavaScript type cast - in JS this is mostly a no-op, but we emit for clarity
                // For numeric conversions, we use Number(), Math.floor(), etc.
                let expr_code = self.generate_expression_js(&type_cast.expression);

                // Extract type name from TypeExpression
                let type_name = match &type_cast.target_type {
                    TypeExpression::Named(ident) => ident.value.as_str(),
                    _ => return expr_code, // For complex types, just pass through
                };

                match type_name {
                    "i32" | "i64" | "isize" | "u32" | "u64" | "usize" => {
                        // Integer cast: use Math.floor for safety
                        format!("Math.floor({})", expr_code)
                    }
                    "f32" | "f64" => {
                        // Float cast: use Number() or just pass through
                        format!("Number({})", expr_code)
                    }
                    "bool" => {
                        // Boolean cast
                        format!("Boolean({})", expr_code)
                    }
                    _ => {
                        // For other types, just emit the expression (structural compatibility)
                        expr_code
                    }
                }
            }
            Expression::Match(match_expr) => {
                self.generate_match_expression_js(match_expr)
            }
            Expression::IfExpression(if_expr) => {
                // Generate JavaScript for if/else expressions
                let condition = self.generate_expression_js(&if_expr.condition);

                // Check if branches are simple expressions or blocks
                let then_code = self.generate_expression_js(&if_expr.then_expr);

                if let Some(else_expr) = &if_expr.else_expr {
                    let else_code = self.generate_expression_js(else_expr);
                    // Use an IIFE to create an expression that returns a value
                    format!("(() => {{ if ({}) {{ return {}; }} else {{ return {}; }} }})()",
                            condition, then_code, else_code)
                } else {
                    // No else branch - just generate if statement (returns undefined if condition is false)
                    format!("(() => {{ if ({}) {{ return {}; }} }})()", condition, then_code)
                }
            }
            Expression::Block(block) => {
                // Generate JavaScript for block expressions
                // Blocks are used in match arms, if expressions, etc.
                let mut code = String::new();
                for (i, stmt) in block.statements.iter().enumerate() {
                    // Check if this is the last statement and it's an expression (implicit return)
                    if i == block.statements.len() - 1 {
                        if let Statement::Expression(expr) = stmt {
                            // Last expression in block is an implicit return
                            code.push_str(&self.generate_expression_js(expr));
                        } else {
                            // Last statement is not an expression, generate normally
                            code.push_str(&self.generate_statement_js(stmt));
                        }
                    } else {
                        // Not the last statement, generate normally with newline
                        code.push_str(&self.generate_statement_js(stmt));
                        code.push_str("\n");
                    }
                }
                code
            }
            Expression::Dereference(deref_expr) => {
                // In JavaScript, we don't have explicit dereferencing
                // Just generate the inner expression directly
                self.generate_expression_js(&deref_expr.expression)
            }
            Expression::Borrow(borrow_expr) => {
                // In JavaScript, we don't have explicit borrowing
                // Just generate the inner expression directly
                self.generate_expression_js(&borrow_expr.expression)
            }
            Expression::MutableBorrow(borrow_expr) => {
                // In JavaScript, we don't have explicit mutable borrowing
                // Just generate the inner expression directly
                self.generate_expression_js(&borrow_expr.expression)
            }
            _ => "/* Unsupported expression */".to_string(),
        }
    }

    /// Generates JavaScript code for a match expression
    /// Enums are represented as: { variant: "VariantName", data: value }
    fn generate_match_expression_js(&self, match_expr: &crate::ast::MatchExpression) -> String {
        let scrutinee = self.generate_expression_js(&match_expr.scrutinee);

        // Generate an IIFE (Immediately Invoked Function Expression) for the match
        let mut code = format!("(() => {{\n");
        code.push_str(&format!("  const __match_value = {};\n", scrutinee));

        // Generate nested if-else for each arm
        for (i, arm) in match_expr.arms.iter().enumerate() {
            // Generate OR condition for multiple patterns: pattern1 || pattern2 || pattern3
            let conditions: Vec<String> = arm.patterns.iter()
                .map(|p| self.generate_pattern_condition_js(p, "__match_value"))
                .collect();
            let condition = if conditions.len() == 1 {
                conditions[0].clone()
            } else {
                format!("({})", conditions.join(" || "))
            };

            // Use the first pattern for body generation (all OR patterns must bind the same variables)
            let body = self.generate_pattern_body_js(&arm.patterns[0], "__match_value", &arm.body);

            // Check if all patterns are wildcards or identifiers (always match)
            let is_wildcard_arm = arm.patterns.iter().all(|p| matches!(p, Pattern::Wildcard | Pattern::Identifier(_)));

            if i == 0 {
                code.push_str(&format!("  if ({}) {{\n", condition));
            } else if is_wildcard_arm {
                // Wildcard or identifier patterns - no condition needed (always matches)
                code.push_str("  else {\n");
            } else {
                code.push_str(&format!("  else if ({}) {{\n", condition));
            }

            code.push_str(&format!("    return {};\n", body));
            code.push_str("  }\n");
        }

        code.push_str("})()");
        code
    }

    /// Generates the condition for a pattern match
    fn generate_pattern_condition_js(&self, pattern: &Pattern, scrutinee_var: &str) -> String {
        match pattern {
            Pattern::Wildcard | Pattern::Identifier(_) => {
                // Wildcards and identifiers always match
                "true".to_string()
            }
            Pattern::Tuple(_) => {
                // TODO: Implement tuple pattern matching
                // For now, treat as wildcard
                "true".to_string()
            }
            Pattern::Literal(expr) => {
                // Compare with literal value
                let literal_val = self.generate_expression_js(expr);
                format!("{} === {}", scrutinee_var, literal_val)
            }
            Pattern::EnumVariant { name, .. } => {
                // Extract the variant name (after :: if present)
                let variant_name = if name.value.contains("::") {
                    name.value.split("::").last().unwrap_or(&name.value)
                } else {
                    &name.value
                };
                format!("{}.variant === \"{}\"", scrutinee_var, variant_name)
            }
        }
    }

    /// Generates the body for a pattern match, including variable bindings
    fn generate_pattern_body_js(&self, pattern: &Pattern, scrutinee_var: &str, body_expr: &Expression) -> String {
        // Check if body is a Block expression with multiple statements
        let is_block = matches!(body_expr, Expression::Block(_));

        match pattern {
            Pattern::Identifier(ident) => {
                // Bind the scrutinee to the identifier
                if is_block {
                    // For block bodies, generate statements with binding at the start
                    if let Expression::Block(block) = body_expr {
                        if block.statements.is_empty() {
                            // Empty block with binding - just return undefined
                            return "undefined".to_string();
                        }

                        let mut code = format!("(() => {{ const {} = {};\n", ident.value, scrutinee_var);
                        for (i, stmt) in block.statements.iter().enumerate() {
                            if i == block.statements.len() - 1 {
                                // Last statement - add return if it's an expression
                                if let Statement::Expression(expr) = stmt {
                                    code.push_str(&format!("return {}; }})()", self.generate_expression_js(expr)));
                                } else {
                                    code.push_str(&self.generate_statement_js(stmt));
                                    code.push_str(" })()");
                                }
                            } else {
                                code.push_str(&self.generate_statement_js(stmt));
                                code.push('\n');
                            }
                        }
                        code
                    } else {
                        unreachable!()
                    }
                } else {
                    let body = self.generate_expression_js(body_expr);
                    format!("(() => {{ const {} = {}; return {}; }})()", ident.value, scrutinee_var, body)
                }
            }
            Pattern::EnumVariant { fields: Some(field_patterns), .. } => {
                // Extract fields from enum variant
                let mut bindings = Vec::new();
                for (i, field_pattern) in field_patterns.iter().enumerate() {
                    if let Pattern::Identifier(ident) = field_pattern {
                        // For tuple-style variants, data is a single value or array
                        if field_patterns.len() == 1 {
                            bindings.push(format!("const {} = {}.data", ident.value, scrutinee_var));
                        } else {
                            bindings.push(format!("const {} = {}.data[{}]", ident.value, scrutinee_var, i));
                        }
                    }
                }

                if is_block {
                    // For block bodies with bindings, generate statements properly
                    if let Expression::Block(block) = body_expr {
                        if block.statements.is_empty() {
                            // Empty block - just return undefined
                            return "undefined".to_string();
                        }

                        let mut code = format!("(() => {{ {};\n", bindings.join("; "));
                        for (i, stmt) in block.statements.iter().enumerate() {
                            if i == block.statements.len() - 1 {
                                if let Statement::Expression(expr) = stmt {
                                    code.push_str(&format!("return {}; }})()", self.generate_expression_js(expr)));
                                } else {
                                    code.push_str(&self.generate_statement_js(stmt));
                                    code.push_str(" })()");
                                }
                            } else {
                                code.push_str(&self.generate_statement_js(stmt));
                                code.push('\n');
                            }
                        }
                        code
                    } else {
                        unreachable!()
                    }
                } else {
                    let body = self.generate_expression_js(body_expr);
                    if bindings.is_empty() {
                        body
                    } else {
                        format!("(() => {{ {}; return {}; }})()", bindings.join("; "), body)
                    }
                }
            }
            _ => {
                // No bindings needed
                if is_block {
                    // Generate block with proper returns
                    if let Expression::Block(block) = body_expr {
                        if block.statements.is_empty() {
                            // Empty block - just return undefined
                            return "undefined".to_string();
                        }

                        let mut code = String::from("(() => {");
                        for (i, stmt) in block.statements.iter().enumerate() {
                            code.push('\n');
                            if i == block.statements.len() - 1 {
                                if let Statement::Expression(expr) = stmt {
                                    code.push_str(&format!("return {}; }})()", self.generate_expression_js(expr)));
                                } else {
                                    code.push_str(&self.generate_statement_js(stmt));
                                    code.push_str(" })()");
                                }
                            } else {
                                code.push_str(&self.generate_statement_js(stmt));
                            }
                        }
                        code
                    } else {
                        unreachable!()
                    }
                } else {
                    self.generate_expression_js(body_expr)
                }
            }
        }
    }

    /// Generates JavaScript code for JSX
    fn generate_jsx_js(&self, jsx: &crate::ast::JsxElement) -> String {
        let tag = &jsx.opening_tag.name.value;

        // Generate attributes
        let attrs = if jsx.opening_tag.attributes.is_empty() {
            String::new()
        } else {
            let attrs_str = jsx.opening_tag.attributes
                .iter()
                .map(|attr| {
                    let val = self.generate_expression_js(&attr.value);
                    format!("{}: {}", attr.name.value, val)
                })
                .collect::<Vec<_>>()
                .join(", ");
            format!(", {{ {} }}", attrs_str)
        };

        // Generate children
        let children = jsx.children
            .iter()
            .map(|child| match child {
                crate::ast::JsxChild::Element(elem) => self.generate_jsx_js(elem),
                crate::ast::JsxChild::Text(text) => format!("\"{}\"", text),
                crate::ast::JsxChild::Expression(expr) => self.generate_expression_js(expr),
            })
            .collect::<Vec<_>>()
            .join(", ");

        if children.is_empty() {
            format!("h('{}'{}, null)", tag, attrs)
        } else {
            format!("h('{}'{}, {})", tag, attrs, children)
        }
    }

    /// Checks if a function name is a server function
    fn is_server_function(&self, name: &str) -> bool {
        self.splitter.server_functions
            .iter()
            .any(|f| f.name.value == name)
    }

    /// Generates JavaScript for an impl block
    fn generate_impl_block_js(&self, impl_block: &ImplBlock) -> String {
        let type_name = &impl_block.type_name.value;
        let mut js = String::new();

        for method in &impl_block.methods {
            let method_name = &method.name.value;

            // Check if method is static (no self parameter)
            let has_self = method.parameters.iter().any(|p| p.name.value == "self");

            // Generate parameter list (skip first param if it's self/Self)
            let params: Vec<String> = method.parameters.iter()
                .skip_while(|p| {
                    // Skip self parameter
                    let param_name = &p.name.value;
                    param_name == "self"
                })
                .map(|p| p.name.value.clone())
                .collect();

            // Generate method body (with implicit returns for last expression)
            let body = self.generate_block_js_impl(&method.body, true);

            if has_self {
                // Instance method - add to prototype
                // Add "const self = this;" at the start of the method body
                js.push_str(&format!(
                    "{}.prototype.{} = function({}) {{\n  const self = this;\n{}\n}};\n\n",
                    type_name,
                    method_name,
                    params.join(", "),
                    body
                ));
            } else {
                // Static method - add directly to constructor
                js.push_str(&format!(
                    "{}.{} = function({}) {{\n{}\n}};\n\n",
                    type_name,
                    method_name,
                    params.join(", "),
                    body
                ));
            }
        }

        js
    }

    /// Returns statistics about the generated code
    pub fn stats(&self) -> EmitterStats {
        EmitterStats {
            server_functions: self.splitter.server_functions.len(),
            client_functions: self.splitter.client_functions.len(),
            shared_functions: self.splitter.shared_functions.len(),
            client_components: self.splitter.client_components.len(),
        }
    }
}

#[derive(Debug, Clone)]
pub struct EmitterStats {
    pub server_functions: usize,
    pub client_functions: usize,
    pub shared_functions: usize,
    pub client_components: usize,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::lexer::Lexer;
    use crate::parser::Parser;

    #[test]
    fn test_server_js_generation() {
        let source = r#"
            @server
            fn get_user(id: i32) -> String {
                return "John Doe";
            }

            fn format_name(first: String, last: String) -> String {
                return first + " " + last;
            }
        "#;

        let mut lexer = Lexer::new(source.to_string());
        let mut parser = Parser::new(&mut lexer);
        let program = parser.parse_program().expect("Parse failed");

        let emitter = JSEmitter::new(&program);
        let server_js = emitter.generate_server_js();

        // Verify server.js contains expected code
        assert!(server_js.contains("HttpServer"));
        // After Sprint 2 fix, server functions use module.exports.name = function() format
        assert!(server_js.contains("module.exports.get_user = function"));
        assert!(server_js.contains("module.exports.format_name = function"));
        assert!(server_js.contains("WebAssembly"));
        assert!(server_js.contains("server.rpc('get_user'"));
    }

    #[test]
    fn test_client_js_generation() {
        let source = r#"
            @server
            fn get_user(id: i32) -> String {
                return "John Doe";
            }

            @client
            fn render_user(name: String) -> String {
                return "User: " + name;
            }

            fn format_name(first: String, last: String) -> String {
                return first + " " + last;
            }
        "#;

        let mut lexer = Lexer::new(source.to_string());
        let mut parser = Parser::new(&mut lexer);
        let program = parser.parse_program().expect("Parse failed");

        let emitter = JSEmitter::new(&program);
        let client_js = emitter.generate_client_js();

        // Verify client.js contains expected code
        assert!(client_js.contains("RPCClient"));
        assert!(client_js.contains("async function get_user"));  // RPC stub
        assert!(client_js.contains("export function render_user"));  // Client function
        assert!(client_js.contains("export function format_name"));  // Shared function
        assert!(client_js.contains("DOMContentLoaded"));
    }

    #[test]
    fn test_stats() {
        let source = r#"
            @server fn s1() {}
            @server fn s2() {}
            @client fn c1() {}
            fn shared1() {}
        "#;

        let mut lexer = Lexer::new(source.to_string());
        let mut parser = Parser::new(&mut lexer);
        let program = parser.parse_program().expect("Parse failed");

        let emitter = JSEmitter::new(&program);
        let stats = emitter.stats();

        assert_eq!(stats.server_functions, 2);
        assert_eq!(stats.client_functions, 1);
        assert_eq!(stats.shared_functions, 1);
        assert_eq!(stats.client_components, 0);
    }
}
