// JS Emitter - Generates complete JavaScript files for server and client
//
// This module combines:
// 1. RPC stubs/handlers from RPCGenerator
// 2. Actual function implementations (converted from WASM or AST)
// 3. Runtime imports and setup code
// 4. Main entry point code
//
// Output:
// - server.js: Server-side code with HTTP server and RPC handlers
// - client.js: Client-side code with RPC stubs and UI components

use crate::ast::{Program, Statement, FunctionDefinition, ComponentDefinition, Expression, BlockStatement, Pattern, TypeExpression};
use crate::code_splitter::CodeSplitter;
use crate::rpc_generator::RPCGenerator;
use crate::source_map::SourceMapBuilder;

#[derive(Debug, Clone)]
pub struct JSEmitter {
    pub splitter: CodeSplitter,
    pub source_file: String,  // Original .raven source file path
    #[allow(dead_code)] // Used in future source map implementation
    current_line: usize,  // Track current line number during generation
}

impl JSEmitter {
    pub fn new(program: &Program) -> Self {
        let mut splitter = CodeSplitter::new();
        splitter.split(program);
        JSEmitter {
            splitter,
            source_file: "input.raven".to_string(),
            current_line: 1,
        }
    }

    /// Create a new JSEmitter with a custom source file path
    pub fn with_source_file(program: &Program, source_file: String) -> Self {
        let mut splitter = CodeSplitter::new();
        splitter.split(program);
        JSEmitter {
            splitter,
            source_file,
            current_line: 1,
        }
    }

    /// Generates the complete server.js file
    pub fn generate_server_js(&self) -> String {
        let mut output = String::new();
        let source_map = SourceMapBuilder::new("server.js".to_string());

        // Header comment
        output.push_str("// Auto-generated RavensOne Server Bundle\n");
        output.push_str("// DO NOT EDIT - Generated by RavensOne compiler\n\n");

        // Import runtime
        output.push_str("const { HttpServer, loadWasm } = require('../dist/server-runtime.js');\n");
        output.push_str("const fs = require('fs');\n");
        output.push_str("const path = require('path');\n\n");

        // Built-in Option constructors
        output.push_str("// Built-in Option<T> constructors\n");
        output.push_str("function Some(value) { return { variant: 'Some', data: value }; }\n");
        output.push_str("const None = { variant: 'None' };\n\n");

        // Load WASM module
        output.push_str("// Load WebAssembly module\n");
        output.push_str("const wasmPath = path.join(__dirname, 'app.wasm');\n");
        output.push_str("const wasmBytes = fs.readFileSync(wasmPath);\n");
        output.push_str("const wasmModule = new WebAssembly.Module(wasmBytes);\n");
        output.push_str("const wasmInstance = new WebAssembly.Instance(wasmModule, {\n");
        output.push_str("  env: {\n");
        output.push_str("    memory: new WebAssembly.Memory({ initial: 256, maximum: 256 }),\n");
        output.push_str("  }\n");
        output.push_str("});\n\n");

        // Generate server function implementations
        output.push_str("// Server function implementations\n");
        for func in &self.splitter.server_functions {
            output.push_str(&self.generate_function_impl(func, true));
            output.push_str("\n\n");
        }

        // Generate shared function implementations
        output.push_str("// Shared utility functions\n");
        for func in &self.splitter.shared_functions {
            output.push_str(&self.generate_function_impl(func, true));
            output.push_str("\n\n");
        }

        // Generate RPC handlers
        output.push_str("// RPC Server Setup\n");
        let rpc_gen = RPCGenerator::new(self.splitter.server_functions.clone());
        output.push_str(&rpc_gen.generate_server_handlers());

        // Add source map reference comment
        output.push('\n');
        output.push_str(&source_map.generate_reference_comment());
        output.push('\n');

        output
    }

    /// Generates the complete server.js file with source map
    #[allow(unused_assignments)] // current_line used for future source map implementation
    pub fn generate_server_js_with_sourcemap(&self) -> (String, String) {
        let mut output = String::new();
        let mut source_map = SourceMapBuilder::new("server.js".to_string());
        let mut current_line = 1;

        // Header comment
        output.push_str("// Auto-generated RavensOne Server Bundle\n");
        current_line += 1;
        output.push_str("// DO NOT EDIT - Generated by RavensOne compiler\n\n");
        current_line += 2;

        // Import runtime
        output.push_str("const { HttpServer, loadWasm } = require('../dist/server-runtime.js');\n");
        current_line += 1;
        output.push_str("const fs = require('fs');\n");
        current_line += 1;
        output.push_str("const path = require('path');\n\n");
        current_line += 2;

        // Load WASM module
        output.push_str("// Load WebAssembly module\n");
        current_line += 1;
        output.push_str("const wasmPath = path.join(__dirname, 'app.wasm');\n");
        current_line += 1;
        output.push_str("const wasmBytes = fs.readFileSync(wasmPath);\n");
        current_line += 1;
        output.push_str("const wasmModule = new WebAssembly.Module(wasmBytes);\n");
        current_line += 1;
        output.push_str("const wasmInstance = new WebAssembly.Instance(wasmModule, {\n");
        current_line += 1;
        output.push_str("  env: {\n");
        current_line += 1;
        output.push_str("    memory: new WebAssembly.Memory({ initial: 256, maximum: 256 }),\n");
        current_line += 1;
        output.push_str("  }\n");
        current_line += 1;
        output.push_str("});\n\n");
        current_line += 2;

        // Generate server function implementations
        output.push_str("// Server function implementations\n");
        current_line += 1;
        for func in &self.splitter.server_functions {
            let func_code = self.generate_function_impl(func, true);

            // Add source mapping for function declaration
            // Note: Would ideally use actual source location from AST
            source_map.add_mapping(
                current_line,
                0,
                &self.source_file,
                1,  // Placeholder - would need location tracking in AST
                0,
                Some(&func.name.value),
            );

            output.push_str(&func_code);
            current_line += func_code.lines().count();
            output.push_str("\n\n");
            current_line += 2;
        }

        // Generate shared function implementations
        output.push_str("// Shared utility functions\n");
        current_line += 1;
        for func in &self.splitter.shared_functions {
            let func_code = self.generate_function_impl(func, true);

            // Add source mapping for function declaration
            source_map.add_mapping(
                current_line,
                0,
                &self.source_file,
                1,  // Placeholder - would need location tracking in AST
                0,
                Some(&func.name.value),
            );

            output.push_str(&func_code);
            current_line += func_code.lines().count();
            output.push_str("\n\n");
            current_line += 2;
        }

        // Generate RPC handlers
        output.push_str("// RPC Server Setup\n");
        current_line += 1;
        let rpc_gen = RPCGenerator::new(self.splitter.server_functions.clone());
        let rpc_code = rpc_gen.generate_server_handlers();
        output.push_str(&rpc_code);
        current_line += rpc_code.lines().count();

        // Add source map reference comment
        output.push('\n');
        output.push_str(&source_map.generate_reference_comment());
        output.push('\n');

        (output, source_map.generate())
    }

    /// Generates the complete client.js file
    pub fn generate_client_js(&self) -> String {
        let mut output = String::new();
        let source_map = SourceMapBuilder::new("client.js".to_string());

        // Header comment
        output.push_str("// Auto-generated RavensOne Client Bundle\n");
        output.push_str("// DO NOT EDIT - Generated by RavensOne compiler\n\n");

        // Import runtime
        output.push_str("import { RPCClient, mountComponent } from '../dist/client-runtime.js';\n\n");

        // Built-in Option constructors
        output.push_str("// Built-in Option<T> constructors\n");
        output.push_str("function Some(value) { return { variant: 'Some', data: value }; }\n");
        output.push_str("const None = { variant: 'None' };\n\n");

        // Generate RPC client stubs
        output.push_str("// RPC Client Setup\n");
        let rpc_gen = RPCGenerator::new(self.splitter.server_functions.clone());
        output.push_str(&rpc_gen.generate_client_stubs());
        output.push('\n');

        // Generate shared constants
        if !self.splitter.shared_constants.is_empty() {
            output.push_str("// Shared constants\n");
            for const_decl in &self.splitter.shared_constants {
                let value = self.generate_expression_js(&const_decl.value);
                output.push_str(&format!("const {} = {};\n", const_decl.name.value, value));
            }
            output.push_str("\n");
        }

        // Generate client function implementations
        output.push_str("// Client function implementations\n");
        for func in &self.splitter.client_functions {
            output.push_str(&self.generate_function_impl(func, false));
            output.push_str("\n\n");
        }

        // Generate shared function implementations
        output.push_str("// Shared utility functions\n");
        for func in &self.splitter.shared_functions {
            output.push_str(&self.generate_function_impl(func, false));
            output.push_str("\n\n");
        }

        // Generate component implementations
        output.push_str("// UI Components\n");
        for comp in &self.splitter.client_components {
            output.push_str(&self.generate_component_impl(comp));
            output.push_str("\n\n");
        }

        // Generate main entry point
        output.push_str("// Initialize application\n");
        output.push_str("window.addEventListener('DOMContentLoaded', () => {\n");
        output.push_str("  console.log('RavensOne client initialized');\n");

        // Auto-mount first component if exists
        if let Some(comp) = self.splitter.client_components.first() {
            output.push_str(&format!("  mountComponent({}, document.getElementById('app'));\n", comp.name.value));
        }

        output.push_str("});\n");

        // Add source map reference comment
        output.push('\n');
        output.push_str(&source_map.generate_reference_comment());
        output.push('\n');

        output
    }

    /// Generates the complete client.js file with source map
    #[allow(unused_assignments)] // current_line used for future source map implementation
    pub fn generate_client_js_with_sourcemap(&self) -> (String, String) {
        let mut output = String::new();
        let mut source_map = SourceMapBuilder::new("client.js".to_string());
        let mut current_line = 1;

        // Header comment
        output.push_str("// Auto-generated RavensOne Client Bundle\n");
        current_line += 1;
        output.push_str("// DO NOT EDIT - Generated by RavensOne compiler\n\n");
        current_line += 2;

        // Import runtime
        output.push_str("import { RPCClient, mountComponent } from '../dist/client-runtime.js';\n\n");
        current_line += 2;

        // Generate RPC client stubs
        output.push_str("// RPC Client Setup\n");
        current_line += 1;
        let rpc_gen = RPCGenerator::new(self.splitter.server_functions.clone());
        let rpc_code = rpc_gen.generate_client_stubs();
        output.push_str(&rpc_code);
        current_line += rpc_code.lines().count();
        output.push('\n');
        current_line += 1;

        // Generate client function implementations
        output.push_str("// Client function implementations\n");
        current_line += 1;
        for func in &self.splitter.client_functions {
            let func_code = self.generate_function_impl(func, false);

            // Add source mapping for function declaration
            source_map.add_mapping(
                current_line,
                0,
                &self.source_file,
                1,  // Placeholder - would need location tracking in AST
                0,
                Some(&func.name.value),
            );

            output.push_str(&func_code);
            current_line += func_code.lines().count();
            output.push_str("\n\n");
            current_line += 2;
        }

        // Generate shared function implementations
        output.push_str("// Shared utility functions\n");
        current_line += 1;
        for func in &self.splitter.shared_functions {
            let func_code = self.generate_function_impl(func, false);

            // Add source mapping for function declaration
            source_map.add_mapping(
                current_line,
                0,
                &self.source_file,
                1,  // Placeholder - would need location tracking in AST
                0,
                Some(&func.name.value),
            );

            output.push_str(&func_code);
            current_line += func_code.lines().count();
            output.push_str("\n\n");
            current_line += 2;
        }

        // Generate component implementations
        output.push_str("// UI Components\n");
        current_line += 1;
        for comp in &self.splitter.client_components {
            let comp_code = self.generate_component_impl(comp);

            // Add source mapping for component declaration
            source_map.add_mapping(
                current_line,
                0,
                &self.source_file,
                1,  // Placeholder - would need location tracking in AST
                0,
                Some(&comp.name.value),
            );

            output.push_str(&comp_code);
            current_line += comp_code.lines().count();
            output.push_str("\n\n");
            current_line += 2;
        }

        // Generate main entry point
        output.push_str("// Initialize application\n");
        current_line += 1;
        output.push_str("window.addEventListener('DOMContentLoaded', () => {\n");
        current_line += 1;
        output.push_str("  console.log('RavensOne client initialized');\n");
        current_line += 1;

        // Auto-mount first component if exists
        if let Some(comp) = self.splitter.client_components.first() {
            output.push_str(&format!("  mountComponent({}, document.getElementById('app'));\n", comp.name.value));
            current_line += 1;
        }

        output.push_str("});\n");
        current_line += 1;

        // Add source map reference comment
        output.push('\n');
        output.push_str(&source_map.generate_reference_comment());
        output.push('\n');

        (output, source_map.generate())
    }

    /// Generates a JavaScript function implementation from AST
    fn generate_function_impl(&self, func: &FunctionDefinition, is_server: bool) -> String {
        let name = &func.name.value;
        let params = func.parameters
            .iter()
            .map(|p| p.name.value.clone())
            .collect::<Vec<_>>()
            .join(", ");

        let async_keyword = if func.is_async { "async " } else { "" };
        let export_keyword = if is_server { "module.exports." } else { "export " };

        let body = self.generate_block_js(&func.body);

        format!(
            "{}{}function {}({}) {{\n{}\n}}",
            export_keyword, async_keyword, name, params, body
        )
    }

    /// Generates a JavaScript component implementation from AST
    fn generate_component_impl(&self, comp: &ComponentDefinition) -> String {
        let name = &comp.name.value;
        let params = comp.parameters
            .iter()
            .map(|p| p.name.value.clone())
            .collect::<Vec<_>>()
            .join(", ");

        let body = self.generate_block_js(&comp.body);

        format!(
            "export function {}({}) {{\n{}\n}}",
            name, params, body
        )
    }

    /// Generates JavaScript code for a block statement
    fn generate_block_js(&self, block: &BlockStatement) -> String {
        let mut output = String::new();

        for stmt in &block.statements {
            output.push_str("  ");
            output.push_str(&self.generate_statement_js(stmt));
            output.push('\n');
        }

        output
    }

    /// Generates JavaScript code for a statement
    fn generate_statement_js(&self, stmt: &Statement) -> String {
        match stmt {
            Statement::Let(let_stmt) => {
                use crate::ast::Pattern;

                // All let statements become 'let' in JS (RavensOne tracks mutability)
                let value = self.generate_expression_js(&let_stmt.value);

                // Generate pattern for left-hand side
                let pattern_str = match &let_stmt.pattern {
                    Pattern::Identifier(id) => id.value.clone(),
                    Pattern::Tuple(patterns) => {
                        // Generate tuple destructuring: let [a, b, c] = value;
                        let names: Vec<String> = patterns.iter().map(|p| {
                            match p {
                                Pattern::Identifier(id) => id.value.clone(),
                                _ => "_".to_string(),  // Nested patterns become wildcards for now
                            }
                        }).collect();
                        format!("[{}]", names.join(", "))
                    }
                    _ => "_".to_string(),  // Other patterns become wildcards
                };

                format!("let {} = {};", pattern_str, value)
            }
            Statement::Const(const_decl) => {
                // Emit const declarations as JavaScript const
                let value = self.generate_expression_js(&const_decl.value);
                format!("const {} = {};", const_decl.name.value, value)
            }
            Statement::Return(ret_stmt) => {
                let value = self.generate_expression_js(&ret_stmt.value);
                format!("return {};", value)
            }
            Statement::Expression(expr) => {
                format!("{};", self.generate_expression_js(expr))
            }
            Statement::If(if_stmt) => {
                let condition = self.generate_expression_js(&if_stmt.condition);
                let then_body = self.generate_block_js(&if_stmt.then_branch);

                if let Some(else_branch) = &if_stmt.else_branch {
                    let else_body = match &**else_branch {
                        Statement::If(_) => self.generate_statement_js(else_branch),
                        _ => format!("{{\n{}\n  }}", self.generate_statement_js(else_branch)),
                    };
                    format!("if ({}) {{\n{}\n  }} else {}", condition, then_body, else_body)
                } else {
                    format!("if ({}) {{\n{}\n  }}", condition, then_body)
                }
            }
            Statement::While(while_stmt) => {
                let condition = self.generate_expression_js(&while_stmt.condition);
                let body = self.generate_block_js(&while_stmt.body);
                format!("while ({}) {{\n{}\n  }}", condition, body)
            }
            Statement::Enum(enum_def) => {
                self.generate_enum_js(enum_def)
            }
            _ => "// Unsupported statement".to_string(),
        }
    }

    /// Generates JavaScript helper functions for enum variants
    fn generate_enum_js(&self, enum_def: &crate::ast::EnumDefinition) -> String {
        let mut code = String::new();
        code.push_str(&format!("// Enum: {}\n", enum_def.name.value));

        for variant in &enum_def.variants {
            let variant_name = &variant.name.value;

            if let Some(fields) = &variant.fields {
                // Variant with data - generate constructor function
                if fields.len() == 1 {
                    // Single field - simple constructor
                    code.push_str(&format!(
                        "function {}(data) {{ return {{ variant: \"{}\", data: data }}; }}\n",
                        variant_name, variant_name
                    ));
                } else {
                    // Multiple fields - use spread/array
                    code.push_str(&format!(
                        "function {}(...data) {{ return {{ variant: \"{}\", data: data }}; }}\n",
                        variant_name, variant_name
                    ));
                }
            } else {
                // Unit variant - no data
                code.push_str(&format!(
                    "const {} = {{ variant: \"{}\" }};\n",
                    variant_name, variant_name
                ));
            }
        }

        code
    }

    /// Generates JavaScript code for an expression
    fn generate_expression_js(&self, expr: &Expression) -> String {
        match expr {
            Expression::Identifier(ident) => {
                // Handle namespaced identifiers (e.g., math::PI, console::log)
                // Strip the namespace since wildcard imports make symbols available globally
                if let Some(idx) = ident.value.rfind("::") {
                    ident.value[idx + 2..].to_string()
                } else {
                    ident.value.clone()
                }
            }
            Expression::IntegerLiteral(value) => value.to_string(),
            Expression::FloatLiteral(value) => value.clone(),
            Expression::StringLiteral(value) => format!("\"{}\"", value),
            Expression::BoolLiteral(value) => value.to_string(),
            Expression::Infix(infix) => {
                let left = self.generate_expression_js(&infix.left);
                let right = self.generate_expression_js(&infix.right);
                let op = &infix.operator.lexeme;
                format!("({} {} {})", left, op, right)
            }
            Expression::Prefix(prefix) => {
                let operand = self.generate_expression_js(&prefix.right);
                format!("({}{})", prefix.operator.lexeme, operand)
            }
            Expression::Spread(spread) => {
                // Generate JavaScript spread operator: ...expr
                let expr = self.generate_expression_js(&spread.expression);
                format!("...{}", expr)
            }
            Expression::FunctionCall(call) => {
                let func = self.generate_expression_js(&call.function);
                let args = call.arguments
                    .iter()
                    .map(|arg| self.generate_expression_js(arg))
                    .collect::<Vec<_>>()
                    .join(", ");

                // Check if this is a server function call from client-side
                if let Expression::Identifier(ident) = &*call.function {
                    if self.is_server_function(&ident.value) {
                        return format!("await {}({})", func, args);
                    }
                }

                format!("{}({})", func, args)
            }
            Expression::MacroCall(macro_call) => {
                // Generate JavaScript for macro calls
                let args = macro_call.arguments
                    .iter()
                    .map(|arg| self.generate_expression_js(arg))
                    .collect::<Vec<_>>();

                // Map Rust-like macros to JavaScript equivalents
                match macro_call.name.value.as_str() {
                    "vec" => format!("[{}]", args.join(", ")),
                    "println" => format!("console.log({})", args.join(", ")),
                    "format" => {
                        // Handle format! macro with string interpolation
                        if args.is_empty() {
                            "``".to_string()
                        } else if args.len() == 1 {
                            // Just a format string, no interpolation
                            format!("`{}`", args[0].trim_matches('"'))
                        } else {
                            // Format string + arguments to interpolate
                            let format_str = args[0].trim_matches('"');
                            let mut result = format_str.to_string();

                            // Replace each {} with ${arg}
                            for arg in args.iter().skip(1) {
                                result = result.replacen("{}", &format!("${{{}}}", arg), 1);
                            }

                            format!("`{}`", result)
                        }
                    }
                    "panic" => format!("throw new Error({})", args.join(", ")),
                    _ => format!("{}({})", macro_call.name.value, args.join(", ")),
                }
            }
            Expression::IndexAccess(index) => {
                let array = self.generate_expression_js(&index.array);

                // Check if the index is a Range expression (for slicing)
                if let Expression::Range(range) = &*index.index {
                    // Generate arr.slice(start, end) for slicing
                    let start = if let Some(start_expr) = &range.start {
                        self.generate_expression_js(start_expr)
                    } else {
                        "0".to_string()
                    };

                    let end = if let Some(end_expr) = &range.end {
                        let end_code = self.generate_expression_js(end_expr);
                        // For inclusive range (..=), we need to add 1 to the end
                        if range.inclusive {
                            format!("({} + 1)", end_code)
                        } else {
                            end_code
                        }
                    } else {
                        "undefined".to_string()
                    };

                    format!("{}.slice({}, {})", array, start, end)
                } else {
                    // Regular index access
                    let idx = self.generate_expression_js(&index.index);
                    format!("{}[{}]", array, idx)
                }
            }
            Expression::ArrayLiteral(array) => {
                let elements = array.elements
                    .iter()
                    .map(|elem| self.generate_expression_js(elem))
                    .collect::<Vec<_>>()
                    .join(", ");
                format!("[{}]", elements)
            }
            Expression::StructLiteral(struct_lit) => {
                let fields = struct_lit.fields
                    .iter()
                    .map(|(name, value)| {
                        format!("{}: {}", name.value, self.generate_expression_js(value))
                    })
                    .collect::<Vec<_>>()
                    .join(", ");
                format!("{{ {} }}", fields)
            }
            Expression::FieldAccess(field) => {
                let object = self.generate_expression_js(&field.object);
                format!("{}.{}", object, field.field.value)
            }
            Expression::JsxElement(jsx) => {
                self.generate_jsx_js(jsx)
            }
            Expression::Await(await_expr) => {
                // Generate JavaScript await expression
                let inner = self.generate_expression_js(&await_expr.expression);
                format!("await {}", inner)
            }
            Expression::Ternary(ternary) => {
                // Generate JavaScript ternary expression: condition ? true_expr : false_expr
                let condition = self.generate_expression_js(&ternary.condition);
                let true_expr = self.generate_expression_js(&ternary.true_expr);
                let false_expr = self.generate_expression_js(&ternary.false_expr);
                format!("({} ? {} : {})", condition, true_expr, false_expr)
            }
            Expression::TypeCast(type_cast) => {
                // Generate JavaScript type cast - in JS this is mostly a no-op, but we emit for clarity
                // For numeric conversions, we use Number(), Math.floor(), etc.
                let expr_code = self.generate_expression_js(&type_cast.expression);

                // Extract type name from TypeExpression
                let type_name = match &type_cast.target_type {
                    TypeExpression::Named(ident) => ident.value.as_str(),
                    _ => return expr_code, // For complex types, just pass through
                };

                match type_name {
                    "i32" | "i64" | "isize" | "u32" | "u64" | "usize" => {
                        // Integer cast: use Math.floor for safety
                        format!("Math.floor({})", expr_code)
                    }
                    "f32" | "f64" => {
                        // Float cast: use Number() or just pass through
                        format!("Number({})", expr_code)
                    }
                    "bool" => {
                        // Boolean cast
                        format!("Boolean({})", expr_code)
                    }
                    _ => {
                        // For other types, just emit the expression (structural compatibility)
                        expr_code
                    }
                }
            }
            Expression::Match(match_expr) => {
                self.generate_match_expression_js(match_expr)
            }
            _ => "/* Unsupported expression */".to_string(),
        }
    }

    /// Generates JavaScript code for a match expression
    /// Enums are represented as: { variant: "VariantName", data: value }
    fn generate_match_expression_js(&self, match_expr: &crate::ast::MatchExpression) -> String {
        let scrutinee = self.generate_expression_js(&match_expr.scrutinee);

        // Generate an IIFE (Immediately Invoked Function Expression) for the match
        let mut code = format!("(() => {{\n");
        code.push_str(&format!("  const __match_value = {};\n", scrutinee));

        // Generate nested if-else for each arm
        for (i, arm) in match_expr.arms.iter().enumerate() {
            let condition = self.generate_pattern_condition_js(&arm.pattern, "__match_value");
            let body = self.generate_pattern_body_js(&arm.pattern, "__match_value", &arm.body);

            if i == 0 {
                code.push_str(&format!("  if ({}) {{\n", condition));
            } else if matches!(arm.pattern, Pattern::Wildcard | Pattern::Identifier(_)) {
                // Wildcard or identifier patterns - no condition needed (always matches)
                code.push_str("  else {\n");
            } else {
                code.push_str(&format!("  else if ({}) {{\n", condition));
            }

            code.push_str(&format!("    return {};\n", body));
            code.push_str("  }\n");
        }

        code.push_str("})()");
        code
    }

    /// Generates the condition for a pattern match
    fn generate_pattern_condition_js(&self, pattern: &Pattern, scrutinee_var: &str) -> String {
        match pattern {
            Pattern::Wildcard | Pattern::Identifier(_) => {
                // Wildcards and identifiers always match
                "true".to_string()
            }
            Pattern::Tuple(_) => {
                // TODO: Implement tuple pattern matching
                // For now, treat as wildcard
                "true".to_string()
            }
            Pattern::Literal(expr) => {
                // Compare with literal value
                let literal_val = self.generate_expression_js(expr);
                format!("{} === {}", scrutinee_var, literal_val)
            }
            Pattern::EnumVariant { name, .. } => {
                // Extract the variant name (after :: if present)
                let variant_name = if name.value.contains("::") {
                    name.value.split("::").last().unwrap_or(&name.value)
                } else {
                    &name.value
                };
                format!("{}.variant === \"{}\"", scrutinee_var, variant_name)
            }
        }
    }

    /// Generates the body for a pattern match, including variable bindings
    fn generate_pattern_body_js(&self, pattern: &Pattern, scrutinee_var: &str, body_expr: &Expression) -> String {
        match pattern {
            Pattern::Identifier(ident) => {
                // Bind the scrutinee to the identifier
                let body = self.generate_expression_js(body_expr);
                format!("(() => {{ const {} = {}; return {}; }})()", ident.value, scrutinee_var, body)
            }
            Pattern::EnumVariant { fields: Some(field_patterns), .. } => {
                // Extract fields from enum variant
                let mut bindings = Vec::new();
                for (i, field_pattern) in field_patterns.iter().enumerate() {
                    if let Pattern::Identifier(ident) = field_pattern {
                        // For tuple-style variants, data is a single value or array
                        if field_patterns.len() == 1 {
                            bindings.push(format!("const {} = {}.data", ident.value, scrutinee_var));
                        } else {
                            bindings.push(format!("const {} = {}.data[{}]", ident.value, scrutinee_var, i));
                        }
                    }
                }

                let body = self.generate_expression_js(body_expr);
                if bindings.is_empty() {
                    body
                } else {
                    format!("(() => {{ {}; return {}; }})()", bindings.join("; "), body)
                }
            }
            _ => {
                // No bindings needed, just generate the body
                self.generate_expression_js(body_expr)
            }
        }
    }

    /// Generates JavaScript code for JSX
    fn generate_jsx_js(&self, jsx: &crate::ast::JsxElement) -> String {
        let tag = &jsx.opening_tag.name.value;

        // Generate attributes
        let attrs = if jsx.opening_tag.attributes.is_empty() {
            String::new()
        } else {
            let attrs_str = jsx.opening_tag.attributes
                .iter()
                .map(|attr| {
                    let val = self.generate_expression_js(&attr.value);
                    format!("{}: {}", attr.name.value, val)
                })
                .collect::<Vec<_>>()
                .join(", ");
            format!(", {{ {} }}", attrs_str)
        };

        // Generate children
        let children = jsx.children
            .iter()
            .map(|child| match child {
                crate::ast::JsxChild::Element(elem) => self.generate_jsx_js(elem),
                crate::ast::JsxChild::Text(text) => format!("\"{}\"", text),
                crate::ast::JsxChild::Expression(expr) => self.generate_expression_js(expr),
            })
            .collect::<Vec<_>>()
            .join(", ");

        if children.is_empty() {
            format!("h('{}'{}, null)", tag, attrs)
        } else {
            format!("h('{}'{}, {})", tag, attrs, children)
        }
    }

    /// Checks if a function name is a server function
    fn is_server_function(&self, name: &str) -> bool {
        self.splitter.server_functions
            .iter()
            .any(|f| f.name.value == name)
    }

    /// Returns statistics about the generated code
    pub fn stats(&self) -> EmitterStats {
        EmitterStats {
            server_functions: self.splitter.server_functions.len(),
            client_functions: self.splitter.client_functions.len(),
            shared_functions: self.splitter.shared_functions.len(),
            client_components: self.splitter.client_components.len(),
        }
    }
}

#[derive(Debug, Clone)]
pub struct EmitterStats {
    pub server_functions: usize,
    pub client_functions: usize,
    pub shared_functions: usize,
    pub client_components: usize,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::lexer::Lexer;
    use crate::parser::Parser;

    #[test]
    fn test_server_js_generation() {
        let source = r#"
            @server
            fn get_user(id: i32) -> String {
                return "John Doe";
            }

            fn format_name(first: String, last: String) -> String {
                return first + " " + last;
            }
        "#;

        let mut lexer = Lexer::new(source.to_string());
        let mut parser = Parser::new(&mut lexer);
        let program = parser.parse_program().expect("Parse failed");

        let emitter = JSEmitter::new(&program);
        let server_js = emitter.generate_server_js();

        // Verify server.js contains expected code
        assert!(server_js.contains("HttpServer"));
        assert!(server_js.contains("function get_user"));
        assert!(server_js.contains("function format_name"));
        assert!(server_js.contains("WebAssembly"));
        assert!(server_js.contains("server.rpc('get_user'"));
    }

    #[test]
    fn test_client_js_generation() {
        let source = r#"
            @server
            fn get_user(id: i32) -> String {
                return "John Doe";
            }

            @client
            fn render_user(name: String) -> String {
                return "User: " + name;
            }

            fn format_name(first: String, last: String) -> String {
                return first + " " + last;
            }
        "#;

        let mut lexer = Lexer::new(source.to_string());
        let mut parser = Parser::new(&mut lexer);
        let program = parser.parse_program().expect("Parse failed");

        let emitter = JSEmitter::new(&program);
        let client_js = emitter.generate_client_js();

        // Verify client.js contains expected code
        assert!(client_js.contains("RPCClient"));
        assert!(client_js.contains("async function get_user"));  // RPC stub
        assert!(client_js.contains("export function render_user"));  // Client function
        assert!(client_js.contains("export function format_name"));  // Shared function
        assert!(client_js.contains("DOMContentLoaded"));
    }

    #[test]
    fn test_stats() {
        let source = r#"
            @server fn s1() {}
            @server fn s2() {}
            @client fn c1() {}
            fn shared1() {}
        "#;

        let mut lexer = Lexer::new(source.to_string());
        let mut parser = Parser::new(&mut lexer);
        let program = parser.parse_program().expect("Parse failed");

        let emitter = JSEmitter::new(&program);
        let stats = emitter.stats();

        assert_eq!(stats.server_functions, 2);
        assert_eq!(stats.client_functions, 1);
        assert_eq!(stats.shared_functions, 1);
        assert_eq!(stats.client_components, 0);
    }
}
