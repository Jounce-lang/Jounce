// examples/05-advanced-types/03_sized_arrays.raven
//
// CONCEPT: Sized arrays with [T; N] syntax
// DIFFICULTY: Advanced
// FEATURES: sized arrays, fixed-size collections, type-level size
//
// Sized arrays have their length encoded in the type: [T; N] means
// "an array of T with exactly N elements". The size is known at
// compile time, enabling optimizations and type safety.

// Function that works with a specific-sized array
fn sum_three(numbers: [i32; 3]) -> i32 {
    numbers[0] + numbers[1] + numbers[2]
}

// Function with a different sized array
fn sum_five(numbers: [i32; 5]) -> i32 {
    let mut total = 0;
    for num in numbers {
        total = total + num;
    }
    total
}

// Generic function with sized array
fn first<T>(array: [T; 3]) -> T {
    array[0]
}

// Get the last element
fn last<T>(array: [T; 4]) -> T {
    array[3]
}

// Transform a sized array (all elements)
fn double_all(numbers: [i32; 3]) -> [i32; 3] {
    [numbers[0] * 2, numbers[1] * 2, numbers[2] * 2]
}

// Create a sized array from individual values
fn make_array<T>(a: T, b: T, c: T) -> [T; 3] {
    [a, b, c]
}

// Count elements in a sized array
fn count_positive(numbers: [i32; 5]) -> i32 {
    let mut count = 0;
    for num in numbers {
        if num > 0 {
            count = count + 1;
        }
    }
    count
}

fn main() {
    // Creating sized arrays
    let three_nums: [i32; 3] = [10, 20, 30];
    let five_nums: [i32; 5] = [1, 2, 3, 4, 5];

    println!("Sum of [10, 20, 30]: {}", sum_three(three_nums));
    println!("Sum of [1, 2, 3, 4, 5]: {}", sum_five(five_nums));

    println!("");

    // Using generic functions with sized arrays
    let strings: [String; 3] = ["hello", "world", "!"];
    println!("First string: {}", first(strings));

    let numbers: [i32; 3] = [100, 200, 300];
    println!("First number: {}", first(numbers));

    println!("");

    // Get last element
    let four_nums: [i32; 4] = [1, 2, 3, 4];
    println!("Last of [1, 2, 3, 4]: {}", last(four_nums));

    println!("");

    // Transform array
    let arr = [5, 10, 15];
    let doubled = double_all(arr);
    println!("Original: [{}, {}, {}]", arr[0], arr[1], arr[2]);
    println!("Doubled:  [{}, {}, {}]", doubled[0], doubled[1], doubled[2]);

    println!("");

    // Make arrays
    let made = make_array(7, 8, 9);
    println!("Made array: [{}, {}, {}]", made[0], made[1], made[2]);

    println!("");

    // Count positive
    let mixed: [i32; 5] = [-2, 5, 0, -1, 3];
    println!("Positive numbers in [-2, 5, 0, -1, 3]: {}", count_positive(mixed));
}

// EXPECTED OUTPUT:
// Sum of [10, 20, 30]: 60
// Sum of [1, 2, 3, 4, 5]: 15
//
// First string: hello
// First number: 100
//
// Last of [1, 2, 3, 4]: 4
//
// Original: [5, 10, 15]
// Doubled:  [10, 20, 30]
//
// Made array: [7, 8, 9]
//
// Positive numbers in [-2, 5, 0, -1, 3]: 2
//
// KEY CONCEPTS:
// - [T; N] syntax specifies exact array size in the type
// - Different sizes = different types ([i32; 3] != [i32; 5])
// - Size is checked at compile time
// - Generic functions work with sized arrays
// - More efficient than dynamic arrays
//
// TRY IT:
// raven compile examples/05-advanced-types/03_sized_arrays.raven
// cd dist && node server.js
