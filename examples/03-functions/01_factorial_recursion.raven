// examples/03-functions/01_factorial_recursion.raven
//
// CONCEPT: Recursive function (factorial)
// DIFFICULTY: Intermediate
// FEATURES: recursion, base case, recursive case, implicit returns
//
// This example demonstrates:
// - Defining a recursive function
// - Base case to stop recursion
// - Recursive case that calls itself
// - Computing factorial: n! = n * (n-1) * (n-2) * ... * 1

fn factorial(n: i32) -> i32 {
    if n <= 1 {
        1
    } else {
        n * factorial(n - 1)
    }
}

fn main() {
    println!("factorial(0) = {}", factorial(0));
    println!("factorial(1) = {}", factorial(1));
    println!("factorial(5) = {}", factorial(5));
    println!("factorial(10) = {}", factorial(10));
}

// EXPECTED OUTPUT:
// factorial(0) = 1
// factorial(1) = 1
// factorial(5) = 120
// factorial(10) = 3628800
//
// TRY IT:
// raven compile examples/03-functions/01_factorial_recursion.raven
// cd dist && node server.js
//
// HOW IT WORKS:
// factorial(5) = 5 * factorial(4)
//              = 5 * (4 * factorial(3))
//              = 5 * (4 * (3 * factorial(2)))
//              = 5 * (4 * (3 * (2 * factorial(1))))
//              = 5 * (4 * (3 * (2 * 1)))
//              = 5 * (4 * (3 * 2))
//              = 5 * (4 * 6)
//              = 5 * 24
//              = 120
//
// WHAT YOU LEARNED:
// - Recursive functions call themselves
// - Every recursion needs a base case to stop
// - The base case for factorial is n <= 1
// - The recursive case breaks the problem into smaller pieces
// - RavensOne handles recursion perfectly!
