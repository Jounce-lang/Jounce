// examples/04-patterns/01_option_basic.raven
//
// CONCEPT: Basic Option<T> usage for nullable values
// DIFFICULTY: Intermediate
// FEATURES: Option<T>, Some, None, pattern matching
//
// Option<T> is RavensOne's way of representing values that might not exist.
// It's safer than null/undefined because you're forced to handle both cases:
// - Some(value): The value exists
// - None: The value doesn't exist
//
// This example demonstrates:
// - Returning Option<T> from a function
// - Pattern matching on Option with Some/None
// - Safe handling of missing values

fn find_even(numbers: [i32; 5]) -> Option<i32> {
    // Search through the array for the first even number
    for num in numbers {
        if num % 2 == 0 {
            return Some(num);  // Found an even number!
        }
    }
    None  // No even numbers found
}

fn main() {
    // Test case 1: Array with no even numbers
    let numbers1 = [1, 3, 5, 7, 9];
    let result1 = find_even(numbers1);

    match result1 {
        Some(value) => println!("Found even: {}", value),
        None => println!("No even numbers found"),
    }

    // Test case 2: Array with even numbers
    let numbers2 = [1, 3, 4, 7, 9];
    let result2 = find_even(numbers2);

    match result2 {
        Some(value) => println!("Found even: {}", value),
        None => println!("No even numbers found"),
    }
}

// EXPECTED OUTPUT:
// No even numbers found
// Found even: 4
//
// TRY IT:
// raven compile examples/04-patterns/01_option_basic.raven
// cd dist && node server.js
//
// KEY TAKEAWAY:
// Option<T> forces you to handle the "missing value" case explicitly,
// preventing null pointer errors at compile time!
