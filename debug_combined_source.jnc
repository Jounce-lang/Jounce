
// JSON Value representation
// Represents any valid JSON value
enum JsonValue {
    Null,
    Bool(bool),
    Number(f64),
    String(String),
    Array(Vec<JsonValue>),
    Object(HashMap<String, JsonValue>),
}

impl JsonValue {
    // Check if value is null
    fn is_null(self: &JsonValue) -> bool {
        match self {
            JsonValue::Null => true,
            _ => false,
        }
    }

    // Check if value is a boolean
    fn is_bool(self: &JsonValue) -> bool {
        match self {
            JsonValue::Bool(_) => true,
            _ => false,
        }
    }

    // Check if value is a number
    fn is_number(self: &JsonValue) -> bool {
        match self {
            JsonValue::Number(_) => true,
            _ => false,
        }
    }

    // Check if value is a string
    fn is_string(self: &JsonValue) -> bool {
        match self {
            JsonValue::String(_) => true,
            _ => false,
        }
    }

    // Check if value is an array
    fn is_array(self: &JsonValue) -> bool {
        match self {
            JsonValue::Array(_) => true,
            _ => false,
        }
    }

    // Check if value is an object
    fn is_object(self: &JsonValue) -> bool {
        match self {
            JsonValue::Object(_) => true,
            _ => false,
        }
    }

    // Extract boolean value
    fn as_bool(self: &JsonValue) -> Result<(), String> {
        match self {
            JsonValue::Bool(b) => Ok(*b),
            _ => Err("Not a boolean"),
        }
    }

    // Extract number value
    fn as_number(self: &JsonValue) -> Result<f64, String> {
        match self {
            JsonValue::Number(n) => Ok(*n),
            _ => Err("Not a number"),
        }
    }

    // Extract integer value
    fn as_i32(self: &JsonValue) -> Result<i32, String> {
        match self {
            JsonValue::Number(n) => Ok(*n as i32),
            _ => Err("Not a number"),
        }
    }

    // Extract string value
    fn as_string(self: &JsonValue) -> Result<String, String> {
        match self {
            JsonValue::String(s) => Ok(s.clone()),
            _ => Err("Not a string"),
        }
    }

    // Extract array value
    fn as_array(self: &JsonValue) -> Result<Vec<JsonValue>, String> {
        match self {
            JsonValue::Array(arr) => Ok(arr.clone()),
            _ => Err("Not an array"),
        }
    }

    // Extract object value
    fn as_object(self: &JsonValue) -> Result<HashMap<String, JsonValue>, String> {
        match self {
            JsonValue::Object(obj) => Ok(obj.clone()),
            _ => Err("Not an object"),
        }
    }

    // Get value from object by key
    fn get(self: &JsonValue, key: String) -> Option<JsonValue> {
        match self {
            JsonValue::Object(obj) => {
                // HashMap.get() returns undefined if key doesn't exist
                // We need to check and wrap in Option
                return if obj.has(key) {
                    Option::Some(obj.get(key))
                } else {
                    Option::None
                };
            },
            _ => Option::None,
        }
    }

    // Get value from array by index
    fn get_index(self: &JsonValue, index: i32) -> Option<JsonValue> {
        match self {
            JsonValue::Array(arr) => arr.get(index),
            _ => Option::None,
        }
    }

    // Set value in object by key
    fn set(self: &mut JsonValue, key: String, value: JsonValue) -> Result<(), String> {
        match self {
            JsonValue::Object(obj) => {
                obj.insert(key, value);
                Ok(())
            },
            _ => Err("Not an object"),
        }
    }

    // Set value in array by index
    fn set_index(self: &mut JsonValue, index: i32, value: JsonValue) -> Result<(), String> {
        match self {
            JsonValue::Array(arr) => {
                if index >= 0 && index < arr.len() {
                    // Would set arr[index] = value
                    Ok(())
                } else {
                    Err("Index out of bounds")
                }
            },
            _ => Err("Not an array"),
        }
    }

    // Push value to array
    fn push(self: &mut JsonValue, value: JsonValue) -> Result<(), String> {
        match self {
            JsonValue::Array(arr) => {
                arr.push(value);
                Ok(())
            },
            _ => Err("Not an array"),
        }
    }

    // Get array length
    fn len(self: &JsonValue) -> Result<i32, String> {
        match self {
            JsonValue::Array(arr) => Ok(arr.len()),
            JsonValue::Object(obj) => Ok(obj.len()),
            JsonValue::String(s) => Ok(s.len()),
            _ => Err("Type does not have a length"),
        }
    }

    // Check if object has key
    fn has_key(self: &JsonValue, key: String) -> bool {
        match self {
            JsonValue::Object(obj) => obj.contains_key(key),
            _ => false,
        }
    }

    // Get all keys from object
    fn keys(self: &JsonValue) -> Result<Vec<String>, String> {
        match self {
            JsonValue::Object(obj) => Ok(obj.keys()),
            _ => Err("Not an object"),
        }
    }

    // Get all values from object
    fn values(self: &JsonValue) -> Result<Vec<JsonValue>, String> {
        match self {
            JsonValue::Object(obj) => Ok(obj.values()),
            _ => Err("Not an object"),
        }
    }

    // Remove key from object
    fn remove(self: &mut JsonValue, key: String) -> Result<Option<JsonValue>, String> {
        match self {
            JsonValue::Object(obj) => Ok(obj.remove(key)),
            _ => Err("Not an object"),
        }
    }

    // Clone the value
    fn clone(self: &JsonValue) -> JsonValue {
        match self {
            JsonValue::Null => JsonValue::Null,
            JsonValue::Bool(b) => JsonValue::Bool(*b),
            JsonValue::Number(n) => JsonValue::Number(*n),
            JsonValue::String(s) => JsonValue::String(s.clone()),
            JsonValue::Array(arr) => JsonValue::Array(arr.clone()),
            JsonValue::Object(obj) => JsonValue::Object(obj.clone()),
        }
    }
}

// JSON parser
struct JsonParser {
    input: String,
    position: i32,
}

impl JsonParser {
    // Create a new parser
    fn new(input: String) -> JsonParser {
        return JsonParser {
            input: input,
            position: 0,
        };
    }

    // Parse JSON string into JsonValue
    fn parse(self: &mut JsonParser) -> Result<JsonValue, String> {
        self.skip_whitespace();
        return self.parse_value();
    }

    // Skip whitespace characters
    fn skip_whitespace(self: &mut JsonParser) {
        while self.position < self.input.len() {
            let ch = self.char_at(self.position);
            if ch == " " || ch == "\t" || ch == "\n" || ch == "\r" {
                self.position = self.position + 1;
            } else {
                break;
            }
        }
    }

    // Get character at position
    fn char_at(self: &JsonParser, pos: i32) -> String {
        if pos >= 0 && pos < self.input.len() {
            // In JavaScript, this will be: input.charAt(pos) or input[pos]
            return self.input.substring(pos, pos + 1);
        }
        return "";
    }

    // Parse any JSON value
    fn parse_value(self: &mut JsonParser) -> Result<JsonValue, String> {
        self.skip_whitespace();
        let ch = self.peek();

        if ch == "n" {
            return self.parse_null();
        } else if ch == "t" || ch == "f" {
            return self.parse_bool();
        } else if ch == "\"" {
            return self.parse_string();
        } else if ch == "[" {
            return self.parse_array();
        } else if ch == "{" {
            return self.parse_object();
        } else {
            return self.parse_number();
        }
    }

    // Parse null
    fn parse_null(self: &mut JsonParser) -> Result<JsonValue, String> {
        self.match_keyword("null")?;
        return Ok(JsonValue::Null);
    }

    // Parse boolean
    fn parse_bool(self: &mut JsonParser) -> Result<JsonValue, String> {
        let ch = self.peek();
        if ch == "t" {
            self.match_keyword("true")?;
            return Ok(JsonValue::Bool(true));
        } else {
            self.match_keyword("false")?;
            return Ok(JsonValue::Bool(false));
        }
    }

    // Parse number
    fn parse_number(self: &mut JsonParser) -> Result<JsonValue, String> {
        let start_pos = self.position;
        let mut has_dot = false;
        let mut has_exp = false;

        // Handle negative sign
        if self.peek() == "-" {
            self.position = self.position + 1;
        }

        // Parse digits
        let mut has_digits = false;
        while !self.is_eof() {
            let ch = self.peek();

            if ch >= "0" && ch <= "9" {
                has_digits = true;
                self.position = self.position + 1;
            } else if ch == "." && !has_dot && !has_exp {
                has_dot = true;
                self.position = self.position + 1;
            } else if (ch == "e" || ch == "E") && !has_exp && has_digits {
                has_exp = true;
                self.position = self.position + 1;
                // Handle optional +/- after exponent
                let next_ch = self.peek();
                if next_ch == "+" || next_ch == "-" {
                    self.position = self.position + 1;
                }
            } else {
                break;
            }
        }

        if !has_digits {
            return Err("Invalid number");
        }

        // Extract number string and parse it
        let num_str = self.input.substring(start_pos, self.position);
        // In JavaScript, this will be: parseFloat(num_str)
        let num_value = num_str.parse_float();
        return Ok(JsonValue::Number(num_value));
    }

    // Parse string
    fn parse_string(self: &mut JsonParser) -> Result<JsonValue, String> {
        // Expect opening quote
        self.expect("\"")?;

        let mut result = "";
        while !self.is_eof() {
            let ch = self.advance();

            if ch == "\"" {
                // End of string
                return Ok(JsonValue::String(result));
            } else if ch == "\\" {
                // Escape sequence
                let escaped = self.advance();
                if escaped == "\"" {
                    result = result + "\"";
                } else if escaped == "\\" {
                    result = result + "\\";
                } else if escaped == "/" {
                    result = result + "/";
                } else if escaped == "n" {
                    result = result + "\n";
                } else if escaped == "r" {
                    result = result + "\r";
                } else if escaped == "t" {
                    result = result + "\t";
                } else if escaped == "b" {
                    result = result + "\b";
                } else if escaped == "f" {
                    result = result + "\f";
                } else if escaped == "u" {
                    // Unicode escape \uXXXX (simplified - just skip for now)
                    self.position = self.position + 4;  // Skip 4 hex digits
                    result = result + "?";  // Placeholder
                } else {
                    result = result + escaped;
                }
            } else {
                result = result + ch;
            }
        }

        return Err("Unterminated string");
    }

    // Parse array
    fn parse_array(self: &mut JsonParser) -> Result<JsonValue, String> {
        self.position = self.position + 1; // Skip '['
        let arr = Vec::new();

        loop {
            self.skip_whitespace();
            if self.peek() == "]" {
                self.position = self.position + 1;
                break;
            }

            let value = self.parse_value()?;
            arr.push(value);

            self.skip_whitespace();
            if self.peek() == "," {
                self.position = self.position + 1;
            }
        }

        return Ok(JsonValue::Array(arr));
    }

    // Parse object
    fn parse_object(self: &mut JsonParser) -> Result<JsonValue, String> {
        self.position = self.position + 1; // Skip '{'
        let obj = HashMap::new();

        loop {
            self.skip_whitespace();
            if self.peek() == "}" {
                self.position = self.position + 1;
                break;
            }

            // Parse key
            let key_value = self.parse_string()?;
            let key = match key_value {
                JsonValue::String(s) => s,
                _ => return Err("Expected string key"),
            };

            self.skip_whitespace();
            if self.peek() != ":" {
                return Err("Expected ':' after key");
            }
            self.position = self.position + 1;

            // Parse value
            let value = self.parse_value()?;
            obj.insert(key, value);

            self.skip_whitespace();
            if self.peek() == "," {
                self.position = self.position + 1;
            }
        }

        return Ok(JsonValue::Object(obj));
    }

    // Peek at current character
    fn peek(self: &JsonParser) -> String {
        return self.char_at(self.position);
    }

    // Advance position
    fn advance(self: &mut JsonParser) -> String {
        let ch = self.peek();
        self.position = self.position + 1;
        return ch;
    }

    // Check if we're at end of input
    fn is_eof(self: &JsonParser) -> bool {
        return self.position >= self.input.len();
    }

    // Expect a specific character
    fn expect(self: &mut JsonParser, expected: String) -> Result<(), String> {
        let ch = self.advance();
        if ch == expected {
            return Ok(());
        }
        return Err("Unexpected character");
    }

    // Match a keyword
    fn match_keyword(self: &mut JsonParser, keyword: String) -> Result<(), String> {
        let start_pos = self.position;
        for i in 0..keyword.len() {
            if self.char_at(self.position) != keyword.substring(i, i + 1) {
                self.position = start_pos;  // Reset on failure
                return Err("Keyword mismatch");
            }
            self.position = self.position + 1;
        }
        return Ok(());
    }
}

// JSON serializer
struct JsonSerializer {
    pretty: bool,
    indent_level: i32,
}

impl JsonSerializer {
    // Create a new serializer
    fn new(pretty: bool) -> JsonSerializer {
        return JsonSerializer {
            pretty: pretty,
            indent_level: 0,
        };
    }

    // Serialize JsonValue to string
    fn serialize(self: &mut JsonSerializer, value: &JsonValue) -> String {
        match value {
            JsonValue::Null => "null",
            JsonValue::Bool(b) => {
                if *b {
                    "true"
                } else {
                    "false"
                }
            },
            JsonValue::Number(n) => {
                // Convert number to string
                // In JavaScript: n.toString()
                return n.to_string();
            },
            JsonValue::String(s) => {
                // Escape and quote string
                return self.escape_string(s);
            },
            JsonValue::Array(arr) => self.serialize_array(arr),
            JsonValue::Object(obj) => self.serialize_object(obj),
        }
    }

    // Escape a string for JSON
    fn escape_string(self: &JsonSerializer, s: &String) -> String {
        let mut result = "\"";

        for i in 0..s.len() {
            let ch = s.substring(i, i + 1);

            if ch == "\"" {
                result = result + "\\\"";
            } else if ch == "\\" {
                result = result + "\\\\";
            } else if ch == "\n" {
                result = result + "\\n";
            } else if ch == "\r" {
                result = result + "\\r";
            } else if ch == "\t" {
                result = result + "\\t";
            } else if ch == "\b" {
                result = result + "\\b";
            } else if ch == "\f" {
                result = result + "\\f";
            } else {
                result = result + ch;
            }
        }

        result = result + "\"";
        return result;
    }

    // Serialize array
    fn serialize_array(self: &mut JsonSerializer, arr: &Vec<JsonValue>) -> String {
        let result = "[";

        let i = 0;
        for value in arr {
            if i > 0 {
                result = result + ",";
            }
            if self.pretty {
                result = result + "\n" + self.indent();
            }
            result = result + self.serialize(value);
            i = i + 1;
        }

        if self.pretty {
            result = result + "\n";
        }
        result = result + "]";
        return result;
    }

    // Serialize object
    fn serialize_object(self: &mut JsonSerializer, obj: &HashMap<String, JsonValue>) -> String {
        let result = "{";

        let i = 0;
        let keys = obj.keys();
        for key in keys {
            if i > 0 {
                result = result + ",";
            }
            if self.pretty {
                result = result + "\n" + self.indent();
            }

            // Key
            result = result + "\"" + key + "\":";
            if self.pretty {
                result = result + " ";
            }

            // Value
            match obj.get(key) {
                Option::Some(value) => {
                    result = result + self.serialize(value);
                },
                Option::None => {},
            }

            i = i + 1;
        }

        if self.pretty {
            result = result + "\n";
        }
        result = result + "}";
        return result;
    }

    // Get indentation string
    fn indent(self: &JsonSerializer) -> String {
        let spaces = "";
        let i = 0;
        for i in 0..(self.indent_level * 2) {
            spaces = spaces + " ";
        }
        return spaces;
    }
}

// Public API functions

// Parse JSON string into JsonValue
// Uses JavaScript's native JSON.parse() for performance and correctness
fn parse(input: String) -> Result<JsonValue, String> {
    // This will be compiled to JavaScript's JSON.parse()
    // For now, we'll use a simplified implementation
    // In production, this should call: JSON.parse(input)

    // Try to parse using JavaScript JSON.parse via external call
    // @external("JSON.parse")
    // fn json_parse_native(s: String) -> JsonValue;

    // Fallback to manual parser for now
    let mut parser = JsonParser::new(input);
    return parser.parse();
}

// Serialize JsonValue to JSON string
// Uses JavaScript's native JSON.stringify() for performance
fn stringify(value: &JsonValue) -> String {
    // This will be compiled to JavaScript's JSON.stringify()
    // For now, we'll use a simplified implementation
    // In production, this should call: JSON.stringify(value)

    // @external("JSON.stringify")
    // fn json_stringify_native(v: JsonValue) -> String;

    // Fallback to manual serializer for now
    let mut serializer = JsonSerializer::new(false);
    return serializer.serialize(value);
}

// Serialize JsonValue to pretty-printed JSON string
fn stringify_pretty(value: &JsonValue) -> String {
    let mut serializer = JsonSerializer::new(true);
    return serializer.serialize(value);
}

// Create empty JSON object
fn object() -> JsonValue {
    return JsonValue::Object(HashMap::new());
}

// Create empty JSON array
fn array() -> JsonValue {
    return JsonValue::Array(Vec::new());
}

// Create JSON null
fn null() -> JsonValue {
    return JsonValue::Null;
}

// Create JSON boolean
fn bool(value: bool) -> JsonValue {
    return JsonValue::Bool(value);
}

// Create JSON number from i32
fn number_i32(value: i32) -> JsonValue {
    return JsonValue::Number(value as f64);
}

// Create JSON number from f64
fn number_f64(value: f64) -> JsonValue {
    return JsonValue::Number(value);
}

// Create JSON string
fn string(value: String) -> JsonValue {
    return JsonValue::String(value);
}

// Helper: Parse JSON from HTTP response body
fn parse_response(body: String) -> Result<JsonValue, String> {
    return parse(body);
}

// Helper: Create JSON request body
fn create_request_body(data: JsonValue) -> String {
    return stringify(&data);
}



// Duration represents a span of time
struct Duration {
    milliseconds: i64,
}

impl Duration {
    // Create a duration from milliseconds
    fn from_millis(ms: i64) -> Duration {
        return Duration {
            milliseconds: ms,
        };
    }

    // Create a duration from seconds
    fn from_seconds(secs: i64) -> Duration {
        return Duration {
            milliseconds: secs * 1000,
        };
    }

    // Create a duration from minutes
    fn from_minutes(mins: i64) -> Duration {
        return Duration {
            milliseconds: mins * 60 * 1000,
        };
    }

    // Create a duration from hours
    fn from_hours(hours: i64) -> Duration {
        return Duration {
            milliseconds: hours * 60 * 60 * 1000,
        };
    }

    // Create a duration from days
    fn from_days(days: i64) -> Duration {
        return Duration {
            milliseconds: days * 24 * 60 * 60 * 1000,
        };
    }

    // Get duration as milliseconds
    fn as_millis(self: &Duration) -> i64 {
        return self.milliseconds;
    }

    // Get duration as seconds
    fn as_seconds(self: &Duration) -> i64 {
        return self.milliseconds / 1000;
    }

    // Get duration as minutes
    fn as_minutes(self: &Duration) -> i64 {
        return self.milliseconds / (60 * 1000);
    }

    // Get duration as hours
    fn as_hours(self: &Duration) -> i64 {
        return self.milliseconds / (60 * 60 * 1000);
    }

    // Get duration as days
    fn as_days(self: &Duration) -> i64 {
        return self.milliseconds / (24 * 60 * 60 * 1000);
    }

    // Add two durations
    fn add(self: &Duration, other: &Duration) -> Duration {
        return Duration {
            milliseconds: self.milliseconds + other.milliseconds,
        };
    }

    // Subtract two durations
    fn sub(self: &Duration, other: &Duration) -> Duration {
        return Duration {
            milliseconds: self.milliseconds - other.milliseconds,
        };
    }

    // Multiply duration by a scalar
    fn mul(self: &Duration, factor: i64) -> Duration {
        return Duration {
            milliseconds: self.milliseconds * factor,
        };
    }

    // Divide duration by a scalar
    fn div(self: &Duration, divisor: i64) -> Duration {
        return Duration {
            milliseconds: self.milliseconds / divisor,
        };
    }

    // Compare durations
    fn eq(self: &Duration, other: &Duration) -> bool {
        return self.milliseconds == other.milliseconds;
    }

    fn lt(self: &Duration, other: &Duration) -> bool {
        return self.milliseconds < other.milliseconds;
    }

    fn gt(self: &Duration, other: &Duration) -> bool {
        return self.milliseconds > other.milliseconds;
    }
}

// DateTime represents a specific point in time
struct DateTime {
    timestamp: i64,  // Unix timestamp in milliseconds
}

impl DateTime {
    // Get current date and time
    fn now() -> DateTime {
        // In JavaScript: Date.now()
        // Returns Unix timestamp in milliseconds
        let current_time = 0;  // Will be replaced with Date.now() when compiled to JS

        // For JS compilation, this will become: new Date().getTime()
        // @js: new Date().getTime()

        return DateTime {
            timestamp: current_time,
        };
    }

    // Create from Unix timestamp (milliseconds)
    fn from_timestamp(ms: i64) -> DateTime {
        return DateTime {
            timestamp: ms,
        };
    }

    // Create from Unix timestamp (seconds)
    fn from_unix_seconds(secs: i64) -> DateTime {
        return DateTime {
            timestamp: secs * 1000,
        };
    }

    // Create from date components
    fn from_components(year: i32, month: i32, day: i32, hour: i32, minute: i32, second: i32) -> DateTime {
        // In JavaScript: new Date(year, month - 1, day, hour, minute, second).getTime()
        // @js: new Date(year, month - 1, day, hour, minute, second).getTime()

        // Simplified timestamp calculation (approximate)
        // Days since epoch (Jan 1, 1970)
        let years_diff = year - 1970;
        let days_from_years = years_diff * 365;

        // Add leap years (rough approximation)
        let leap_years = years_diff / 4;
        let total_days = days_from_years + leap_years;

        // Add days from months (approximate)
        let days_in_months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        let days_from_months = days_in_months[month - 1];

        // Total days
        let total_days_with_month = total_days + days_from_months + day - 1;

        // Calculate timestamp
        let timestamp = (total_days_with_month as i64) * 24 * 60 * 60 * 1000;
        let timestamp_with_hours = timestamp + ((hour as i64) * 60 * 60 * 1000);
        let timestamp_with_minutes = timestamp_with_hours + ((minute as i64) * 60 * 1000);
        let final_timestamp = timestamp_with_minutes + ((second as i64) * 1000);

        return DateTime {
            timestamp: final_timestamp,
        };
    }

    // Parse from ISO 8601 string
    fn parse(date_str: String) -> Result<DateTime, String> {
        // In JavaScript: Date.parse(dateStr)
        // Returns timestamp in milliseconds or NaN

        // @js: const ts = Date.parse(date_str); if (isNaN(ts)) { return Err("Invalid date"); } return Ok(new DateTime(ts));

        // Simplified parsing - just return current time for now
        // Real implementation would parse ISO 8601 format
        return Ok(DateTime { timestamp: 0 });
    }

    // Get timestamp in milliseconds
    fn timestamp_millis(self: &DateTime) -> i64 {
        return self.timestamp;
    }

    // Get timestamp in seconds
    fn timestamp_seconds(self: &DateTime) -> i64 {
        return self.timestamp / 1000;
    }

    // Get year
    fn year(self: &DateTime) -> i32 {
        // In JavaScript: new Date(timestamp).getFullYear()
        // @js: new Date(this.timestamp).getFullYear()

        // Simplified calculation (will be replaced by JS Date API)
        // Epoch year is 1970
        let years_since_epoch = self.timestamp / (365 * 24 * 60 * 60 * 1000);
        return 1970 + (years_since_epoch as i32);
    }

    // Get month (1-12)
    fn month(self: &DateTime) -> i32 {
        // In JavaScript: new Date(timestamp).getMonth() + 1
        // @js: new Date(this.timestamp).getMonth() + 1

        // Will be replaced by JS Date API
        return 1;
    }

    // Get day of month (1-31)
    fn day(self: &DateTime) -> i32 {
        // In JavaScript: new Date(timestamp).getDate()
        // @js: new Date(this.timestamp).getDate()

        // Will be replaced by JS Date API
        return 1;
    }

    // Get day of week (0 = Sunday, 6 = Saturday)
    fn day_of_week(self: &DateTime) -> i32 {
        // In JavaScript: new Date(timestamp).getDay()
        // @js: new Date(this.timestamp).getDay()

        // Will be replaced by JS Date API
        return 0;
    }

    // Get hour (0-23)
    fn hour(self: &DateTime) -> i32 {
        // In JavaScript: new Date(timestamp).getHours()
        // @js: new Date(this.timestamp).getHours()

        // Simplified calculation
        let hours_since_epoch = self.timestamp / (60 * 60 * 1000);
        return (hours_since_epoch % 24) as i32;
    }

    // Get minute (0-59)
    fn minute(self: &DateTime) -> i32 {
        // In JavaScript: new Date(timestamp).getMinutes()
        // @js: new Date(this.timestamp).getMinutes()

        // Simplified calculation
        let minutes_since_epoch = self.timestamp / (60 * 1000);
        return (minutes_since_epoch % 60) as i32;
    }

    // Get second (0-59)
    fn second(self: &DateTime) -> i32 {
        // In JavaScript: new Date(timestamp).getSeconds()
        // @js: new Date(this.timestamp).getSeconds()

        // Simplified calculation
        let seconds_since_epoch = self.timestamp / 1000;
        return (seconds_since_epoch % 60) as i32;
    }

    // Get millisecond (0-999)
    fn millisecond(self: &DateTime) -> i32 {
        return (self.timestamp % 1000) as i32;
    }

    // Add duration to datetime
    fn add_duration(self: &DateTime, duration: &Duration) -> DateTime {
        return DateTime {
            timestamp: self.timestamp + duration.milliseconds,
        };
    }

    // Subtract duration from datetime
    fn sub_duration(self: &DateTime, duration: &Duration) -> DateTime {
        return DateTime {
            timestamp: self.timestamp - duration.milliseconds,
        };
    }

    // Calculate duration between two datetimes
    fn duration_since(self: &DateTime, other: &DateTime) -> Duration {
        return Duration {
            milliseconds: self.timestamp - other.timestamp,
        };
    }

    // Format datetime as ISO 8601 string
    fn to_iso_string(self: &DateTime) -> String {
        // In JavaScript: new Date(timestamp).toISOString()
        // @js: new Date(this.timestamp).toISOString()

        // Manual formatting as fallback
        let year = self.year();
        let month = self.month();
        let day = self.day();
        let hour = self.hour();
        let minute = self.minute();
        let second = self.second();
        let ms = self.millisecond();

        // Format: "YYYY-MM-DDTHH:MM:SS.sssZ"
        let result = "";
        result = result + year.to_string();
        result = result + "-";
        result = result + self.pad_zero(month, 2);
        result = result + "-";
        result = result + self.pad_zero(day, 2);
        result = result + "T";
        result = result + self.pad_zero(hour, 2);
        result = result + ":";
        result = result + self.pad_zero(minute, 2);
        result = result + ":";
        result = result + self.pad_zero(second, 2);
        result = result + ".";
        result = result + self.pad_zero(ms, 3);
        result = result + "Z";

        return result;
    }

    // Helper to pad number with zeros
    fn pad_zero(self: &DateTime, num: i32, width: i32) -> String {
        let s = num.to_string();
        let mut result = s;

        while result.len() < width {
            result = "0" + result;
        }

        return result;
    }

    // Format datetime with custom format string
    fn format(self: &DateTime, format_str: String) -> String {
        // Support format codes:
        // %Y - 4-digit year
        // %m - 2-digit month
        // %d - 2-digit day
        // %H - 2-digit hour (24h)
        // %M - 2-digit minute
        // %S - 2-digit second

        let mut result = format_str;

        // Replace format codes
        result = result.replace("%Y", self.year().to_string());
        result = result.replace("%m", self.pad_zero(self.month(), 2));
        result = result.replace("%d", self.pad_zero(self.day(), 2));
        result = result.replace("%H", self.pad_zero(self.hour(), 2));
        result = result.replace("%M", self.pad_zero(self.minute(), 2));
        result = result.replace("%S", self.pad_zero(self.second(), 2));

        return result;
    }

    // Format as RFC 2822 (email format)
    fn to_rfc2822(self: &DateTime) -> String {
        // In JavaScript: new Date(timestamp).toUTCString()
        // @js: new Date(this.timestamp).toUTCString()

        // Format: "Mon, 15 Jan 2024 14:30:00 +0000"
        let days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        let months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

        let day_name = days[self.day_of_week()];
        let month_name = months[self.month() - 1];

        let result = "";
        result = result + day_name + ", ";
        result = result + self.day().to_string() + " ";
        result = result + month_name + " ";
        result = result + self.year().to_string() + " ";
        result = result + self.pad_zero(self.hour(), 2) + ":";
        result = result + self.pad_zero(self.minute(), 2) + ":";
        result = result + self.pad_zero(self.second(), 2);
        result = result + " +0000";

        return result;
    }

    // Compare datetimes
    fn eq(self: &DateTime, other: &DateTime) -> bool {
        return self.timestamp == other.timestamp;
    }

    fn lt(self: &DateTime, other: &DateTime) -> bool {
        return self.timestamp < other.timestamp;
    }

    fn gt(self: &DateTime, other: &DateTime) -> bool {
        return self.timestamp > other.timestamp;
    }

    // Check if datetime is before another
    fn is_before(self: &DateTime, other: &DateTime) -> bool {
        return self.timestamp < other.timestamp;
    }

    // Check if datetime is after another
    fn is_after(self: &DateTime, other: &DateTime) -> bool {
        return self.timestamp > other.timestamp;
    }
}

// Time zone information
enum TimeZone {
    UTC,
    Local,
    Offset(i32),  // Offset in minutes
}

// Date with timezone
struct ZonedDateTime {
    datetime: DateTime,
    timezone: TimeZone,
}

impl ZonedDateTime {
    // Create from datetime and timezone
    fn new(datetime: DateTime, timezone: TimeZone) -> ZonedDateTime {
        return ZonedDateTime {
            datetime: datetime,
            timezone: timezone,
        };
    }

    // Get current time in UTC
    fn now_utc() -> ZonedDateTime {
        return ZonedDateTime {
            datetime: DateTime::now(),
            timezone: TimeZone::UTC,
        };
    }

    // Get current time in local timezone
    fn now_local() -> ZonedDateTime {
        return ZonedDateTime {
            datetime: DateTime::now(),
            timezone: TimeZone::Local,
        };
    }

    // Convert to UTC
    fn to_utc(self: &ZonedDateTime) -> ZonedDateTime {
        // Would apply timezone conversion
        return ZonedDateTime {
            datetime: self.datetime,
            timezone: TimeZone::UTC,
        };
    }

    // Convert to local timezone
    fn to_local(self: &ZonedDateTime) -> ZonedDateTime {
        // Would apply timezone conversion
        return ZonedDateTime {
            datetime: self.datetime,
            timezone: TimeZone::Local,
        };
    }

    // Get the underlying DateTime
    fn datetime(self: &ZonedDateTime) -> DateTime {
        return self.datetime;
    }
}

// Timer for measuring elapsed time
struct Timer {
    start_time: i64,
}

impl Timer {
    // Start a new timer
    fn start() -> Timer {
        let now = DateTime::now();
        return Timer {
            start_time: now.timestamp,
        };
    }

    // Get elapsed time since timer started
    fn elapsed(self: &Timer) -> Duration {
        let now = DateTime::now();
        return Duration {
            milliseconds: now.timestamp - self.start_time,
        };
    }

    // Reset the timer
    fn reset(self: &mut Timer) {
        let now = DateTime::now();
        self.start_time = now.timestamp;
    }
}

// Stopwatch for lap timing
struct Stopwatch {
    start_time: i64,
    laps: Vec<i64>,
    running: bool,
}

impl Stopwatch {
    // Create a new stopwatch
    fn new() -> Stopwatch {
        return Stopwatch {
            start_time: 0,
            laps: Vec::new(),
            running: false,
        };
    }

    // Start the stopwatch
    fn start(self: &mut Stopwatch) {
        let now = DateTime::now();
        self.start_time = now.timestamp;
        self.running = true;
    }

    // Stop the stopwatch
    fn stop(self: &mut Stopwatch) -> Duration {
        self.running = false;
        let elapsed = self.elapsed();
        return elapsed;
    }

    // Record a lap time
    fn lap(self: &mut Stopwatch) -> Duration {
        let now = DateTime::now();
        let lap_time = now.timestamp - self.start_time;
        self.laps.push(lap_time);
        return Duration::from_millis(lap_time);
    }

    // Get elapsed time
    fn elapsed(self: &Stopwatch) -> Duration {
        let now = DateTime::now();
        return Duration::from_millis(now.timestamp - self.start_time);
    }

    // Reset the stopwatch
    fn reset(self: &mut Stopwatch) {
        self.start_time = 0;
        self.laps.clear();
        self.running = false;
    }

    // Get all lap times
    fn get_laps(self: &Stopwatch) -> Vec<Duration> {
        let result = Vec::new();
        for lap_ms in self.laps {
            result.push(Duration::from_millis(lap_ms));
        }
        return result;
    }
}

// Public convenience functions

// Get current time
fn now() -> DateTime {
    return DateTime::now();
}

// Get current UTC time
fn now_utc() -> ZonedDateTime {
    return ZonedDateTime::now_utc();
}

// Get current local time
fn now_local() -> ZonedDateTime {
    return ZonedDateTime::now_local();
}

// Sleep for a duration (async operation)
async fn sleep(duration: Duration) {
    // In JavaScript: await new Promise(resolve => setTimeout(resolve, duration.milliseconds))
    // @js: await new Promise(resolve => setTimeout(resolve, duration.milliseconds))

    // This is an async operation that suspends execution
    // Will be implemented by JavaScript setTimeout when compiled
}

// Create a timer
fn timer() -> Timer {
    return Timer::start();
}

// Create a stopwatch
fn stopwatch() -> Stopwatch {
    return Stopwatch::new();
}

// Common duration helpers
fn seconds(n: i64) -> Duration {
    return Duration::from_seconds(n);
}

fn minutes(n: i64) -> Duration {
    return Duration::from_minutes(n);
}

fn hours(n: i64) -> Duration {
    return Duration::from_hours(n);
}

fn days(n: i64) -> Duration {
    return Duration::from_days(n);
}

// Parse duration from string
fn parse_duration(s: String) -> Result<Duration, String> {
    // Parse strings like "5s", "2m", "1h", "3d", "500ms"

    let trimmed = s.trim();
    if trimmed.is_empty() {
        return Err("Empty duration string");
    }

    // Extract number and unit
    let mut number_str = "";
    let mut unit = "";
    let mut found_unit = false;

    for i in 0..trimmed.len() {
        let ch = trimmed.substring(i, i + 1);

        if !found_unit && (ch >= "0" && ch <= "9" || ch == ".") {
            number_str = number_str + ch;
        } else {
            found_unit = true;
            unit = unit + ch;
        }
    }

    // Parse the number
    let num = number_str.parse_float();
    if num < 0.0 {
        return Err("Invalid duration number");
    }

    // Convert based on unit
    if unit == "ms" {
        return Ok(Duration::from_millis(num as i64));
    } else if unit == "s" {
        return Ok(Duration::from_seconds(num as i64));
    } else if unit == "m" || unit == "min" {
        return Ok(Duration::from_minutes(num as i64));
    } else if unit == "h" || unit == "hr" {
        return Ok(Duration::from_hours(num as i64));
    } else if unit == "d" || unit == "day" {
        return Ok(Duration::from_days(num as i64));
    } else {
        return Err("Unknown duration unit");
    }
}

// Parse datetime from string
fn parse_datetime(s: String) -> Result<DateTime, String> {
    return DateTime::parse(s);
}



// Cryptography Module for Jounce
// Provides security primitives for hashing, random generation, and encoding

// Hash algorithms enum
enum HashAlgorithm {
    SHA256,
    SHA1,
    MD5,
}

// Hash result struct
struct Hash {
    algorithm: HashAlgorithm,
    digest: String,  // Hex-encoded hash
}

impl Hash {
    // Get hash as hex string
    fn to_hex(self: &Hash) -> String {
        return self.digest;
    }

    // Get hash as base64 string
    fn to_base64(self: &Hash) -> String {
        // Convert hex to base64
        // @js: btoa(this.digest.match(/.{2}/g).map(byte => String.fromCharCode(parseInt(byte, 16))).join(''))
        return base64_encode(self.digest);
    }

    // Compare with another hash (constant-time comparison)
    fn eq(self: &Hash, other: &Hash) -> bool {
        if self.digest.len() != other.digest.len() {
            return false;
        }

        let mut result = 0;
        for i in 0..self.digest.len() {
            let a = self.digest.char_at(i);
            let b = other.digest.char_at(i);
            result = result | (a != b);
        }

        return result == 0;
    }
}

// Hashing functions

// SHA-256 hash
fn sha256(data: String) -> Hash {
    // In browser: crypto.subtle.digest('SHA-256', data)
    // In Node.js: crypto.createHash('sha256').update(data).digest('hex')
    // @js_browser: crypto.subtle.digest('SHA-256', new TextEncoder().encode(data)).then(buf => Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join(''))
    // @js_node: require('crypto').createHash('sha256').update(data).digest('hex')

    // Call JavaScript helper (defined in runtime)
    let digest = __crypto_sha256(data);
    return Hash {
        algorithm: HashAlgorithm::SHA256,
        digest: digest,
    };
}

// SHA-1 hash
fn sha1(data: String) -> Hash {
    // @js_browser: crypto.subtle.digest('SHA-1', new TextEncoder().encode(data))
    // @js_node: require('crypto').createHash('sha1').update(data).digest('hex')

    let digest = __crypto_sha1(data);
    return Hash {
        algorithm: HashAlgorithm::SHA1,
        digest: digest,
    };
}

// MD5 hash (not cryptographically secure - use for checksums only)
fn md5(data: String) -> Hash {
    // @js_node: require('crypto').createHash('md5').update(data).digest('hex')

    let digest = __crypto_md5(data);
    return Hash {
        algorithm: HashAlgorithm::MD5,
        digest: digest,
    };
}

// Generic hash function
fn hash(algorithm: HashAlgorithm, data: String) -> Hash {
    match algorithm {
        HashAlgorithm::SHA256 => sha256(data),
        HashAlgorithm::SHA1 => sha1(data),
        HashAlgorithm::MD5 => md5(data),
    }
}

// HMAC (Hash-based Message Authentication Code)
fn hmac_sha256(key: String, data: String) -> Hash {
    // @js_node: require('crypto').createHmac('sha256', key).update(data).digest('hex')

    let digest = __crypto_hmac("sha256", key, data);
    return Hash {
        algorithm: HashAlgorithm::SHA256,
        digest: digest,
    };
}

// Random number generation

// Generate secure random bytes
fn random_bytes(length: i32) -> Vec<u8> {
    // @js_browser: crypto.getRandomValues(new Uint8Array(length))
    // @js_node: require('crypto').randomBytes(length)

    return __crypto_random_bytes(length);
}

// Generate secure random integer in range [min, max)
fn random_int(min: i32, max: i32) -> i32 {
    // @js: Math.floor(Math.random() * (max - min)) + min

    let range = max - min;
    if range <= 0 {
        return min;
    }

    // Use secure random if available
    let bytes = random_bytes(4);
    let random_value = (bytes[0] as i32) * 16777216 +
                       (bytes[1] as i32) * 65536 +
                       (bytes[2] as i32) * 256 +
                       (bytes[3] as i32);

    return (random_value % range) + min;
}

// Generate secure random float in range [0, 1)
fn random_float() -> f64 {
    // @js: crypto.getRandomValues(new Uint32Array(1))[0] / 4294967296

    let bytes = random_bytes(4);
    let random_value = (bytes[0] as f64) * 16777216.0 +
                       (bytes[1] as f64) * 65536.0 +
                       (bytes[2] as f64) * 256.0 +
                       (bytes[3] as f64);

    return random_value / 4294967296.0;
}

// Generate random string with specified characters
fn random_string(length: i32, charset: String) -> String {
    let result = "";

    for i in 0..length {
        let index = random_int(0, charset.len());
        result = result + charset.substring(index, index + 1);
    }

    return result;
}

// Generate random alphanumeric string
fn random_alphanumeric(length: i32) -> String {
    let charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    return random_string(length, charset);
}

// Generate random hex string
fn random_hex(length: i32) -> String {
    let charset = "0123456789abcdef";
    return random_string(length, charset);
}

// UUID generation

// Generate UUID v4 (random)
fn uuid_v4() -> String {
    // Format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    // where x is random hex digit and y is 8, 9, a, or b

    // @js: crypto.randomUUID()

    let hex = random_hex(32);

    // Insert hyphens and version/variant bits
    let uuid = "";
    uuid = uuid + hex.substring(0, 8);
    uuid = uuid + "-";
    uuid = uuid + hex.substring(8, 12);
    uuid = uuid + "-4";  // Version 4
    uuid = uuid + hex.substring(13, 16);
    uuid = uuid + "-";

    // Variant bits (10xx)
    let variant_char = hex.substring(16, 17);
    let variant_value = hex_to_int(variant_char);
    let adjusted = (variant_value & 0x3) | 0x8;
    uuid = uuid + int_to_hex(adjusted);

    uuid = uuid + hex.substring(17, 20);
    uuid = uuid + "-";
    uuid = uuid + hex.substring(20, 32);

    return uuid;
}

// Base64 encoding/decoding

// Encode string to base64
fn base64_encode(data: String) -> String {
    // @js_browser: btoa(data)
    // @js_node: Buffer.from(data).toString('base64')

    // Base64 alphabet
    let alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    let result = "";
    let padding = "";

    // Convert to bytes
    let bytes = Vec::new();
    for i in 0..data.len() {
        bytes.push(data.char_code_at(i));
    }

    // Process in groups of 3 bytes
    let i = 0;
    while i < bytes.len() {
        let b1 = bytes[i];
        let b2 = if i + 1 < bytes.len() { bytes[i + 1] } else { 0 };
        let b3 = if i + 2 < bytes.len() { bytes[i + 2] } else { 0 };

        // Convert 3 bytes to 4 base64 characters
        let c1 = b1 >> 2;
        let c2 = ((b1 & 0x03) << 4) | (b2 >> 4);
        let c3 = ((b2 & 0x0F) << 2) | (b3 >> 6);
        let c4 = b3 & 0x3F;

        result = result + alphabet.substring(c1, c1 + 1);
        result = result + alphabet.substring(c2, c2 + 1);

        if i + 1 < bytes.len() {
            result = result + alphabet.substring(c3, c3 + 1);
        } else {
            padding = padding + "=";
        }

        if i + 2 < bytes.len() {
            result = result + alphabet.substring(c4, c4 + 1);
        } else {
            padding = padding + "=";
        }

        i = i + 3;
    }

    return result + padding;
}

// Decode base64 to string
fn base64_decode(encoded: String) -> Result<String, String> {
    // @js_browser: atob(encoded)
    // @js_node: Buffer.from(encoded, 'base64').toString()

    // Remove all padding characters
    let data = encoded;
    while data.contains("=") {
        data = data.replace("=", "");
    }

    // Base64 alphabet lookup
    let alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    let result = "";
    let i = 0;

    while i < data.len() {
        if i + 1 >= data.len() {
            break;
        }

        // Get 4 base64 characters
        let c1 = alphabet.index_of(data.substring(i, i + 1));
        let c2 = alphabet.index_of(data.substring(i + 1, i + 2));
        let c3 = if i + 2 < data.len() { alphabet.index_of(data.substring(i + 2, i + 3)) } else { 0 };
        let c4 = if i + 3 < data.len() { alphabet.index_of(data.substring(i + 3, i + 4)) } else { 0 };

        if c1 < 0 || c2 < 0 {
            return Err("Invalid base64 character");
        }

        // Convert 4 base64 characters to 3 bytes
        let b1 = (c1 << 2) | (c2 >> 4);
        let b2 = ((c2 & 0x0F) << 4) | (c3 >> 2);
        let b3 = ((c3 & 0x03) << 6) | c4;

        result = result + String::from_char_code(b1);

        if i + 2 < data.len() {
            result = result + String::from_char_code(b2);
        }

        if i + 3 < data.len() {
            result = result + String::from_char_code(b3);
        }

        i = i + 4;
    }

    return Ok(result);
}

// Hex encoding/decoding

// Encode bytes to hex string
fn hex_encode(bytes: &[u8]) -> String {
    let hex_chars = "0123456789abcdef";
    let result = "";

    for byte in bytes {
        let high = (byte >> 4) & 0x0F;
        let low = byte & 0x0F;
        result = result + hex_chars.substring(high as i32, (high + 1) as i32);
        result = result + hex_chars.substring(low as i32, (low + 1) as i32);
    }

    return result;
}

// Decode hex string to bytes
fn hex_decode(hex: String) -> Result<Vec<u8>, String> {
    if hex.len() % 2 != 0 {
        return Err("Hex string must have even length");
    }

    let result = Vec::new();
    let i = 0;

    while i < hex.len() {
        let high = hex_char_to_int(hex.substring(i, i + 1));
        let low = hex_char_to_int(hex.substring(i + 1, i + 2));

        if high < 0 || low < 0 {
            return Err("Invalid hex character");
        }

        let byte = (high << 4) | low;
        result.push(byte as u8);

        i = i + 2;
    }

    return Ok(result);
}

// Helper functions

// Convert hex character to integer
fn hex_char_to_int(ch: String) -> i32 {
    if ch >= "0" && ch <= "9" {
        return ch.char_code_at(0) - "0".char_code_at(0);
    } else if ch >= "a" && ch <= "f" {
        return 10 + (ch.char_code_at(0) - "a".char_code_at(0));
    } else if ch >= "A" && ch <= "F" {
        return 10 + (ch.char_code_at(0) - "A".char_code_at(0));
    }
    return -1;
}

// Convert hex string to integer
fn hex_to_int(hex: String) -> i32 {
    let result = 0;
    for i in 0..hex.len() {
        let ch = hex.substring(i, i + 1);
        let val = hex_char_to_int(ch);
        if val < 0 {
            return 0;
        }
        result = result * 16 + val;
    }
    return result;
}

// Convert integer to hex character
fn int_to_hex(value: i32) -> String {
    let hex_chars = "0123456789abcdef";
    return hex_chars.substring(value & 0x0F, (value & 0x0F) + 1);
}

// Password hashing (using PBKDF2)

struct PasswordHash {
    algorithm: String,  // e.g., "PBKDF2-SHA256"
    iterations: i32,
    salt: String,       // Hex-encoded salt
    hash: String,       // Hex-encoded hash
}

impl PasswordHash {
    // Create from components
    fn new(algorithm: String, iterations: i32, salt: String, hash: String) -> PasswordHash {
        return PasswordHash {
            algorithm: algorithm,
            iterations: iterations,
            salt: salt,
            hash: hash,
        };
    }

    // Serialize to string
    fn to_string(self: &PasswordHash) -> String {
        // Format: $algorithm$iterations$salt$hash
        let result = "$";
        result = result + self.algorithm;
        result = result + "$";
        result = result + self.iterations.to_string();
        result = result + "$";
        result = result + self.salt;
        result = result + "$";
        result = result + self.hash;
        return result;
    }

    // Parse from string
    fn from_string(s: String) -> Result<PasswordHash, String> {
        let parts = s.split("$");
        if parts.len() != 5 {
            return Err("Invalid password hash format");
        }

        let algorithm = parts[1];
        let iterations = parts[2].parse_int();
        let salt = parts[3];
        let hash = parts[4];

        return Ok(PasswordHash {
            algorithm: algorithm,
            iterations: iterations,
            salt: salt,
            hash: hash,
        });
    }

    // Verify password
    fn verify(self: &PasswordHash, password: String) -> bool {
        // Hash the password with the same salt and iterations
        let computed = hash_password(password, self.salt, self.iterations);
        return computed.hash == self.hash;
    }
}

// Hash a password with salt
fn hash_password(password: String, salt: String, iterations: i32) -> PasswordHash {
    // Use PBKDF2-HMAC-SHA256
    let hash = __crypto_pbkdf2(password, salt, iterations, 32, "sha256");
    return PasswordHash {
        algorithm: "PBKDF2-SHA256",
        iterations: iterations,
        salt: salt,
        hash: hash,
    };
}

// Generate salt for password hashing
fn generate_salt(length: i32) -> String {
    return random_hex(length);
}

// Convenience function: hash password with auto-generated salt
fn hash_password_auto(password: String) -> PasswordHash {
    let salt = generate_salt(32);  // 32 hex characters = 16 bytes
    let iterations = 100000;       // OWASP recommended minimum
    return hash_password(password, salt, iterations);
}



// File system operations (async)
// Server-side only - not available in browser

// File metadata
struct Metadata {
    size: i64,
    is_file: bool,
    is_directory: bool,
    created: i64,       // Unix timestamp in milliseconds
    modified: i64,      // Unix timestamp in milliseconds
    accessed: i64,      // Unix timestamp in milliseconds
    permissions: i32,   // Unix file permissions (e.g., 0o644)
}

impl Metadata {
    // Check if this is a regular file
    fn is_file(self: &Metadata) -> bool {
        return self.is_file;
    }

    // Check if this is a directory
    fn is_directory(self: &Metadata) -> bool {
        return self.is_directory;
    }

    // Get file size in bytes
    fn len(self: &Metadata) -> i64 {
        return self.size;
    }

    // Get creation time
    fn created(self: &Metadata) -> i64 {
        return self.created;
    }

    // Get modification time
    fn modified(self: &Metadata) -> i64 {
        return self.modified;
    }

    // Get last access time
    fn accessed(self: &Metadata) -> i64 {
        return self.accessed;
    }

    // Get permissions
    fn permissions(self: &Metadata) -> i32 {
        return self.permissions;
    }

    // Check if read-only
    fn is_readonly(self: &Metadata) -> bool {
        // Check write permission for owner
        return (self.permissions & 0o200) == 0;
    }
}

// Directory entry
struct DirEntry {
    name: String,
    path: String,
    metadata: Metadata,
}

impl DirEntry {
    // Get the entry name
    fn name(self: &DirEntry) -> String {
        return self.name;
    }

    // Get the full path
    fn path(self: &DirEntry) -> String {
        return self.path;
    }

    // Get metadata
    fn metadata(self: &DirEntry) -> Metadata {
        return self.metadata;
    }

    // Check if this is a file
    fn is_file(self: &DirEntry) -> bool {
        return self.metadata.is_file;
    }

    // Check if this is a directory
    fn is_directory(self: &DirEntry) -> bool {
        return self.metadata.is_directory;
    }
}

// File handle for reading (commented out - not used in current tests)
// The convenience functions below use JavaScript helpers directly
// This struct will be enabled once the parser supports .as_bytes() and other advanced methods

// struct File {
//     path: String,
//     position: i64,
//     size: i64,
//     is_open: bool,
// }

// impl File {
//     // Open a file for reading
//     fn open(path: String) -> Result<File, String> {
//         return Result::Ok(File {
//             path: path,
//             position: 0,
//             size: 0,
//             is_open: true,
//         });
//     }
//     // Create a new file for writing
//     fn create(path: String) -> Result<File, String> {
//         return Result::Ok(File {
//             path: path,
//             position: 0,
//             size: 0,
//             is_open: true,
//         });
//     }
//     // Read entire file contents as string
//     fn read_to_string(self: &mut File) -> Result<String, String> {
//         if !self.is_open {
//             return Result::Err("File not open");
//         }
//         return Result::Ok(String::new());
//     }
//     // Read entire file contents as bytes
//     fn read_to_end(self: &mut File) -> Result<Vec<u8>, String> {
//         if !self.is_open {
//             return Result::Err("File not open");
//         }
//         return Result::Ok(Vec::new());
//     }
//     // Read a specific number of bytes
//     fn read(self: &mut File, buf: Vec<u8>) -> Result<i64, String> {
//         if !self.is_open {
//             return Result::Err("File not open");
//         }
//         return Result::Ok(0);
//     }
//     // Write bytes to file
//     fn write(self: &mut File, data: Vec<u8>) -> Result<i64, String> {
//         if !self.is_open {
//             return Result::Err("File not open");
//         }
//         return Result::Ok(data.len() as i64);
//     }
//     // Write string to file
//     fn write_str(self: &mut File, s: String) -> Result<i64, String> {
//         // Note: .as_bytes() not supported yet
//         return Result::Ok(0);
//     }
//     // Seek to a position in the file
//     fn seek(self: &mut File, pos: i64) -> Result<i64, String> {
//         if !self.is_open {
//             return Result::Err("File not open");
//         }
//         self.position = pos;
//         return Result::Ok(pos);
//     }
//     // Get current position
//     fn position(self: &File) -> i64 {
//         return self.position;
//     }
//     // Flush buffered writes
//     fn flush(self: &mut File) -> Result<(), String> {
//         if !self.is_open {
//             return Result::Err("File not open");
//         }
//         return Result::Ok(());
//     }
//     // Close the file
//     fn close(self: &mut File) -> Result<(), String> {
//         if !self.is_open {
//             return Result::Err("File already closed");
//         }
//         self.is_open = false;
//         return Result::Ok(());
//     }
//     // Get file metadata
//     fn metadata(self: &File) -> Result<Metadata, String> {
//         return Result::Ok(Metadata {
//             size: self.size,
//             is_file: true,
//             is_directory: false,
//             created: 0,
//             modified: 0,
//             accessed: 0,
//             permissions: 0o644,
//         });
//     }
// }

// Convenience functions for common file operations

// Read entire file to string
fn read_to_string(path: String) -> Result<String, String> {
    return __fs_read_to_string_safe(path);
}

// Read entire file to bytes
fn read(path: String) -> Result<Vec<u8>, String> {
    return __fs_read_bytes_safe(path);
}

// Write string to file
fn write(path: String, contents: String) -> Result<(), String> {
    return __fs_write_string_safe(path, contents);
}

// Write bytes to file
fn write_bytes(path: String, data: Vec<u8>) -> Result<(), String> {
    return __fs_write_bytes_safe(path, data);
}

// Append string to file
fn append(path: String, contents: String) -> Result<(), String> {
    return __fs_append_string_safe(path, contents);
}

// Check if file exists
fn exists(path: String) -> bool {
    return __fs_exists(path);
}

// Check if path is a file
fn is_file(path: String) -> bool {
    match metadata(path) {
        Result::Ok(m) => m.is_file,
        Result::Err(_) => false,
    }
}

// Check if path is a directory
fn is_directory(path: String) -> bool {
    match metadata(path) {
        Result::Ok(m) => m.is_directory,
        Result::Err(_) => false,
    }
}

// Get file/directory metadata
fn metadata(path: String) -> Result<Metadata, String> {
    return __fs_metadata_safe(path);
}

// Create a directory
fn create_dir(path: String) -> Result<(), String> {
    return __fs_create_dir_safe(path);
}

// Create directory and all parent directories
fn create_dir_all(path: String) -> Result<(), String> {
    return __fs_create_dir_all_safe(path);
}

// Remove a file
fn remove_file(path: String) -> Result<(), String> {
    return __fs_remove_file_safe(path);
}

// Remove an empty directory
fn remove_dir(path: String) -> Result<(), String> {
    return __fs_remove_dir_safe(path);
}

// Remove directory and all contents
fn remove_dir_all(path: String) -> Result<(), String> {
    return __fs_remove_dir_all_safe(path);
}

// Read directory contents
fn read_dir(path: String) -> Result<Vec<DirEntry>, String> {
    return __fs_read_dir_safe(path);
}

// Copy a file
fn copy(from: String, to: String) -> Result<i64, String> {
    let contents = read(from)?;
    write_bytes(to, contents.clone())?;
    let size = contents.len() as i64;
    return Ok(size);
}

// Rename/move a file or directory
fn rename(from: String, to: String) -> Result<(), String> {
    return __fs_rename_safe(from, to);
}

// Get current working directory
fn current_dir() -> Result<String, String> {
    // Would get current directory
    return Result::Ok(String::from("/"));
}

// Set current working directory
fn set_current_dir(path: String) -> Result<(), String> {
    // Would change directory
    return Result::Ok(());
}

// Canonicalize a path (resolve .. and . and symlinks)
fn canonicalize(path: String) -> Result<String, String> {
    // Would resolve path
    return Result::Ok(path);
}

// Create a symbolic link
fn symlink(original: String, link: String) -> Result<(), String> {
    // Would create symlink
    return Result::Ok(());
}

// Read a symbolic link
fn read_link(path: String) -> Result<String, String> {
    // Would read symlink target
    return Result::Ok(String::new());
}

// Set file permissions
fn set_permissions(path: String, perms: i32) -> Result<(), String> {
    // Would set permissions
    return Result::Ok(());
}

// Walk directory tree recursively
fn walk_dir(path: String) -> Result<Vec<DirEntry>, String> {
    let mut results = Vec::new();
    let entries = read_dir(path)?;

    for entry in entries {
        results.push(entry);

        if entry.is_directory() {
            let sub_entries = walk_dir(entry.path())?;
            for sub_entry in sub_entries {
                results.push(sub_entry);
            }
        }
    }

    return Result::Ok(results);
}

// Find files matching a pattern (glob)
fn glob(pattern: String) -> Result<Vec<String>, String> {
    // Would find matching files
    return Result::Ok(Vec::new());
}

// Path manipulation functions (commented out pending parser enhancements for .split())
// These will be enabled once the parser supports method calls with string literal arguments

// // Get file extension
// fn extension(path: String) -> Option<String> {
//     let parts = path.split(".");
//     if parts.len() > 1 {
//         return Option::Some(parts[parts.len() - 1]);
//     }
//     return Option::None;
// }

// // Get file name without extension
// fn file_stem(path: String) -> Option<String> {
//     let parts = path.split("/");
//     if parts.len() == 0 {
//         return Option::None;
//     }
//     let filename = parts[parts.len() - 1];
//     let name_parts = filename.split(".");
//     if name_parts.len() > 1 {
//         // Remove extension
//         let stem = String::new();
//         for i in 0..(name_parts.len() - 1) {
//             if i > 0 {
//                 stem.push_str(".");
//             }
//             stem.push_str(&name_parts[i]);
//         }
//         return Option::Some(stem);
//     }
//     return Option::Some(filename);
// }

// // Get file name (last component of path)
// fn file_name(path: String) -> Option<String> {
//     let parts = path.split("/");
//     if parts.len() == 0 {
//         return Option::None;
//     }
//     return Option::Some(parts[parts.len() - 1]);
// }

// // Get parent directory
// fn parent(path: String) -> Option<String> {
//     let parts = path.split("/");
//     if parts.len() <= 1 {
//         return Option::None;
//     }
//     let parent_path = String::new();
//     for i in 0..(parts.len() - 1) {
//         if i > 0 {
//             parent_path.push_str("/");
//         }
//         parent_path.push_str(&parts[i]);
//     }
//     return Option::Some(parent_path);
// }

// // Join path components
// fn join(base: String, component: String) -> String {
//     if base.ends_with("/") {
//         return base + &component;
//     } else {
//         return base + "/" + &component;
//     }
// }

// // Check if path is absolute
// fn is_absolute(path: String) -> bool {
//     return path.starts_with("/");
// }

// // Check if path is relative
// fn is_relative(path: String) -> bool {
//     return !is_absolute(path);
// }



// YAML parsing and serialization module
// Supports scalars, sequences, mappings, and basic multi-line strings

// YAML value types
enum YamlValue {
    Null,
    Bool(bool),
    Number(f64),
    String(String),
    Sequence(Vec<YamlValue>),
    Mapping(HashMap<String, YamlValue>),
}

impl YamlValue {
    // Type checking methods
    fn is_null(self: &YamlValue) -> bool {
        match self {
            YamlValue::Null => true,
            _ => false,
        }
    }

    fn is_bool(self: &YamlValue) -> bool {
        match self {
            YamlValue::Bool(_) => true,
            _ => false,
        }
    }

    fn is_number(self: &YamlValue) -> bool {
        match self {
            YamlValue::Number(_) => true,
            _ => false,
        }
    }

    fn is_string(self: &YamlValue) -> bool {
        match self {
            YamlValue::String(_) => true,
            _ => false,
        }
    }

    fn is_sequence(self: &YamlValue) -> bool {
        match self {
            YamlValue::Sequence(_) => true,
            _ => false,
        }
    }

    fn is_mapping(self: &YamlValue) -> bool {
        match self {
            YamlValue::Mapping(_) => true,
            _ => false,
        }
    }

    // Conversion methods
    fn as_bool(self: &YamlValue) -> Option<bool> {
        match self {
            YamlValue::Bool(b) => Option::Some(*b),
            _ => Option::None,
        }
    }

    fn as_number(self: &YamlValue) -> Option<f64> {
        match self {
            YamlValue::Number(n) => Option::Some(*n),
            _ => Option::None,
        }
    }

    fn as_string(self: &YamlValue) -> Option<String> {
        match self {
            YamlValue::String(s) => Option::Some(s.clone()),
            _ => Option::None,
        }
    }

    fn as_sequence(self: &YamlValue) -> Option<Vec<YamlValue> > {
        match self {
            YamlValue::Sequence(seq) => Option::Some(seq.clone()),
            _ => Option::None,
        }
    }

    fn as_mapping(self: &YamlValue) -> Option<HashMap<String, YamlValue> > {
        match self {
            YamlValue::Mapping(map) => Option::Some(map.clone()),
            _ => Option::None,
        }
    }

    // Access methods for mappings
    fn get(self: &YamlValue, key: String) -> Option<YamlValue> {
        match self {
            YamlValue::Mapping(map) => {
                if map.contains_key(&key) {
                    Option::Some(map.get(&key).unwrap().clone())
                } else {
                    Option::None
                }
            }
            _ => Option::None,
        }
    }

    fn set(self: &mut YamlValue, key: String, value: YamlValue) -> bool {
        match self {
            YamlValue::Mapping(map) => {
                map.insert(key, value);
                return true;
            }
            _ => false,
        }
    }

    fn keys(self: &YamlValue) -> Vec<String> {
        match self {
            YamlValue::Mapping(map) => {
                let mut result = Vec::new();
                for key in map.keys() {
                    result.push(key.clone());
                }
                return result;
            }
            _ => Vec::new(),
        }
    }

    // Access methods for sequences
    fn get_index(self: &YamlValue, index: i64) -> Option<YamlValue> {
        match self {
            YamlValue::Sequence(seq) => {
                if index >= 0 && (index as usize) < seq.len() {
                    Option::Some(seq[index as usize].clone())
                } else {
                    Option::None
                }
            }
            _ => Option::None,
        }
    }

    fn push(self: &mut YamlValue, value: YamlValue) -> bool {
        match self {
            YamlValue::Sequence(seq) => {
                seq.push(value);
                return true;
            }
            _ => false,
        }
    }

    fn len(self: &YamlValue) -> i64 {
        match self {
            YamlValue::Sequence(seq) => seq.len() as i64,
            YamlValue::Mapping(map) => map.len() as i64,
            YamlValue::String(s) => s.len() as i64,
            _ => 0,
        }
    }

    // String representation
    fn to_string(self: &YamlValue) -> String {
        match self {
            YamlValue::Null => String::from("null"),
            YamlValue::Bool(b) => if *b { String::from("true") } else { String::from("false") },
            YamlValue::Number(n) => n.to_string(),
            YamlValue::String(s) => s.clone(),
            YamlValue::Sequence(_) => String::from("[Sequence]"),
            YamlValue::Mapping(_) => String::from("[Mapping]"),
        }
    }
}

// YAML Parser
struct YamlParser {
    input: String,
    position: i64,
    line: i64,
    column: i64,
    indent_level: i64,
}

impl YamlParser {
    fn new(input: String) -> YamlParser {
        return YamlParser {
            input: input,
            position: 0,
            line: 1,
            column: 0,
            indent_level: 0,
        };
    }

    fn current_char(self: &YamlParser) -> String {
        if self.position >= self.input.len() as i64 {
            return String::new();
        }
        return self.input.char_at(self.position as usize);
    }

    fn peek_char(self: &YamlParser, offset: i64) -> String {
        let pos = self.position + offset;
        if pos >= self.input.len() as i64 {
            return String::new();
        }
        return self.input.char_at(pos as usize);
    }

    fn advance(self: &mut YamlParser) {
        if self.position < self.input.len() as i64 {
            let ch = self.current_char();
            if ch == "\n" {
                self.line = self.line + 1;
                self.column = 0;
            } else {
                self.column = self.column + 1;
            }
            self.position = self.position + 1;
        }
    }

    fn skip_whitespace(self: &mut YamlParser) {
        loop {
            let ch = self.current_char();
            if ch == " " || ch == "\t" {
                self.advance();
            } else {
                break;
            }
        }
    }

    fn skip_line(self: &mut YamlParser) {
        loop {
            let ch = self.current_char();
            if ch.is_empty() || ch == "\n" {
                break;
            }
            self.advance();
        }
        if self.current_char() == "\n" {
            self.advance();
        }
    }

    fn parse_value(self: &mut YamlParser) -> Result<YamlValue, String> {
        self.skip_whitespace();

        let ch = self.current_char();

        // Handle comments
        if ch == "#" {
            self.skip_line();
            return self.parse_value();
        }

        // Handle sequences (flow style: [1, 2, 3])
        if ch == "[" {
            return self.parse_flow_sequence();
        }

        // Handle mappings (flow style: {key: value})
        if ch == "{" {
            return self.parse_flow_mapping();
        }

        // Handle sequences (block style with -)
        if ch == "-" && (self.peek_char(1) == " " || self.peek_char(1) == "\n") {
            return self.parse_block_sequence();
        }

        // Handle scalars
        return self.parse_scalar();
    }

    fn parse_scalar(self: &mut YamlParser) -> Result<YamlValue, String> {
        let start = self.position;
        let mut value = String::new();

        // Read until newline, comma, or end of input
        loop {
            let ch = self.current_char();
            if ch.is_empty() || ch == "\n" || ch == "," || ch == "]" || ch == "}" {
                break;
            }
            if ch == "#" {
                break;
            }
            value.push_str(&ch);
            self.advance();
        }

        // Trim whitespace
        value = value.trim().to_string();

        // Parse as appropriate type
        if value == "null" || value == "~" || value.is_empty() {
            return Result::Ok(YamlValue::Null);
        }

        if value == "true" {
            return Result::Ok(YamlValue::Bool(true));
        }

        if value == "false" {
            return Result::Ok(YamlValue::Bool(false));
        }

        // Try to parse as number
        let num_opt = value.parse_float();
        match num_opt {
            Option::Some(num) => {
                return Result::Ok(YamlValue::Number(num));
            }
            Option::None => {}
        }

        // Remove quotes if present
        if value.starts_with("\"") && value.ends_with("\"") {
            value = value.substring(1, value.len() - 1);
        } else if value.starts_with("'") && value.ends_with("'") {
            value = value.substring(1, value.len() - 1);
        }

        return Result::Ok(YamlValue::String(value));
    }

    fn parse_flow_sequence(self: &mut YamlParser) -> Result<YamlValue, String> {
        // Skip opening [
        self.advance();

        let mut sequence = Vec::new();

        loop {
            self.skip_whitespace();

            let ch = self.current_char();
            if ch == "]" {
                self.advance();
                break;
            }

            if ch.is_empty() {
                return Result::Err(String::from("Unexpected end of input in sequence"));
            }

            // Parse value
            let value = self.parse_value()?;
            sequence.push(value);

            self.skip_whitespace();

            // Check for comma or closing bracket
            let next = self.current_char();
            if next == "," {
                self.advance();
            } else if next == "]" {
                self.advance();
                break;
            } else if !next.is_empty() {
                return Result::Err(String::from("Expected ',' or ']' in sequence"));
            }
        }

        return Result::Ok(YamlValue::Sequence(sequence));
    }

    fn parse_flow_mapping(self: &mut YamlParser) -> Result<YamlValue, String> {
        // Skip opening {
        self.advance();

        let mut mapping = HashMap::new();

        loop {
            self.skip_whitespace();

            let ch = self.current_char();
            if ch == "}" {
                self.advance();
                break;
            }

            if ch.is_empty() {
                return Result::Err(String::from("Unexpected end of input in mapping"));
            }

            // Parse key
            let key_result = self.parse_scalar()?;
            let key = match key_result {
                YamlValue::String(s) => s,
                _ => key_result.to_string(),
            };

            self.skip_whitespace();

            // Expect colon
            if self.current_char() != ":" {
                return Result::Err(String::from("Expected ':' after key"));
            }
            self.advance();

            self.skip_whitespace();

            // Parse value
            let value = self.parse_value()?;
            mapping.insert(key, value);

            self.skip_whitespace();

            // Check for comma or closing brace
            let next = self.current_char();
            if next == "," {
                self.advance();
            } else if next == "}" {
                self.advance();
                break;
            } else if !next.is_empty() {
                return Result::Err(String::from("Expected ',' or '}' in mapping"));
            }
        }

        return Result::Ok(YamlValue::Mapping(mapping));
    }

    fn parse_block_sequence(self: &mut YamlParser) -> Result<YamlValue, String> {
        let mut sequence = Vec::new();
        let base_indent = self.column;

        loop {
            // Check if we're still at the same indent level with a dash
            if self.current_char() != "-" {
                break;
            }

            // Skip dash
            self.advance();
            self.skip_whitespace();

            // Parse value
            let value = self.parse_value()?;
            sequence.push(value);

            // Skip to next line
            if self.current_char() == "\n" {
                self.advance();
            }

            // Check indent of next line
            self.skip_whitespace();
            if self.column < base_indent {
                break;
            }
        }

        return Result::Ok(YamlValue::Sequence(sequence));
    }
}

// Parse YAML string to YamlValue
fn parse(yaml: String) -> Result<YamlValue, String> {
    let mut parser = YamlParser::new(yaml);
    return parser.parse_value();
}

// Serialize YamlValue to YAML string
fn stringify(value: YamlValue) -> String {
    return stringify_with_indent(&value, 0);
}

fn stringify_with_indent(value: &YamlValue, indent: i64) -> String {
    let indent_str = " ".repeat(indent as usize * 2);

    match value {
        YamlValue::Null => String::from("null"),
        YamlValue::Bool(b) => if *b { String::from("true") } else { String::from("false") },
        YamlValue::Number(n) => n.to_string(),
        YamlValue::String(s) => {
            // Quote strings that need it
            if s.contains(":") || s.contains("#") || s.contains("\"") {
                return format!("\"{}\"", s.replace("\"", "\\\""));
            }
            return s.clone();
        }
        YamlValue::Sequence(seq) => {
            if seq.is_empty() {
                return String::from("[]");
            }

            let mut result = String::new();
            for item in seq {
                result.push_str("\n");
                result.push_str(&indent_str);
                result.push_str("- ");
                result.push_str(&stringify_with_indent(item, indent + 1));
            }
            return result;
        }
        YamlValue::Mapping(map) => {
            if map.is_empty() {
                return String::from("{}");
            }

            let mut result = String::new();
            let keys = map.keys();
            for key in keys {
                result.push_str("\n");
                result.push_str(&indent_str);
                result.push_str(key);
                result.push_str(": ");
                let value_str = stringify_with_indent(&map.get(key).unwrap(), indent + 1);
                result.push_str(&value_str);
            }
            return result;
        }
    }
}

// Create YAML values

fn yaml_null() -> YamlValue {
    return YamlValue::Null;
}

fn yaml_bool(value: bool) -> YamlValue {
    return YamlValue::Bool(value);
}

fn yaml_number(value: f64) -> YamlValue {
    return YamlValue::Number(value);
}

fn yaml_string(value: String) -> YamlValue {
    return YamlValue::String(value);
}

fn yaml_sequence() -> YamlValue {
    return YamlValue::Sequence(Vec::new());
}

fn yaml_mapping() -> YamlValue {
    return YamlValue::Mapping(HashMap::new());
}


// Test Crypto Module Implementation

// Test SHA-256 hashing
fn test_sha256() {
    let data = "Hello, World!";
    let hash = crypto::sha256(data);

    assert_true(hash.to_hex().len() > 0, "SHA-256 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA256, "Algorithm should be SHA256");
}

// Test SHA-1 hashing
fn test_sha1() {
    let data = "Hello, World!";
    let hash = crypto::sha1(data);

    assert_true(hash.to_hex().len() > 0, "SHA-1 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA1, "Algorithm should be SHA1");
}

// Test MD5 hashing
fn test_md5() {
    let data = "Hello, World!";
    let hash = crypto::md5(data);

    assert_true(hash.to_hex().len() > 0, "MD5 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::MD5, "Algorithm should be MD5");
}

// Test HMAC
fn test_hmac() {
    let key = "secret-key";
    let data = "message";
    let hmac = crypto::hmac_sha256(key, data);

    assert_true(hmac.to_hex().len() > 0, "HMAC should not be empty");
}

// Test hash comparison
fn test_hash_equality() {
    let data = "test data";
    let hash1 = crypto::sha256(data);
    let hash2 = crypto::sha256(data);

    assert_true(hash1.eq(&hash2), "Same input should produce same hash");
}

// Test random bytes generation
fn test_random_bytes() {
    let bytes1 = crypto::random_bytes(16);
    let bytes2 = crypto::random_bytes(16);

    assert_eq(bytes1.len(), 16, "Should generate 16 bytes");
    assert_eq(bytes2.len(), 16, "Should generate 16 bytes");

    // Random bytes should be different
    let mut different = false;
    for i in 0..16 {
        if bytes1[i] != bytes2[i] {
            different = true;
            break;
        }
    }
    assert_true(different, "Random bytes should be different");
}

// Test random integer generation
fn test_random_int() {
    let num1 = crypto::random_int(0, 100);
    let num2 = crypto::random_int(0, 100);

    assert_true(num1 >= 0 && num1 < 100, "Random int should be in range [0, 100)");
    assert_true(num2 >= 0 && num2 < 100, "Random int should be in range [0, 100)");
}

// Test random float generation
fn test_random_float() {
    let num1 = crypto::random_float();
    let num2 = crypto::random_float();

    assert_true(num1 >= 0.0 && num1 < 1.0, "Random float should be in range [0, 1)");
    assert_true(num2 >= 0.0 && num2 < 1.0, "Random float should be in range [0, 1)");
}

// Test random string generation
fn test_random_string() {
    let charset = "abc123";
    let str1 = crypto::random_string(10, charset);
    let str2 = crypto::random_string(10, charset);

    assert_eq(str1.len(), 10, "Random string should have specified length");
    assert_eq(str2.len(), 10, "Random string should have specified length");

    // All characters should be from charset
    for i in 0..str1.len() {
        let ch = str1.substring(i, i + 1);
        assert_true(charset.contains(ch), "Character should be from charset");
    }
}

// Test random alphanumeric string
fn test_random_alphanumeric() {
    let str = crypto::random_alphanumeric(20);

    assert_eq(str.len(), 20, "Should generate string of specified length");

    // Check if alphanumeric
    for i in 0..str.len() {
        let ch = str.substring(i, i + 1);
        let is_alpha = (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z");
        let is_digit = ch >= "0" && ch <= "9";
        assert_true(is_alpha || is_digit, "Should be alphanumeric");
    }
}

// Test random hex string
fn test_random_hex() {
    let hex = crypto::random_hex(32);

    assert_eq(hex.len(), 32, "Should generate hex string of specified length");

    // Check if hex characters
    for i in 0..hex.len() {
        let ch = hex.substring(i, i + 1);
        let is_hex = (ch >= "0" && ch <= "9") || (ch >= "a" && ch <= "f");
        assert_true(is_hex, "Should be hex character");
    }
}

// Test UUID v4 generation
fn test_uuid_v4() {
    let uuid1 = crypto::uuid_v4();
    let uuid2 = crypto::uuid_v4();

    // UUID format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    assert_eq(uuid1.len(), 36, "UUID should be 36 characters");
    assert_eq(uuid2.len(), 36, "UUID should be 36 characters");

    // Check hyphens at correct positions
    assert_eq(uuid1.substring(8, 9), "-", "Should have hyphen at position 8");
    assert_eq(uuid1.substring(13, 14), "-", "Should have hyphen at position 13");
    assert_eq(uuid1.substring(18, 19), "-", "Should have hyphen at position 18");
    assert_eq(uuid1.substring(23, 24), "-", "Should have hyphen at position 23");

    // Check version bit (4)
    assert_eq(uuid1.substring(14, 15), "4", "Should have version 4");

    // UUIDs should be different
    assert_ne(uuid1, uuid2, "UUIDs should be unique");
}

// Test base64 encoding
fn test_base64_encode() {
    let data = "Hello, World!";
    let encoded = crypto::base64_encode(data);

    assert_true(encoded.len() > 0, "Encoded string should not be empty");

    // Base64 encoded "Hello, World!" should be known value
    // SGVsbG8sIFdvcmxkIQ==
}

// Test base64 decoding
fn test_base64_decode() {
    let encoded = "SGVsbG8sIFdvcmxkIQ==";
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, "Hello, World!", "Should decode correctly");
        },
        Err(e) => {
            assert(false, "Failed to decode base64");
        },
    }
}

// Test base64 round-trip
fn test_base64_roundtrip() {
    let original = "The quick brown fox jumps over the lazy dog";
    let encoded = crypto::base64_encode(original);
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, original, "Round-trip should preserve data");
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test hex encoding
fn test_hex_encode() {
    let bytes = [72, 101, 108, 108, 111];  // "Hello" in ASCII
    let hex = crypto::hex_encode(&bytes);

    assert_eq(hex, "48656c6c6f", "Should encode to correct hex");
}

// Test hex decoding
fn test_hex_decode() {
    let hex = "48656c6c6f";
    let bytes_result = crypto::hex_decode(hex);

    match bytes_result {
        Ok(bytes) => {
            assert_eq(bytes.len(), 5, "Should decode to 5 bytes");
            assert_eq(bytes[0], 72, "First byte should be 72");
            assert_eq(bytes[1], 101, "Second byte should be 101");
        },
        Err(e) => {
            assert(false, "Failed to decode hex");
        },
    }
}

// Test hex round-trip
fn test_hex_roundtrip() {
    let original = [1, 2, 3, 4, 5, 255, 128, 64, 32, 16];
    let hex = crypto::hex_encode(&original);
    let decoded_result = crypto::hex_decode(hex);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded.len(), original.len(), "Should decode to same length");
            for i in 0..original.len() {
                assert_eq(decoded[i], original[i], "Bytes should match");
            }
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test password hashing
fn test_password_hashing() {
    let password = "my-secure-password";
    let hash = crypto::hash_password_auto(password);

    assert_eq(hash.algorithm, "PBKDF2-SHA256", "Algorithm should be PBKDF2-SHA256");
    assert_true(hash.iterations >= 100000, "Should use at least 100000 iterations");
    assert_true(hash.salt.len() > 0, "Should have salt");
    assert_true(hash.hash.len() > 0, "Should have hash");
}

// Test password verification
fn test_password_verification() {
    let password = "correct-password";
    let wrong_password = "wrong-password";

    let hash = crypto::hash_password_auto(password);

    // Correct password should verify
    assert_true(hash.verify(password), "Correct password should verify");

    // Wrong password should not verify
    assert_false(hash.verify(wrong_password), "Wrong password should not verify");
}

// Test password hash serialization
fn test_password_hash_serialization() {
    let password = "test-password";
    let hash = crypto::hash_password_auto(password);

    // Serialize to string
    let serialized = hash.to_string();
    assert_true(serialized.len() > 0, "Serialized string should not be empty");
    assert_true(serialized.starts_with("$"), "Should start with $");

    // Deserialize from string
    let parsed_result = PasswordHash::from_string(serialized);
    match parsed_result {
        Ok(parsed) => {
            assert_eq(parsed.algorithm, hash.algorithm, "Algorithm should match");
            assert_eq(parsed.iterations, hash.iterations, "Iterations should match");
            assert_eq(parsed.salt, hash.salt, "Salt should match");
            assert_eq(parsed.hash, hash.hash, "Hash should match");
        },
        Err(e) => {
            assert(false, "Failed to parse password hash");
        },
    }
}

// Test salt generation
fn test_salt_generation() {
    let salt1 = crypto::generate_salt(32);
    let salt2 = crypto::generate_salt(32);

    assert_eq(salt1.len(), 32, "Salt should have specified length");
    assert_eq(salt2.len(), 32, "Salt should have specified length");
    assert_ne(salt1, salt2, "Salts should be different");
}


// Test Crypto Module Implementation

// Test SHA-256 hashing
fn test_sha256() {
    let data = "Hello, World!";
    let hash = crypto::sha256(data);

    assert_true(hash.to_hex().len() > 0, "SHA-256 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA256, "Algorithm should be SHA256");
}

// Test SHA-1 hashing
fn test_sha1() {
    let data = "Hello, World!";
    let hash = crypto::sha1(data);

    assert_true(hash.to_hex().len() > 0, "SHA-1 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA1, "Algorithm should be SHA1");
}

// Test MD5 hashing
fn test_md5() {
    let data = "Hello, World!";
    let hash = crypto::md5(data);

    assert_true(hash.to_hex().len() > 0, "MD5 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::MD5, "Algorithm should be MD5");
}

// Test HMAC
fn test_hmac() {
    let key = "secret-key";
    let data = "message";
    let hmac = crypto::hmac_sha256(key, data);

    assert_true(hmac.to_hex().len() > 0, "HMAC should not be empty");
}

// Test hash comparison
fn test_hash_equality() {
    let data = "test data";
    let hash1 = crypto::sha256(data);
    let hash2 = crypto::sha256(data);

    assert_true(hash1.eq(&hash2), "Same input should produce same hash");
}

// Test random bytes generation
fn test_random_bytes() {
    let bytes1 = crypto::random_bytes(16);
    let bytes2 = crypto::random_bytes(16);

    assert_eq(bytes1.len(), 16, "Should generate 16 bytes");
    assert_eq(bytes2.len(), 16, "Should generate 16 bytes");

    // Random bytes should be different
    let mut different = false;
    for i in 0..16 {
        if bytes1[i] != bytes2[i] {
            different = true;
            break;
        }
    }
    assert_true(different, "Random bytes should be different");
}

// Test random integer generation
fn test_random_int() {
    let num1 = crypto::random_int(0, 100);
    let num2 = crypto::random_int(0, 100);

    assert_true(num1 >= 0 && num1 < 100, "Random int should be in range [0, 100)");
    assert_true(num2 >= 0 && num2 < 100, "Random int should be in range [0, 100)");
}

// Test random float generation
fn test_random_float() {
    let num1 = crypto::random_float();
    let num2 = crypto::random_float();

    assert_true(num1 >= 0.0 && num1 < 1.0, "Random float should be in range [0, 1)");
    assert_true(num2 >= 0.0 && num2 < 1.0, "Random float should be in range [0, 1)");
}

// Test random string generation
fn test_random_string() {
    let charset = "abc123";
    let str1 = crypto::random_string(10, charset);
    let str2 = crypto::random_string(10, charset);

    assert_eq(str1.len(), 10, "Random string should have specified length");
    assert_eq(str2.len(), 10, "Random string should have specified length");

    // All characters should be from charset
    for i in 0..str1.len() {
        let ch = str1.substring(i, i + 1);
        assert_true(charset.contains(ch), "Character should be from charset");
    }
}

// Test random alphanumeric string
fn test_random_alphanumeric() {
    let str = crypto::random_alphanumeric(20);

    assert_eq(str.len(), 20, "Should generate string of specified length");

    // Check if alphanumeric
    for i in 0..str.len() {
        let ch = str.substring(i, i + 1);
        let is_alpha = (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z");
        let is_digit = ch >= "0" && ch <= "9";
        assert_true(is_alpha || is_digit, "Should be alphanumeric");
    }
}

// Test random hex string
fn test_random_hex() {
    let hex = crypto::random_hex(32);

    assert_eq(hex.len(), 32, "Should generate hex string of specified length");

    // Check if hex characters
    for i in 0..hex.len() {
        let ch = hex.substring(i, i + 1);
        let is_hex = (ch >= "0" && ch <= "9") || (ch >= "a" && ch <= "f");
        assert_true(is_hex, "Should be hex character");
    }
}

// Test UUID v4 generation
fn test_uuid_v4() {
    let uuid1 = crypto::uuid_v4();
    let uuid2 = crypto::uuid_v4();

    // UUID format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    assert_eq(uuid1.len(), 36, "UUID should be 36 characters");
    assert_eq(uuid2.len(), 36, "UUID should be 36 characters");

    // Check hyphens at correct positions
    assert_eq(uuid1.substring(8, 9), "-", "Should have hyphen at position 8");
    assert_eq(uuid1.substring(13, 14), "-", "Should have hyphen at position 13");
    assert_eq(uuid1.substring(18, 19), "-", "Should have hyphen at position 18");
    assert_eq(uuid1.substring(23, 24), "-", "Should have hyphen at position 23");

    // Check version bit (4)
    assert_eq(uuid1.substring(14, 15), "4", "Should have version 4");

    // UUIDs should be different
    assert_ne(uuid1, uuid2, "UUIDs should be unique");
}

// Test base64 encoding
fn test_base64_encode() {
    let data = "Hello, World!";
    let encoded = crypto::base64_encode(data);

    assert_true(encoded.len() > 0, "Encoded string should not be empty");

    // Base64 encoded "Hello, World!" should be known value
    // SGVsbG8sIFdvcmxkIQ==
}

// Test base64 decoding
fn test_base64_decode() {
    let encoded = "SGVsbG8sIFdvcmxkIQ==";
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, "Hello, World!", "Should decode correctly");
        },
        Err(e) => {
            assert(false, "Failed to decode base64");
        },
    }
}

// Test base64 round-trip
fn test_base64_roundtrip() {
    let original = "The quick brown fox jumps over the lazy dog";
    let encoded = crypto::base64_encode(original);
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, original, "Round-trip should preserve data");
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test hex encoding
fn test_hex_encode() {
    let bytes = [72, 101, 108, 108, 111];  // "Hello" in ASCII
    let hex = crypto::hex_encode(&bytes);

    assert_eq(hex, "48656c6c6f", "Should encode to correct hex");
}

// Test hex decoding
fn test_hex_decode() {
    let hex = "48656c6c6f";
    let bytes_result = crypto::hex_decode(hex);

    match bytes_result {
        Ok(bytes) => {
            assert_eq(bytes.len(), 5, "Should decode to 5 bytes");
            assert_eq(bytes[0], 72, "First byte should be 72");
            assert_eq(bytes[1], 101, "Second byte should be 101");
        },
        Err(e) => {
            assert(false, "Failed to decode hex");
        },
    }
}

// Test hex round-trip
fn test_hex_roundtrip() {
    let original = [1, 2, 3, 4, 5, 255, 128, 64, 32, 16];
    let hex = crypto::hex_encode(&original);
    let decoded_result = crypto::hex_decode(hex);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded.len(), original.len(), "Should decode to same length");
            for i in 0..original.len() {
                assert_eq(decoded[i], original[i], "Bytes should match");
            }
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test password hashing
fn test_password_hashing() {
    let password = "my-secure-password";
    let hash = crypto::hash_password_auto(password);

    assert_eq(hash.algorithm, "PBKDF2-SHA256", "Algorithm should be PBKDF2-SHA256");
    assert_true(hash.iterations >= 100000, "Should use at least 100000 iterations");
    assert_true(hash.salt.len() > 0, "Should have salt");
    assert_true(hash.hash.len() > 0, "Should have hash");
}

// Test password verification
fn test_password_verification() {
    let password = "correct-password";
    let wrong_password = "wrong-password";

    let hash = crypto::hash_password_auto(password);

    // Correct password should verify
    assert_true(hash.verify(password), "Correct password should verify");

    // Wrong password should not verify
    assert_false(hash.verify(wrong_password), "Wrong password should not verify");
}

// Test password hash serialization
fn test_password_hash_serialization() {
    let password = "test-password";
    let hash = crypto::hash_password_auto(password);

    // Serialize to string
    let serialized = hash.to_string();
    assert_true(serialized.len() > 0, "Serialized string should not be empty");
    assert_true(serialized.starts_with("$"), "Should start with $");

    // Deserialize from string
    let parsed_result = PasswordHash::from_string(serialized);
    match parsed_result {
        Ok(parsed) => {
            assert_eq(parsed.algorithm, hash.algorithm, "Algorithm should match");
            assert_eq(parsed.iterations, hash.iterations, "Iterations should match");
            assert_eq(parsed.salt, hash.salt, "Salt should match");
            assert_eq(parsed.hash, hash.hash, "Hash should match");
        },
        Err(e) => {
            assert(false, "Failed to parse password hash");
        },
    }
}

// Test salt generation
fn test_salt_generation() {
    let salt1 = crypto::generate_salt(32);
    let salt2 = crypto::generate_salt(32);

    assert_eq(salt1.len(), 32, "Salt should have specified length");
    assert_eq(salt2.len(), 32, "Salt should have specified length");
    assert_ne(salt1, salt2, "Salts should be different");
}


// Test Crypto Module Implementation

// Test SHA-256 hashing
fn test_sha256() {
    let data = "Hello, World!";
    let hash = crypto::sha256(data);

    assert_true(hash.to_hex().len() > 0, "SHA-256 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA256, "Algorithm should be SHA256");
}

// Test SHA-1 hashing
fn test_sha1() {
    let data = "Hello, World!";
    let hash = crypto::sha1(data);

    assert_true(hash.to_hex().len() > 0, "SHA-1 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA1, "Algorithm should be SHA1");
}

// Test MD5 hashing
fn test_md5() {
    let data = "Hello, World!";
    let hash = crypto::md5(data);

    assert_true(hash.to_hex().len() > 0, "MD5 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::MD5, "Algorithm should be MD5");
}

// Test HMAC
fn test_hmac() {
    let key = "secret-key";
    let data = "message";
    let hmac = crypto::hmac_sha256(key, data);

    assert_true(hmac.to_hex().len() > 0, "HMAC should not be empty");
}

// Test hash comparison
fn test_hash_equality() {
    let data = "test data";
    let hash1 = crypto::sha256(data);
    let hash2 = crypto::sha256(data);

    assert_true(hash1.eq(&hash2), "Same input should produce same hash");
}

// Test random bytes generation
fn test_random_bytes() {
    let bytes1 = crypto::random_bytes(16);
    let bytes2 = crypto::random_bytes(16);

    assert_eq(bytes1.len(), 16, "Should generate 16 bytes");
    assert_eq(bytes2.len(), 16, "Should generate 16 bytes");

    // Random bytes should be different
    let mut different = false;
    for i in 0..16 {
        if bytes1[i] != bytes2[i] {
            different = true;
            break;
        }
    }
    assert_true(different, "Random bytes should be different");
}

// Test random integer generation
fn test_random_int() {
    let num1 = crypto::random_int(0, 100);
    let num2 = crypto::random_int(0, 100);

    assert_true(num1 >= 0 && num1 < 100, "Random int should be in range [0, 100)");
    assert_true(num2 >= 0 && num2 < 100, "Random int should be in range [0, 100)");
}

// Test random float generation
fn test_random_float() {
    let num1 = crypto::random_float();
    let num2 = crypto::random_float();

    assert_true(num1 >= 0.0 && num1 < 1.0, "Random float should be in range [0, 1)");
    assert_true(num2 >= 0.0 && num2 < 1.0, "Random float should be in range [0, 1)");
}

// Test random string generation
fn test_random_string() {
    let charset = "abc123";
    let str1 = crypto::random_string(10, charset);
    let str2 = crypto::random_string(10, charset);

    assert_eq(str1.len(), 10, "Random string should have specified length");
    assert_eq(str2.len(), 10, "Random string should have specified length");

    // All characters should be from charset
    for i in 0..str1.len() {
        let ch = str1.substring(i, i + 1);
        assert_true(charset.contains(ch), "Character should be from charset");
    }
}

// Test random alphanumeric string
fn test_random_alphanumeric() {
    let str = crypto::random_alphanumeric(20);

    assert_eq(str.len(), 20, "Should generate string of specified length");

    // Check if alphanumeric
    for i in 0..str.len() {
        let ch = str.substring(i, i + 1);
        let is_alpha = (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z");
        let is_digit = ch >= "0" && ch <= "9";
        assert_true(is_alpha || is_digit, "Should be alphanumeric");
    }
}

// Test random hex string
fn test_random_hex() {
    let hex = crypto::random_hex(32);

    assert_eq(hex.len(), 32, "Should generate hex string of specified length");

    // Check if hex characters
    for i in 0..hex.len() {
        let ch = hex.substring(i, i + 1);
        let is_hex = (ch >= "0" && ch <= "9") || (ch >= "a" && ch <= "f");
        assert_true(is_hex, "Should be hex character");
    }
}

// Test UUID v4 generation
fn test_uuid_v4() {
    let uuid1 = crypto::uuid_v4();
    let uuid2 = crypto::uuid_v4();

    // UUID format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    assert_eq(uuid1.len(), 36, "UUID should be 36 characters");
    assert_eq(uuid2.len(), 36, "UUID should be 36 characters");

    // Check hyphens at correct positions
    assert_eq(uuid1.substring(8, 9), "-", "Should have hyphen at position 8");
    assert_eq(uuid1.substring(13, 14), "-", "Should have hyphen at position 13");
    assert_eq(uuid1.substring(18, 19), "-", "Should have hyphen at position 18");
    assert_eq(uuid1.substring(23, 24), "-", "Should have hyphen at position 23");

    // Check version bit (4)
    assert_eq(uuid1.substring(14, 15), "4", "Should have version 4");

    // UUIDs should be different
    assert_ne(uuid1, uuid2, "UUIDs should be unique");
}

// Test base64 encoding
fn test_base64_encode() {
    let data = "Hello, World!";
    let encoded = crypto::base64_encode(data);

    assert_true(encoded.len() > 0, "Encoded string should not be empty");

    // Base64 encoded "Hello, World!" should be known value
    // SGVsbG8sIFdvcmxkIQ==
}

// Test base64 decoding
fn test_base64_decode() {
    let encoded = "SGVsbG8sIFdvcmxkIQ==";
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, "Hello, World!", "Should decode correctly");
        },
        Err(e) => {
            assert(false, "Failed to decode base64");
        },
    }
}

// Test base64 round-trip
fn test_base64_roundtrip() {
    let original = "The quick brown fox jumps over the lazy dog";
    let encoded = crypto::base64_encode(original);
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, original, "Round-trip should preserve data");
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test hex encoding
fn test_hex_encode() {
    let bytes = [72, 101, 108, 108, 111];  // "Hello" in ASCII
    let hex = crypto::hex_encode(&bytes);

    assert_eq(hex, "48656c6c6f", "Should encode to correct hex");
}

// Test hex decoding
fn test_hex_decode() {
    let hex = "48656c6c6f";
    let bytes_result = crypto::hex_decode(hex);

    match bytes_result {
        Ok(bytes) => {
            assert_eq(bytes.len(), 5, "Should decode to 5 bytes");
            assert_eq(bytes[0], 72, "First byte should be 72");
            assert_eq(bytes[1], 101, "Second byte should be 101");
        },
        Err(e) => {
            assert(false, "Failed to decode hex");
        },
    }
}

// Test hex round-trip
fn test_hex_roundtrip() {
    let original = [1, 2, 3, 4, 5, 255, 128, 64, 32, 16];
    let hex = crypto::hex_encode(&original);
    let decoded_result = crypto::hex_decode(hex);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded.len(), original.len(), "Should decode to same length");
            for i in 0..original.len() {
                assert_eq(decoded[i], original[i], "Bytes should match");
            }
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test password hashing
fn test_password_hashing() {
    let password = "my-secure-password";
    let hash = crypto::hash_password_auto(password);

    assert_eq(hash.algorithm, "PBKDF2-SHA256", "Algorithm should be PBKDF2-SHA256");
    assert_true(hash.iterations >= 100000, "Should use at least 100000 iterations");
    assert_true(hash.salt.len() > 0, "Should have salt");
    assert_true(hash.hash.len() > 0, "Should have hash");
}

// Test password verification
fn test_password_verification() {
    let password = "correct-password";
    let wrong_password = "wrong-password";

    let hash = crypto::hash_password_auto(password);

    // Correct password should verify
    assert_true(hash.verify(password), "Correct password should verify");

    // Wrong password should not verify
    assert_false(hash.verify(wrong_password), "Wrong password should not verify");
}

// Test password hash serialization
fn test_password_hash_serialization() {
    let password = "test-password";
    let hash = crypto::hash_password_auto(password);

    // Serialize to string
    let serialized = hash.to_string();
    assert_true(serialized.len() > 0, "Serialized string should not be empty");
    assert_true(serialized.starts_with("$"), "Should start with $");

    // Deserialize from string
    let parsed_result = PasswordHash::from_string(serialized);
    match parsed_result {
        Ok(parsed) => {
            assert_eq(parsed.algorithm, hash.algorithm, "Algorithm should match");
            assert_eq(parsed.iterations, hash.iterations, "Iterations should match");
            assert_eq(parsed.salt, hash.salt, "Salt should match");
            assert_eq(parsed.hash, hash.hash, "Hash should match");
        },
        Err(e) => {
            assert(false, "Failed to parse password hash");
        },
    }
}

// Test salt generation
fn test_salt_generation() {
    let salt1 = crypto::generate_salt(32);
    let salt2 = crypto::generate_salt(32);

    assert_eq(salt1.len(), 32, "Salt should have specified length");
    assert_eq(salt2.len(), 32, "Salt should have specified length");
    assert_ne(salt1, salt2, "Salts should be different");
}


// Test Crypto Module Implementation

// Test SHA-256 hashing
fn test_sha256() {
    let data = "Hello, World!";
    let hash = crypto::sha256(data);

    assert_true(hash.to_hex().len() > 0, "SHA-256 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA256, "Algorithm should be SHA256");
}

// Test SHA-1 hashing
fn test_sha1() {
    let data = "Hello, World!";
    let hash = crypto::sha1(data);

    assert_true(hash.to_hex().len() > 0, "SHA-1 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA1, "Algorithm should be SHA1");
}

// Test MD5 hashing
fn test_md5() {
    let data = "Hello, World!";
    let hash = crypto::md5(data);

    assert_true(hash.to_hex().len() > 0, "MD5 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::MD5, "Algorithm should be MD5");
}

// Test HMAC
fn test_hmac() {
    let key = "secret-key";
    let data = "message";
    let hmac = crypto::hmac_sha256(key, data);

    assert_true(hmac.to_hex().len() > 0, "HMAC should not be empty");
}

// Test hash comparison
fn test_hash_equality() {
    let data = "test data";
    let hash1 = crypto::sha256(data);
    let hash2 = crypto::sha256(data);

    assert_true(hash1.eq(&hash2), "Same input should produce same hash");
}

// Test random bytes generation
fn test_random_bytes() {
    let bytes1 = crypto::random_bytes(16);
    let bytes2 = crypto::random_bytes(16);

    assert_eq(bytes1.len(), 16, "Should generate 16 bytes");
    assert_eq(bytes2.len(), 16, "Should generate 16 bytes");

    // Random bytes should be different
    let mut different = false;
    for i in 0..16 {
        if bytes1[i] != bytes2[i] {
            different = true;
            break;
        }
    }
    assert_true(different, "Random bytes should be different");
}

// Test random integer generation
fn test_random_int() {
    let num1 = crypto::random_int(0, 100);
    let num2 = crypto::random_int(0, 100);

    assert_true(num1 >= 0 && num1 < 100, "Random int should be in range [0, 100)");
    assert_true(num2 >= 0 && num2 < 100, "Random int should be in range [0, 100)");
}

// Test random float generation
fn test_random_float() {
    let num1 = crypto::random_float();
    let num2 = crypto::random_float();

    assert_true(num1 >= 0.0 && num1 < 1.0, "Random float should be in range [0, 1)");
    assert_true(num2 >= 0.0 && num2 < 1.0, "Random float should be in range [0, 1)");
}

// Test random string generation
fn test_random_string() {
    let charset = "abc123";
    let str1 = crypto::random_string(10, charset);
    let str2 = crypto::random_string(10, charset);

    assert_eq(str1.len(), 10, "Random string should have specified length");
    assert_eq(str2.len(), 10, "Random string should have specified length");

    // All characters should be from charset
    for i in 0..str1.len() {
        let ch = str1.substring(i, i + 1);
        assert_true(charset.contains(ch), "Character should be from charset");
    }
}

// Test random alphanumeric string
fn test_random_alphanumeric() {
    let str = crypto::random_alphanumeric(20);

    assert_eq(str.len(), 20, "Should generate string of specified length");

    // Check if alphanumeric
    for i in 0..str.len() {
        let ch = str.substring(i, i + 1);
        let is_alpha = (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z");
        let is_digit = ch >= "0" && ch <= "9";
        assert_true(is_alpha || is_digit, "Should be alphanumeric");
    }
}

// Test random hex string
fn test_random_hex() {
    let hex = crypto::random_hex(32);

    assert_eq(hex.len(), 32, "Should generate hex string of specified length");

    // Check if hex characters
    for i in 0..hex.len() {
        let ch = hex.substring(i, i + 1);
        let is_hex = (ch >= "0" && ch <= "9") || (ch >= "a" && ch <= "f");
        assert_true(is_hex, "Should be hex character");
    }
}

// Test UUID v4 generation
fn test_uuid_v4() {
    let uuid1 = crypto::uuid_v4();
    let uuid2 = crypto::uuid_v4();

    // UUID format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    assert_eq(uuid1.len(), 36, "UUID should be 36 characters");
    assert_eq(uuid2.len(), 36, "UUID should be 36 characters");

    // Check hyphens at correct positions
    assert_eq(uuid1.substring(8, 9), "-", "Should have hyphen at position 8");
    assert_eq(uuid1.substring(13, 14), "-", "Should have hyphen at position 13");
    assert_eq(uuid1.substring(18, 19), "-", "Should have hyphen at position 18");
    assert_eq(uuid1.substring(23, 24), "-", "Should have hyphen at position 23");

    // Check version bit (4)
    assert_eq(uuid1.substring(14, 15), "4", "Should have version 4");

    // UUIDs should be different
    assert_ne(uuid1, uuid2, "UUIDs should be unique");
}

// Test base64 encoding
fn test_base64_encode() {
    let data = "Hello, World!";
    let encoded = crypto::base64_encode(data);

    assert_true(encoded.len() > 0, "Encoded string should not be empty");

    // Base64 encoded "Hello, World!" should be known value
    // SGVsbG8sIFdvcmxkIQ==
}

// Test base64 decoding
fn test_base64_decode() {
    let encoded = "SGVsbG8sIFdvcmxkIQ==";
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, "Hello, World!", "Should decode correctly");
        },
        Err(e) => {
            assert(false, "Failed to decode base64");
        },
    }
}

// Test base64 round-trip
fn test_base64_roundtrip() {
    let original = "The quick brown fox jumps over the lazy dog";
    let encoded = crypto::base64_encode(original);
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, original, "Round-trip should preserve data");
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test hex encoding
fn test_hex_encode() {
    let bytes = [72, 101, 108, 108, 111];  // "Hello" in ASCII
    let hex = crypto::hex_encode(&bytes);

    assert_eq(hex, "48656c6c6f", "Should encode to correct hex");
}

// Test hex decoding
fn test_hex_decode() {
    let hex = "48656c6c6f";
    let bytes_result = crypto::hex_decode(hex);

    match bytes_result {
        Ok(bytes) => {
            assert_eq(bytes.len(), 5, "Should decode to 5 bytes");
            assert_eq(bytes[0], 72, "First byte should be 72");
            assert_eq(bytes[1], 101, "Second byte should be 101");
        },
        Err(e) => {
            assert(false, "Failed to decode hex");
        },
    }
}

// Test hex round-trip
fn test_hex_roundtrip() {
    let original = [1, 2, 3, 4, 5, 255, 128, 64, 32, 16];
    let hex = crypto::hex_encode(&original);
    let decoded_result = crypto::hex_decode(hex);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded.len(), original.len(), "Should decode to same length");
            for i in 0..original.len() {
                assert_eq(decoded[i], original[i], "Bytes should match");
            }
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test password hashing
fn test_password_hashing() {
    let password = "my-secure-password";
    let hash = crypto::hash_password_auto(password);

    assert_eq(hash.algorithm, "PBKDF2-SHA256", "Algorithm should be PBKDF2-SHA256");
    assert_true(hash.iterations >= 100000, "Should use at least 100000 iterations");
    assert_true(hash.salt.len() > 0, "Should have salt");
    assert_true(hash.hash.len() > 0, "Should have hash");
}

// Test password verification
fn test_password_verification() {
    let password = "correct-password";
    let wrong_password = "wrong-password";

    let hash = crypto::hash_password_auto(password);

    // Correct password should verify
    assert_true(hash.verify(password), "Correct password should verify");

    // Wrong password should not verify
    assert_false(hash.verify(wrong_password), "Wrong password should not verify");
}

// Test password hash serialization
fn test_password_hash_serialization() {
    let password = "test-password";
    let hash = crypto::hash_password_auto(password);

    // Serialize to string
    let serialized = hash.to_string();
    assert_true(serialized.len() > 0, "Serialized string should not be empty");
    assert_true(serialized.starts_with("$"), "Should start with $");

    // Deserialize from string
    let parsed_result = PasswordHash::from_string(serialized);
    match parsed_result {
        Ok(parsed) => {
            assert_eq(parsed.algorithm, hash.algorithm, "Algorithm should match");
            assert_eq(parsed.iterations, hash.iterations, "Iterations should match");
            assert_eq(parsed.salt, hash.salt, "Salt should match");
            assert_eq(parsed.hash, hash.hash, "Hash should match");
        },
        Err(e) => {
            assert(false, "Failed to parse password hash");
        },
    }
}

// Test salt generation
fn test_salt_generation() {
    let salt1 = crypto::generate_salt(32);
    let salt2 = crypto::generate_salt(32);

    assert_eq(salt1.len(), 32, "Salt should have specified length");
    assert_eq(salt2.len(), 32, "Salt should have specified length");
    assert_ne(salt1, salt2, "Salts should be different");
}


// Test Crypto Module Implementation

// Test SHA-256 hashing
fn test_sha256() {
    let data = "Hello, World!";
    let hash = crypto::sha256(data);

    assert_true(hash.to_hex().len() > 0, "SHA-256 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA256, "Algorithm should be SHA256");
}

// Test SHA-1 hashing
fn test_sha1() {
    let data = "Hello, World!";
    let hash = crypto::sha1(data);

    assert_true(hash.to_hex().len() > 0, "SHA-1 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA1, "Algorithm should be SHA1");
}

// Test MD5 hashing
fn test_md5() {
    let data = "Hello, World!";
    let hash = crypto::md5(data);

    assert_true(hash.to_hex().len() > 0, "MD5 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::MD5, "Algorithm should be MD5");
}

// Test HMAC
fn test_hmac() {
    let key = "secret-key";
    let data = "message";
    let hmac = crypto::hmac_sha256(key, data);

    assert_true(hmac.to_hex().len() > 0, "HMAC should not be empty");
}

// Test hash comparison
fn test_hash_equality() {
    let data = "test data";
    let hash1 = crypto::sha256(data);
    let hash2 = crypto::sha256(data);

    assert_true(hash1.eq(&hash2), "Same input should produce same hash");
}

// Test random bytes generation
fn test_random_bytes() {
    let bytes1 = crypto::random_bytes(16);
    let bytes2 = crypto::random_bytes(16);

    assert_eq(bytes1.len(), 16, "Should generate 16 bytes");
    assert_eq(bytes2.len(), 16, "Should generate 16 bytes");

    // Random bytes should be different
    let mut different = false;
    for i in 0..16 {
        if bytes1[i] != bytes2[i] {
            different = true;
            break;
        }
    }
    assert_true(different, "Random bytes should be different");
}

// Test random integer generation
fn test_random_int() {
    let num1 = crypto::random_int(0, 100);
    let num2 = crypto::random_int(0, 100);

    assert_true(num1 >= 0 && num1 < 100, "Random int should be in range [0, 100)");
    assert_true(num2 >= 0 && num2 < 100, "Random int should be in range [0, 100)");
}

// Test random float generation
fn test_random_float() {
    let num1 = crypto::random_float();
    let num2 = crypto::random_float();

    assert_true(num1 >= 0.0 && num1 < 1.0, "Random float should be in range [0, 1)");
    assert_true(num2 >= 0.0 && num2 < 1.0, "Random float should be in range [0, 1)");
}

// Test random string generation
fn test_random_string() {
    let charset = "abc123";
    let str1 = crypto::random_string(10, charset);
    let str2 = crypto::random_string(10, charset);

    assert_eq(str1.len(), 10, "Random string should have specified length");
    assert_eq(str2.len(), 10, "Random string should have specified length");

    // All characters should be from charset
    for i in 0..str1.len() {
        let ch = str1.substring(i, i + 1);
        assert_true(charset.contains(ch), "Character should be from charset");
    }
}

// Test random alphanumeric string
fn test_random_alphanumeric() {
    let str = crypto::random_alphanumeric(20);

    assert_eq(str.len(), 20, "Should generate string of specified length");

    // Check if alphanumeric
    for i in 0..str.len() {
        let ch = str.substring(i, i + 1);
        let is_alpha = (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z");
        let is_digit = ch >= "0" && ch <= "9";
        assert_true(is_alpha || is_digit, "Should be alphanumeric");
    }
}

// Test random hex string
fn test_random_hex() {
    let hex = crypto::random_hex(32);

    assert_eq(hex.len(), 32, "Should generate hex string of specified length");

    // Check if hex characters
    for i in 0..hex.len() {
        let ch = hex.substring(i, i + 1);
        let is_hex = (ch >= "0" && ch <= "9") || (ch >= "a" && ch <= "f");
        assert_true(is_hex, "Should be hex character");
    }
}

// Test UUID v4 generation
fn test_uuid_v4() {
    let uuid1 = crypto::uuid_v4();
    let uuid2 = crypto::uuid_v4();

    // UUID format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    assert_eq(uuid1.len(), 36, "UUID should be 36 characters");
    assert_eq(uuid2.len(), 36, "UUID should be 36 characters");

    // Check hyphens at correct positions
    assert_eq(uuid1.substring(8, 9), "-", "Should have hyphen at position 8");
    assert_eq(uuid1.substring(13, 14), "-", "Should have hyphen at position 13");
    assert_eq(uuid1.substring(18, 19), "-", "Should have hyphen at position 18");
    assert_eq(uuid1.substring(23, 24), "-", "Should have hyphen at position 23");

    // Check version bit (4)
    assert_eq(uuid1.substring(14, 15), "4", "Should have version 4");

    // UUIDs should be different
    assert_ne(uuid1, uuid2, "UUIDs should be unique");
}

// Test base64 encoding
fn test_base64_encode() {
    let data = "Hello, World!";
    let encoded = crypto::base64_encode(data);

    assert_true(encoded.len() > 0, "Encoded string should not be empty");

    // Base64 encoded "Hello, World!" should be known value
    // SGVsbG8sIFdvcmxkIQ==
}

// Test base64 decoding
fn test_base64_decode() {
    let encoded = "SGVsbG8sIFdvcmxkIQ==";
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, "Hello, World!", "Should decode correctly");
        },
        Err(e) => {
            assert(false, "Failed to decode base64");
        },
    }
}

// Test base64 round-trip
fn test_base64_roundtrip() {
    let original = "The quick brown fox jumps over the lazy dog";
    let encoded = crypto::base64_encode(original);
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, original, "Round-trip should preserve data");
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test hex encoding
fn test_hex_encode() {
    let bytes = [72, 101, 108, 108, 111];  // "Hello" in ASCII
    let hex = crypto::hex_encode(&bytes);

    assert_eq(hex, "48656c6c6f", "Should encode to correct hex");
}

// Test hex decoding
fn test_hex_decode() {
    let hex = "48656c6c6f";
    let bytes_result = crypto::hex_decode(hex);

    match bytes_result {
        Ok(bytes) => {
            assert_eq(bytes.len(), 5, "Should decode to 5 bytes");
            assert_eq(bytes[0], 72, "First byte should be 72");
            assert_eq(bytes[1], 101, "Second byte should be 101");
        },
        Err(e) => {
            assert(false, "Failed to decode hex");
        },
    }
}

// Test hex round-trip
fn test_hex_roundtrip() {
    let original = [1, 2, 3, 4, 5, 255, 128, 64, 32, 16];
    let hex = crypto::hex_encode(&original);
    let decoded_result = crypto::hex_decode(hex);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded.len(), original.len(), "Should decode to same length");
            for i in 0..original.len() {
                assert_eq(decoded[i], original[i], "Bytes should match");
            }
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test password hashing
fn test_password_hashing() {
    let password = "my-secure-password";
    let hash = crypto::hash_password_auto(password);

    assert_eq(hash.algorithm, "PBKDF2-SHA256", "Algorithm should be PBKDF2-SHA256");
    assert_true(hash.iterations >= 100000, "Should use at least 100000 iterations");
    assert_true(hash.salt.len() > 0, "Should have salt");
    assert_true(hash.hash.len() > 0, "Should have hash");
}

// Test password verification
fn test_password_verification() {
    let password = "correct-password";
    let wrong_password = "wrong-password";

    let hash = crypto::hash_password_auto(password);

    // Correct password should verify
    assert_true(hash.verify(password), "Correct password should verify");

    // Wrong password should not verify
    assert_false(hash.verify(wrong_password), "Wrong password should not verify");
}

// Test password hash serialization
fn test_password_hash_serialization() {
    let password = "test-password";
    let hash = crypto::hash_password_auto(password);

    // Serialize to string
    let serialized = hash.to_string();
    assert_true(serialized.len() > 0, "Serialized string should not be empty");
    assert_true(serialized.starts_with("$"), "Should start with $");

    // Deserialize from string
    let parsed_result = PasswordHash::from_string(serialized);
    match parsed_result {
        Ok(parsed) => {
            assert_eq(parsed.algorithm, hash.algorithm, "Algorithm should match");
            assert_eq(parsed.iterations, hash.iterations, "Iterations should match");
            assert_eq(parsed.salt, hash.salt, "Salt should match");
            assert_eq(parsed.hash, hash.hash, "Hash should match");
        },
        Err(e) => {
            assert(false, "Failed to parse password hash");
        },
    }
}

// Test salt generation
fn test_salt_generation() {
    let salt1 = crypto::generate_salt(32);
    let salt2 = crypto::generate_salt(32);

    assert_eq(salt1.len(), 32, "Salt should have specified length");
    assert_eq(salt2.len(), 32, "Salt should have specified length");
    assert_ne(salt1, salt2, "Salts should be different");
}


// Test Crypto Module Implementation

// Test SHA-256 hashing
fn test_sha256() {
    let data = "Hello, World!";
    let hash = crypto::sha256(data);

    assert_true(hash.to_hex().len() > 0, "SHA-256 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA256, "Algorithm should be SHA256");
}

// Test SHA-1 hashing
fn test_sha1() {
    let data = "Hello, World!";
    let hash = crypto::sha1(data);

    assert_true(hash.to_hex().len() > 0, "SHA-1 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA1, "Algorithm should be SHA1");
}

// Test MD5 hashing
fn test_md5() {
    let data = "Hello, World!";
    let hash = crypto::md5(data);

    assert_true(hash.to_hex().len() > 0, "MD5 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::MD5, "Algorithm should be MD5");
}

// Test HMAC
fn test_hmac() {
    let key = "secret-key";
    let data = "message";
    let hmac = crypto::hmac_sha256(key, data);

    assert_true(hmac.to_hex().len() > 0, "HMAC should not be empty");
}

// Test hash comparison
fn test_hash_equality() {
    let data = "test data";
    let hash1 = crypto::sha256(data);
    let hash2 = crypto::sha256(data);

    assert_true(hash1.eq(&hash2), "Same input should produce same hash");
}

// Test random bytes generation
fn test_random_bytes() {
    let bytes1 = crypto::random_bytes(16);
    let bytes2 = crypto::random_bytes(16);

    assert_eq(bytes1.len(), 16, "Should generate 16 bytes");
    assert_eq(bytes2.len(), 16, "Should generate 16 bytes");

    // Random bytes should be different
    let mut different = false;
    for i in 0..16 {
        if bytes1[i] != bytes2[i] {
            different = true;
            break;
        }
    }
    assert_true(different, "Random bytes should be different");
}

// Test random integer generation
fn test_random_int() {
    let num1 = crypto::random_int(0, 100);
    let num2 = crypto::random_int(0, 100);

    assert_true(num1 >= 0 && num1 < 100, "Random int should be in range [0, 100)");
    assert_true(num2 >= 0 && num2 < 100, "Random int should be in range [0, 100)");
}

// Test random float generation
fn test_random_float() {
    let num1 = crypto::random_float();
    let num2 = crypto::random_float();

    assert_true(num1 >= 0.0 && num1 < 1.0, "Random float should be in range [0, 1)");
    assert_true(num2 >= 0.0 && num2 < 1.0, "Random float should be in range [0, 1)");
}

// Test random string generation
fn test_random_string() {
    let charset = "abc123";
    let str1 = crypto::random_string(10, charset);
    let str2 = crypto::random_string(10, charset);

    assert_eq(str1.len(), 10, "Random string should have specified length");
    assert_eq(str2.len(), 10, "Random string should have specified length");

    // All characters should be from charset
    for i in 0..str1.len() {
        let ch = str1.substring(i, i + 1);
        assert_true(charset.contains(ch), "Character should be from charset");
    }
}

// Test random alphanumeric string
fn test_random_alphanumeric() {
    let str = crypto::random_alphanumeric(20);

    assert_eq(str.len(), 20, "Should generate string of specified length");

    // Check if alphanumeric
    for i in 0..str.len() {
        let ch = str.substring(i, i + 1);
        let is_alpha = (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z");
        let is_digit = ch >= "0" && ch <= "9";
        assert_true(is_alpha || is_digit, "Should be alphanumeric");
    }
}

// Test random hex string
fn test_random_hex() {
    let hex = crypto::random_hex(32);

    assert_eq(hex.len(), 32, "Should generate hex string of specified length");

    // Check if hex characters
    for i in 0..hex.len() {
        let ch = hex.substring(i, i + 1);
        let is_hex = (ch >= "0" && ch <= "9") || (ch >= "a" && ch <= "f");
        assert_true(is_hex, "Should be hex character");
    }
}

// Test UUID v4 generation
fn test_uuid_v4() {
    let uuid1 = crypto::uuid_v4();
    let uuid2 = crypto::uuid_v4();

    // UUID format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    assert_eq(uuid1.len(), 36, "UUID should be 36 characters");
    assert_eq(uuid2.len(), 36, "UUID should be 36 characters");

    // Check hyphens at correct positions
    assert_eq(uuid1.substring(8, 9), "-", "Should have hyphen at position 8");
    assert_eq(uuid1.substring(13, 14), "-", "Should have hyphen at position 13");
    assert_eq(uuid1.substring(18, 19), "-", "Should have hyphen at position 18");
    assert_eq(uuid1.substring(23, 24), "-", "Should have hyphen at position 23");

    // Check version bit (4)
    assert_eq(uuid1.substring(14, 15), "4", "Should have version 4");

    // UUIDs should be different
    assert_ne(uuid1, uuid2, "UUIDs should be unique");
}

// Test base64 encoding
fn test_base64_encode() {
    let data = "Hello, World!";
    let encoded = crypto::base64_encode(data);

    assert_true(encoded.len() > 0, "Encoded string should not be empty");

    // Base64 encoded "Hello, World!" should be known value
    // SGVsbG8sIFdvcmxkIQ==
}

// Test base64 decoding
fn test_base64_decode() {
    let encoded = "SGVsbG8sIFdvcmxkIQ==";
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, "Hello, World!", "Should decode correctly");
        },
        Err(e) => {
            assert(false, "Failed to decode base64");
        },
    }
}

// Test base64 round-trip
fn test_base64_roundtrip() {
    let original = "The quick brown fox jumps over the lazy dog";
    let encoded = crypto::base64_encode(original);
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, original, "Round-trip should preserve data");
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test hex encoding
fn test_hex_encode() {
    let bytes = [72, 101, 108, 108, 111];  // "Hello" in ASCII
    let hex = crypto::hex_encode(&bytes);

    assert_eq(hex, "48656c6c6f", "Should encode to correct hex");
}

// Test hex decoding
fn test_hex_decode() {
    let hex = "48656c6c6f";
    let bytes_result = crypto::hex_decode(hex);

    match bytes_result {
        Ok(bytes) => {
            assert_eq(bytes.len(), 5, "Should decode to 5 bytes");
            assert_eq(bytes[0], 72, "First byte should be 72");
            assert_eq(bytes[1], 101, "Second byte should be 101");
        },
        Err(e) => {
            assert(false, "Failed to decode hex");
        },
    }
}

// Test hex round-trip
fn test_hex_roundtrip() {
    let original = [1, 2, 3, 4, 5, 255, 128, 64, 32, 16];
    let hex = crypto::hex_encode(&original);
    let decoded_result = crypto::hex_decode(hex);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded.len(), original.len(), "Should decode to same length");
            for i in 0..original.len() {
                assert_eq(decoded[i], original[i], "Bytes should match");
            }
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test password hashing
fn test_password_hashing() {
    let password = "my-secure-password";
    let hash = crypto::hash_password_auto(password);

    assert_eq(hash.algorithm, "PBKDF2-SHA256", "Algorithm should be PBKDF2-SHA256");
    assert_true(hash.iterations >= 100000, "Should use at least 100000 iterations");
    assert_true(hash.salt.len() > 0, "Should have salt");
    assert_true(hash.hash.len() > 0, "Should have hash");
}

// Test password verification
fn test_password_verification() {
    let password = "correct-password";
    let wrong_password = "wrong-password";

    let hash = crypto::hash_password_auto(password);

    // Correct password should verify
    assert_true(hash.verify(password), "Correct password should verify");

    // Wrong password should not verify
    assert_false(hash.verify(wrong_password), "Wrong password should not verify");
}

// Test password hash serialization
fn test_password_hash_serialization() {
    let password = "test-password";
    let hash = crypto::hash_password_auto(password);

    // Serialize to string
    let serialized = hash.to_string();
    assert_true(serialized.len() > 0, "Serialized string should not be empty");
    assert_true(serialized.starts_with("$"), "Should start with $");

    // Deserialize from string
    let parsed_result = PasswordHash::from_string(serialized);
    match parsed_result {
        Ok(parsed) => {
            assert_eq(parsed.algorithm, hash.algorithm, "Algorithm should match");
            assert_eq(parsed.iterations, hash.iterations, "Iterations should match");
            assert_eq(parsed.salt, hash.salt, "Salt should match");
            assert_eq(parsed.hash, hash.hash, "Hash should match");
        },
        Err(e) => {
            assert(false, "Failed to parse password hash");
        },
    }
}

// Test salt generation
fn test_salt_generation() {
    let salt1 = crypto::generate_salt(32);
    let salt2 = crypto::generate_salt(32);

    assert_eq(salt1.len(), 32, "Salt should have specified length");
    assert_eq(salt2.len(), 32, "Salt should have specified length");
    assert_ne(salt1, salt2, "Salts should be different");
}


// Test Crypto Module Implementation

// Test SHA-256 hashing
fn test_sha256() {
    let data = "Hello, World!";
    let hash = crypto::sha256(data);

    assert_true(hash.to_hex().len() > 0, "SHA-256 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA256, "Algorithm should be SHA256");
}

// Test SHA-1 hashing
fn test_sha1() {
    let data = "Hello, World!";
    let hash = crypto::sha1(data);

    assert_true(hash.to_hex().len() > 0, "SHA-1 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA1, "Algorithm should be SHA1");
}

// Test MD5 hashing
fn test_md5() {
    let data = "Hello, World!";
    let hash = crypto::md5(data);

    assert_true(hash.to_hex().len() > 0, "MD5 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::MD5, "Algorithm should be MD5");
}

// Test HMAC
fn test_hmac() {
    let key = "secret-key";
    let data = "message";
    let hmac = crypto::hmac_sha256(key, data);

    assert_true(hmac.to_hex().len() > 0, "HMAC should not be empty");
}

// Test hash comparison
fn test_hash_equality() {
    let data = "test data";
    let hash1 = crypto::sha256(data);
    let hash2 = crypto::sha256(data);

    assert_true(hash1.eq(&hash2), "Same input should produce same hash");
}

// Test random bytes generation
fn test_random_bytes() {
    let bytes1 = crypto::random_bytes(16);
    let bytes2 = crypto::random_bytes(16);

    assert_eq(bytes1.len(), 16, "Should generate 16 bytes");
    assert_eq(bytes2.len(), 16, "Should generate 16 bytes");

    // Random bytes should be different
    let mut different = false;
    for i in 0..16 {
        if bytes1[i] != bytes2[i] {
            different = true;
            break;
        }
    }
    assert_true(different, "Random bytes should be different");
}

// Test random integer generation
fn test_random_int() {
    let num1 = crypto::random_int(0, 100);
    let num2 = crypto::random_int(0, 100);

    assert_true(num1 >= 0 && num1 < 100, "Random int should be in range [0, 100)");
    assert_true(num2 >= 0 && num2 < 100, "Random int should be in range [0, 100)");
}

// Test random float generation
fn test_random_float() {
    let num1 = crypto::random_float();
    let num2 = crypto::random_float();

    assert_true(num1 >= 0.0 && num1 < 1.0, "Random float should be in range [0, 1)");
    assert_true(num2 >= 0.0 && num2 < 1.0, "Random float should be in range [0, 1)");
}

// Test random string generation
fn test_random_string() {
    let charset = "abc123";
    let str1 = crypto::random_string(10, charset);
    let str2 = crypto::random_string(10, charset);

    assert_eq(str1.len(), 10, "Random string should have specified length");
    assert_eq(str2.len(), 10, "Random string should have specified length");

    // All characters should be from charset
    for i in 0..str1.len() {
        let ch = str1.substring(i, i + 1);
        assert_true(charset.contains(ch), "Character should be from charset");
    }
}

// Test random alphanumeric string
fn test_random_alphanumeric() {
    let str = crypto::random_alphanumeric(20);

    assert_eq(str.len(), 20, "Should generate string of specified length");

    // Check if alphanumeric
    for i in 0..str.len() {
        let ch = str.substring(i, i + 1);
        let is_alpha = (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z");
        let is_digit = ch >= "0" && ch <= "9";
        assert_true(is_alpha || is_digit, "Should be alphanumeric");
    }
}

// Test random hex string
fn test_random_hex() {
    let hex = crypto::random_hex(32);

    assert_eq(hex.len(), 32, "Should generate hex string of specified length");

    // Check if hex characters
    for i in 0..hex.len() {
        let ch = hex.substring(i, i + 1);
        let is_hex = (ch >= "0" && ch <= "9") || (ch >= "a" && ch <= "f");
        assert_true(is_hex, "Should be hex character");
    }
}

// Test UUID v4 generation
fn test_uuid_v4() {
    let uuid1 = crypto::uuid_v4();
    let uuid2 = crypto::uuid_v4();

    // UUID format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    assert_eq(uuid1.len(), 36, "UUID should be 36 characters");
    assert_eq(uuid2.len(), 36, "UUID should be 36 characters");

    // Check hyphens at correct positions
    assert_eq(uuid1.substring(8, 9), "-", "Should have hyphen at position 8");
    assert_eq(uuid1.substring(13, 14), "-", "Should have hyphen at position 13");
    assert_eq(uuid1.substring(18, 19), "-", "Should have hyphen at position 18");
    assert_eq(uuid1.substring(23, 24), "-", "Should have hyphen at position 23");

    // Check version bit (4)
    assert_eq(uuid1.substring(14, 15), "4", "Should have version 4");

    // UUIDs should be different
    assert_ne(uuid1, uuid2, "UUIDs should be unique");
}

// Test base64 encoding
fn test_base64_encode() {
    let data = "Hello, World!";
    let encoded = crypto::base64_encode(data);

    assert_true(encoded.len() > 0, "Encoded string should not be empty");

    // Base64 encoded "Hello, World!" should be known value
    // SGVsbG8sIFdvcmxkIQ==
}

// Test base64 decoding
fn test_base64_decode() {
    let encoded = "SGVsbG8sIFdvcmxkIQ==";
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, "Hello, World!", "Should decode correctly");
        },
        Err(e) => {
            assert(false, "Failed to decode base64");
        },
    }
}

// Test base64 round-trip
fn test_base64_roundtrip() {
    let original = "The quick brown fox jumps over the lazy dog";
    let encoded = crypto::base64_encode(original);
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, original, "Round-trip should preserve data");
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test hex encoding
fn test_hex_encode() {
    let bytes = [72, 101, 108, 108, 111];  // "Hello" in ASCII
    let hex = crypto::hex_encode(&bytes);

    assert_eq(hex, "48656c6c6f", "Should encode to correct hex");
}

// Test hex decoding
fn test_hex_decode() {
    let hex = "48656c6c6f";
    let bytes_result = crypto::hex_decode(hex);

    match bytes_result {
        Ok(bytes) => {
            assert_eq(bytes.len(), 5, "Should decode to 5 bytes");
            assert_eq(bytes[0], 72, "First byte should be 72");
            assert_eq(bytes[1], 101, "Second byte should be 101");
        },
        Err(e) => {
            assert(false, "Failed to decode hex");
        },
    }
}

// Test hex round-trip
fn test_hex_roundtrip() {
    let original = [1, 2, 3, 4, 5, 255, 128, 64, 32, 16];
    let hex = crypto::hex_encode(&original);
    let decoded_result = crypto::hex_decode(hex);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded.len(), original.len(), "Should decode to same length");
            for i in 0..original.len() {
                assert_eq(decoded[i], original[i], "Bytes should match");
            }
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test password hashing
fn test_password_hashing() {
    let password = "my-secure-password";
    let hash = crypto::hash_password_auto(password);

    assert_eq(hash.algorithm, "PBKDF2-SHA256", "Algorithm should be PBKDF2-SHA256");
    assert_true(hash.iterations >= 100000, "Should use at least 100000 iterations");
    assert_true(hash.salt.len() > 0, "Should have salt");
    assert_true(hash.hash.len() > 0, "Should have hash");
}

// Test password verification
fn test_password_verification() {
    let password = "correct-password";
    let wrong_password = "wrong-password";

    let hash = crypto::hash_password_auto(password);

    // Correct password should verify
    assert_true(hash.verify(password), "Correct password should verify");

    // Wrong password should not verify
    assert_false(hash.verify(wrong_password), "Wrong password should not verify");
}

// Test password hash serialization
fn test_password_hash_serialization() {
    let password = "test-password";
    let hash = crypto::hash_password_auto(password);

    // Serialize to string
    let serialized = hash.to_string();
    assert_true(serialized.len() > 0, "Serialized string should not be empty");
    assert_true(serialized.starts_with("$"), "Should start with $");

    // Deserialize from string
    let parsed_result = PasswordHash::from_string(serialized);
    match parsed_result {
        Ok(parsed) => {
            assert_eq(parsed.algorithm, hash.algorithm, "Algorithm should match");
            assert_eq(parsed.iterations, hash.iterations, "Iterations should match");
            assert_eq(parsed.salt, hash.salt, "Salt should match");
            assert_eq(parsed.hash, hash.hash, "Hash should match");
        },
        Err(e) => {
            assert(false, "Failed to parse password hash");
        },
    }
}

// Test salt generation
fn test_salt_generation() {
    let salt1 = crypto::generate_salt(32);
    let salt2 = crypto::generate_salt(32);

    assert_eq(salt1.len(), 32, "Salt should have specified length");
    assert_eq(salt2.len(), 32, "Salt should have specified length");
    assert_ne(salt1, salt2, "Salts should be different");
}


// Test Crypto Module Implementation

// Test SHA-256 hashing
fn test_sha256() {
    let data = "Hello, World!";
    let hash = crypto::sha256(data);

    assert_true(hash.to_hex().len() > 0, "SHA-256 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA256, "Algorithm should be SHA256");
}

// Test SHA-1 hashing
fn test_sha1() {
    let data = "Hello, World!";
    let hash = crypto::sha1(data);

    assert_true(hash.to_hex().len() > 0, "SHA-1 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA1, "Algorithm should be SHA1");
}

// Test MD5 hashing
fn test_md5() {
    let data = "Hello, World!";
    let hash = crypto::md5(data);

    assert_true(hash.to_hex().len() > 0, "MD5 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::MD5, "Algorithm should be MD5");
}

// Test HMAC
fn test_hmac() {
    let key = "secret-key";
    let data = "message";
    let hmac = crypto::hmac_sha256(key, data);

    assert_true(hmac.to_hex().len() > 0, "HMAC should not be empty");
}

// Test hash comparison
fn test_hash_equality() {
    let data = "test data";
    let hash1 = crypto::sha256(data);
    let hash2 = crypto::sha256(data);

    assert_true(hash1.eq(&hash2), "Same input should produce same hash");
}

// Test random bytes generation
fn test_random_bytes() {
    let bytes1 = crypto::random_bytes(16);
    let bytes2 = crypto::random_bytes(16);

    assert_eq(bytes1.len(), 16, "Should generate 16 bytes");
    assert_eq(bytes2.len(), 16, "Should generate 16 bytes");

    // Random bytes should be different
    let mut different = false;
    for i in 0..16 {
        if bytes1[i] != bytes2[i] {
            different = true;
            break;
        }
    }
    assert_true(different, "Random bytes should be different");
}

// Test random integer generation
fn test_random_int() {
    let num1 = crypto::random_int(0, 100);
    let num2 = crypto::random_int(0, 100);

    assert_true(num1 >= 0 && num1 < 100, "Random int should be in range [0, 100)");
    assert_true(num2 >= 0 && num2 < 100, "Random int should be in range [0, 100)");
}

// Test random float generation
fn test_random_float() {
    let num1 = crypto::random_float();
    let num2 = crypto::random_float();

    assert_true(num1 >= 0.0 && num1 < 1.0, "Random float should be in range [0, 1)");
    assert_true(num2 >= 0.0 && num2 < 1.0, "Random float should be in range [0, 1)");
}

// Test random string generation
fn test_random_string() {
    let charset = "abc123";
    let str1 = crypto::random_string(10, charset);
    let str2 = crypto::random_string(10, charset);

    assert_eq(str1.len(), 10, "Random string should have specified length");
    assert_eq(str2.len(), 10, "Random string should have specified length");

    // All characters should be from charset
    for i in 0..str1.len() {
        let ch = str1.substring(i, i + 1);
        assert_true(charset.contains(ch), "Character should be from charset");
    }
}

// Test random alphanumeric string
fn test_random_alphanumeric() {
    let str = crypto::random_alphanumeric(20);

    assert_eq(str.len(), 20, "Should generate string of specified length");

    // Check if alphanumeric
    for i in 0..str.len() {
        let ch = str.substring(i, i + 1);
        let is_alpha = (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z");
        let is_digit = ch >= "0" && ch <= "9";
        assert_true(is_alpha || is_digit, "Should be alphanumeric");
    }
}

// Test random hex string
fn test_random_hex() {
    let hex = crypto::random_hex(32);

    assert_eq(hex.len(), 32, "Should generate hex string of specified length");

    // Check if hex characters
    for i in 0..hex.len() {
        let ch = hex.substring(i, i + 1);
        let is_hex = (ch >= "0" && ch <= "9") || (ch >= "a" && ch <= "f");
        assert_true(is_hex, "Should be hex character");
    }
}

// Test UUID v4 generation
fn test_uuid_v4() {
    let uuid1 = crypto::uuid_v4();
    let uuid2 = crypto::uuid_v4();

    // UUID format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    assert_eq(uuid1.len(), 36, "UUID should be 36 characters");
    assert_eq(uuid2.len(), 36, "UUID should be 36 characters");

    // Check hyphens at correct positions
    assert_eq(uuid1.substring(8, 9), "-", "Should have hyphen at position 8");
    assert_eq(uuid1.substring(13, 14), "-", "Should have hyphen at position 13");
    assert_eq(uuid1.substring(18, 19), "-", "Should have hyphen at position 18");
    assert_eq(uuid1.substring(23, 24), "-", "Should have hyphen at position 23");

    // Check version bit (4)
    assert_eq(uuid1.substring(14, 15), "4", "Should have version 4");

    // UUIDs should be different
    assert_ne(uuid1, uuid2, "UUIDs should be unique");
}

// Test base64 encoding
fn test_base64_encode() {
    let data = "Hello, World!";
    let encoded = crypto::base64_encode(data);

    assert_true(encoded.len() > 0, "Encoded string should not be empty");

    // Base64 encoded "Hello, World!" should be known value
    // SGVsbG8sIFdvcmxkIQ==
}

// Test base64 decoding
fn test_base64_decode() {
    let encoded = "SGVsbG8sIFdvcmxkIQ==";
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, "Hello, World!", "Should decode correctly");
        },
        Err(e) => {
            assert(false, "Failed to decode base64");
        },
    }
}

// Test base64 round-trip
fn test_base64_roundtrip() {
    let original = "The quick brown fox jumps over the lazy dog";
    let encoded = crypto::base64_encode(original);
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, original, "Round-trip should preserve data");
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test hex encoding
fn test_hex_encode() {
    let bytes = [72, 101, 108, 108, 111];  // "Hello" in ASCII
    let hex = crypto::hex_encode(&bytes);

    assert_eq(hex, "48656c6c6f", "Should encode to correct hex");
}

// Test hex decoding
fn test_hex_decode() {
    let hex = "48656c6c6f";
    let bytes_result = crypto::hex_decode(hex);

    match bytes_result {
        Ok(bytes) => {
            assert_eq(bytes.len(), 5, "Should decode to 5 bytes");
            assert_eq(bytes[0], 72, "First byte should be 72");
            assert_eq(bytes[1], 101, "Second byte should be 101");
        },
        Err(e) => {
            assert(false, "Failed to decode hex");
        },
    }
}

// Test hex round-trip
fn test_hex_roundtrip() {
    let original = [1, 2, 3, 4, 5, 255, 128, 64, 32, 16];
    let hex = crypto::hex_encode(&original);
    let decoded_result = crypto::hex_decode(hex);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded.len(), original.len(), "Should decode to same length");
            for i in 0..original.len() {
                assert_eq(decoded[i], original[i], "Bytes should match");
            }
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test password hashing
fn test_password_hashing() {
    let password = "my-secure-password";
    let hash = crypto::hash_password_auto(password);

    assert_eq(hash.algorithm, "PBKDF2-SHA256", "Algorithm should be PBKDF2-SHA256");
    assert_true(hash.iterations >= 100000, "Should use at least 100000 iterations");
    assert_true(hash.salt.len() > 0, "Should have salt");
    assert_true(hash.hash.len() > 0, "Should have hash");
}

// Test password verification
fn test_password_verification() {
    let password = "correct-password";
    let wrong_password = "wrong-password";

    let hash = crypto::hash_password_auto(password);

    // Correct password should verify
    assert_true(hash.verify(password), "Correct password should verify");

    // Wrong password should not verify
    assert_false(hash.verify(wrong_password), "Wrong password should not verify");
}

// Test password hash serialization
fn test_password_hash_serialization() {
    let password = "test-password";
    let hash = crypto::hash_password_auto(password);

    // Serialize to string
    let serialized = hash.to_string();
    assert_true(serialized.len() > 0, "Serialized string should not be empty");
    assert_true(serialized.starts_with("$"), "Should start with $");

    // Deserialize from string
    let parsed_result = PasswordHash::from_string(serialized);
    match parsed_result {
        Ok(parsed) => {
            assert_eq(parsed.algorithm, hash.algorithm, "Algorithm should match");
            assert_eq(parsed.iterations, hash.iterations, "Iterations should match");
            assert_eq(parsed.salt, hash.salt, "Salt should match");
            assert_eq(parsed.hash, hash.hash, "Hash should match");
        },
        Err(e) => {
            assert(false, "Failed to parse password hash");
        },
    }
}

// Test salt generation
fn test_salt_generation() {
    let salt1 = crypto::generate_salt(32);
    let salt2 = crypto::generate_salt(32);

    assert_eq(salt1.len(), 32, "Salt should have specified length");
    assert_eq(salt2.len(), 32, "Salt should have specified length");
    assert_ne(salt1, salt2, "Salts should be different");
}


// Test Crypto Module Implementation

// Test SHA-256 hashing
fn test_sha256() {
    let data = "Hello, World!";
    let hash = crypto::sha256(data);

    assert_true(hash.to_hex().len() > 0, "SHA-256 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA256, "Algorithm should be SHA256");
}

// Test SHA-1 hashing
fn test_sha1() {
    let data = "Hello, World!";
    let hash = crypto::sha1(data);

    assert_true(hash.to_hex().len() > 0, "SHA-1 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA1, "Algorithm should be SHA1");
}

// Test MD5 hashing
fn test_md5() {
    let data = "Hello, World!";
    let hash = crypto::md5(data);

    assert_true(hash.to_hex().len() > 0, "MD5 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::MD5, "Algorithm should be MD5");
}

// Test HMAC
fn test_hmac() {
    let key = "secret-key";
    let data = "message";
    let hmac = crypto::hmac_sha256(key, data);

    assert_true(hmac.to_hex().len() > 0, "HMAC should not be empty");
}

// Test hash comparison
fn test_hash_equality() {
    let data = "test data";
    let hash1 = crypto::sha256(data);
    let hash2 = crypto::sha256(data);

    assert_true(hash1.eq(&hash2), "Same input should produce same hash");
}

// Test random bytes generation
fn test_random_bytes() {
    let bytes1 = crypto::random_bytes(16);
    let bytes2 = crypto::random_bytes(16);

    assert_eq(bytes1.len(), 16, "Should generate 16 bytes");
    assert_eq(bytes2.len(), 16, "Should generate 16 bytes");

    // Random bytes should be different
    let mut different = false;
    for i in 0..16 {
        if bytes1[i] != bytes2[i] {
            different = true;
            break;
        }
    }
    assert_true(different, "Random bytes should be different");
}

// Test random integer generation
fn test_random_int() {
    let num1 = crypto::random_int(0, 100);
    let num2 = crypto::random_int(0, 100);

    assert_true(num1 >= 0 && num1 < 100, "Random int should be in range [0, 100)");
    assert_true(num2 >= 0 && num2 < 100, "Random int should be in range [0, 100)");
}

// Test random float generation
fn test_random_float() {
    let num1 = crypto::random_float();
    let num2 = crypto::random_float();

    assert_true(num1 >= 0.0 && num1 < 1.0, "Random float should be in range [0, 1)");
    assert_true(num2 >= 0.0 && num2 < 1.0, "Random float should be in range [0, 1)");
}

// Test random string generation
fn test_random_string() {
    let charset = "abc123";
    let str1 = crypto::random_string(10, charset);
    let str2 = crypto::random_string(10, charset);

    assert_eq(str1.len(), 10, "Random string should have specified length");
    assert_eq(str2.len(), 10, "Random string should have specified length");

    // All characters should be from charset
    for i in 0..str1.len() {
        let ch = str1.substring(i, i + 1);
        assert_true(charset.contains(ch), "Character should be from charset");
    }
}

// Test random alphanumeric string
fn test_random_alphanumeric() {
    let str = crypto::random_alphanumeric(20);

    assert_eq(str.len(), 20, "Should generate string of specified length");

    // Check if alphanumeric
    for i in 0..str.len() {
        let ch = str.substring(i, i + 1);
        let is_alpha = (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z");
        let is_digit = ch >= "0" && ch <= "9";
        assert_true(is_alpha || is_digit, "Should be alphanumeric");
    }
}

// Test random hex string
fn test_random_hex() {
    let hex = crypto::random_hex(32);

    assert_eq(hex.len(), 32, "Should generate hex string of specified length");

    // Check if hex characters
    for i in 0..hex.len() {
        let ch = hex.substring(i, i + 1);
        let is_hex = (ch >= "0" && ch <= "9") || (ch >= "a" && ch <= "f");
        assert_true(is_hex, "Should be hex character");
    }
}

// Test UUID v4 generation
fn test_uuid_v4() {
    let uuid1 = crypto::uuid_v4();
    let uuid2 = crypto::uuid_v4();

    // UUID format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    assert_eq(uuid1.len(), 36, "UUID should be 36 characters");
    assert_eq(uuid2.len(), 36, "UUID should be 36 characters");

    // Check hyphens at correct positions
    assert_eq(uuid1.substring(8, 9), "-", "Should have hyphen at position 8");
    assert_eq(uuid1.substring(13, 14), "-", "Should have hyphen at position 13");
    assert_eq(uuid1.substring(18, 19), "-", "Should have hyphen at position 18");
    assert_eq(uuid1.substring(23, 24), "-", "Should have hyphen at position 23");

    // Check version bit (4)
    assert_eq(uuid1.substring(14, 15), "4", "Should have version 4");

    // UUIDs should be different
    assert_ne(uuid1, uuid2, "UUIDs should be unique");
}

// Test base64 encoding
fn test_base64_encode() {
    let data = "Hello, World!";
    let encoded = crypto::base64_encode(data);

    assert_true(encoded.len() > 0, "Encoded string should not be empty");

    // Base64 encoded "Hello, World!" should be known value
    // SGVsbG8sIFdvcmxkIQ==
}

// Test base64 decoding
fn test_base64_decode() {
    let encoded = "SGVsbG8sIFdvcmxkIQ==";
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, "Hello, World!", "Should decode correctly");
        },
        Err(e) => {
            assert(false, "Failed to decode base64");
        },
    }
}

// Test base64 round-trip
fn test_base64_roundtrip() {
    let original = "The quick brown fox jumps over the lazy dog";
    let encoded = crypto::base64_encode(original);
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, original, "Round-trip should preserve data");
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test hex encoding
fn test_hex_encode() {
    let bytes = [72, 101, 108, 108, 111];  // "Hello" in ASCII
    let hex = crypto::hex_encode(&bytes);

    assert_eq(hex, "48656c6c6f", "Should encode to correct hex");
}

// Test hex decoding
fn test_hex_decode() {
    let hex = "48656c6c6f";
    let bytes_result = crypto::hex_decode(hex);

    match bytes_result {
        Ok(bytes) => {
            assert_eq(bytes.len(), 5, "Should decode to 5 bytes");
            assert_eq(bytes[0], 72, "First byte should be 72");
            assert_eq(bytes[1], 101, "Second byte should be 101");
        },
        Err(e) => {
            assert(false, "Failed to decode hex");
        },
    }
}

// Test hex round-trip
fn test_hex_roundtrip() {
    let original = [1, 2, 3, 4, 5, 255, 128, 64, 32, 16];
    let hex = crypto::hex_encode(&original);
    let decoded_result = crypto::hex_decode(hex);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded.len(), original.len(), "Should decode to same length");
            for i in 0..original.len() {
                assert_eq(decoded[i], original[i], "Bytes should match");
            }
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test password hashing
fn test_password_hashing() {
    let password = "my-secure-password";
    let hash = crypto::hash_password_auto(password);

    assert_eq(hash.algorithm, "PBKDF2-SHA256", "Algorithm should be PBKDF2-SHA256");
    assert_true(hash.iterations >= 100000, "Should use at least 100000 iterations");
    assert_true(hash.salt.len() > 0, "Should have salt");
    assert_true(hash.hash.len() > 0, "Should have hash");
}

// Test password verification
fn test_password_verification() {
    let password = "correct-password";
    let wrong_password = "wrong-password";

    let hash = crypto::hash_password_auto(password);

    // Correct password should verify
    assert_true(hash.verify(password), "Correct password should verify");

    // Wrong password should not verify
    assert_false(hash.verify(wrong_password), "Wrong password should not verify");
}

// Test password hash serialization
fn test_password_hash_serialization() {
    let password = "test-password";
    let hash = crypto::hash_password_auto(password);

    // Serialize to string
    let serialized = hash.to_string();
    assert_true(serialized.len() > 0, "Serialized string should not be empty");
    assert_true(serialized.starts_with("$"), "Should start with $");

    // Deserialize from string
    let parsed_result = PasswordHash::from_string(serialized);
    match parsed_result {
        Ok(parsed) => {
            assert_eq(parsed.algorithm, hash.algorithm, "Algorithm should match");
            assert_eq(parsed.iterations, hash.iterations, "Iterations should match");
            assert_eq(parsed.salt, hash.salt, "Salt should match");
            assert_eq(parsed.hash, hash.hash, "Hash should match");
        },
        Err(e) => {
            assert(false, "Failed to parse password hash");
        },
    }
}

// Test salt generation
fn test_salt_generation() {
    let salt1 = crypto::generate_salt(32);
    let salt2 = crypto::generate_salt(32);

    assert_eq(salt1.len(), 32, "Salt should have specified length");
    assert_eq(salt2.len(), 32, "Salt should have specified length");
    assert_ne(salt1, salt2, "Salts should be different");
}


// Test Crypto Module Implementation

// Test SHA-256 hashing
fn test_sha256() {
    let data = "Hello, World!";
    let hash = crypto::sha256(data);

    assert_true(hash.to_hex().len() > 0, "SHA-256 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA256, "Algorithm should be SHA256");
}

// Test SHA-1 hashing
fn test_sha1() {
    let data = "Hello, World!";
    let hash = crypto::sha1(data);

    assert_true(hash.to_hex().len() > 0, "SHA-1 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA1, "Algorithm should be SHA1");
}

// Test MD5 hashing
fn test_md5() {
    let data = "Hello, World!";
    let hash = crypto::md5(data);

    assert_true(hash.to_hex().len() > 0, "MD5 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::MD5, "Algorithm should be MD5");
}

// Test HMAC
fn test_hmac() {
    let key = "secret-key";
    let data = "message";
    let hmac = crypto::hmac_sha256(key, data);

    assert_true(hmac.to_hex().len() > 0, "HMAC should not be empty");
}

// Test hash comparison
fn test_hash_equality() {
    let data = "test data";
    let hash1 = crypto::sha256(data);
    let hash2 = crypto::sha256(data);

    assert_true(hash1.eq(&hash2), "Same input should produce same hash");
}

// Test random bytes generation
fn test_random_bytes() {
    let bytes1 = crypto::random_bytes(16);
    let bytes2 = crypto::random_bytes(16);

    assert_eq(bytes1.len(), 16, "Should generate 16 bytes");
    assert_eq(bytes2.len(), 16, "Should generate 16 bytes");

    // Random bytes should be different
    let mut different = false;
    for i in 0..16 {
        if bytes1[i] != bytes2[i] {
            different = true;
            break;
        }
    }
    assert_true(different, "Random bytes should be different");
}

// Test random integer generation
fn test_random_int() {
    let num1 = crypto::random_int(0, 100);
    let num2 = crypto::random_int(0, 100);

    assert_true(num1 >= 0 && num1 < 100, "Random int should be in range [0, 100)");
    assert_true(num2 >= 0 && num2 < 100, "Random int should be in range [0, 100)");
}

// Test random float generation
fn test_random_float() {
    let num1 = crypto::random_float();
    let num2 = crypto::random_float();

    assert_true(num1 >= 0.0 && num1 < 1.0, "Random float should be in range [0, 1)");
    assert_true(num2 >= 0.0 && num2 < 1.0, "Random float should be in range [0, 1)");
}

// Test random string generation
fn test_random_string() {
    let charset = "abc123";
    let str1 = crypto::random_string(10, charset);
    let str2 = crypto::random_string(10, charset);

    assert_eq(str1.len(), 10, "Random string should have specified length");
    assert_eq(str2.len(), 10, "Random string should have specified length");

    // All characters should be from charset
    for i in 0..str1.len() {
        let ch = str1.substring(i, i + 1);
        assert_true(charset.contains(ch), "Character should be from charset");
    }
}

// Test random alphanumeric string
fn test_random_alphanumeric() {
    let str = crypto::random_alphanumeric(20);

    assert_eq(str.len(), 20, "Should generate string of specified length");

    // Check if alphanumeric
    for i in 0..str.len() {
        let ch = str.substring(i, i + 1);
        let is_alpha = (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z");
        let is_digit = ch >= "0" && ch <= "9";
        assert_true(is_alpha || is_digit, "Should be alphanumeric");
    }
}

// Test random hex string
fn test_random_hex() {
    let hex = crypto::random_hex(32);

    assert_eq(hex.len(), 32, "Should generate hex string of specified length");

    // Check if hex characters
    for i in 0..hex.len() {
        let ch = hex.substring(i, i + 1);
        let is_hex = (ch >= "0" && ch <= "9") || (ch >= "a" && ch <= "f");
        assert_true(is_hex, "Should be hex character");
    }
}

// Test UUID v4 generation
fn test_uuid_v4() {
    let uuid1 = crypto::uuid_v4();
    let uuid2 = crypto::uuid_v4();

    // UUID format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    assert_eq(uuid1.len(), 36, "UUID should be 36 characters");
    assert_eq(uuid2.len(), 36, "UUID should be 36 characters");

    // Check hyphens at correct positions
    assert_eq(uuid1.substring(8, 9), "-", "Should have hyphen at position 8");
    assert_eq(uuid1.substring(13, 14), "-", "Should have hyphen at position 13");
    assert_eq(uuid1.substring(18, 19), "-", "Should have hyphen at position 18");
    assert_eq(uuid1.substring(23, 24), "-", "Should have hyphen at position 23");

    // Check version bit (4)
    assert_eq(uuid1.substring(14, 15), "4", "Should have version 4");

    // UUIDs should be different
    assert_ne(uuid1, uuid2, "UUIDs should be unique");
}

// Test base64 encoding
fn test_base64_encode() {
    let data = "Hello, World!";
    let encoded = crypto::base64_encode(data);

    assert_true(encoded.len() > 0, "Encoded string should not be empty");

    // Base64 encoded "Hello, World!" should be known value
    // SGVsbG8sIFdvcmxkIQ==
}

// Test base64 decoding
fn test_base64_decode() {
    let encoded = "SGVsbG8sIFdvcmxkIQ==";
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, "Hello, World!", "Should decode correctly");
        },
        Err(e) => {
            assert(false, "Failed to decode base64");
        },
    }
}

// Test base64 round-trip
fn test_base64_roundtrip() {
    let original = "The quick brown fox jumps over the lazy dog";
    let encoded = crypto::base64_encode(original);
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, original, "Round-trip should preserve data");
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test hex encoding
fn test_hex_encode() {
    let bytes = [72, 101, 108, 108, 111];  // "Hello" in ASCII
    let hex = crypto::hex_encode(&bytes);

    assert_eq(hex, "48656c6c6f", "Should encode to correct hex");
}

// Test hex decoding
fn test_hex_decode() {
    let hex = "48656c6c6f";
    let bytes_result = crypto::hex_decode(hex);

    match bytes_result {
        Ok(bytes) => {
            assert_eq(bytes.len(), 5, "Should decode to 5 bytes");
            assert_eq(bytes[0], 72, "First byte should be 72");
            assert_eq(bytes[1], 101, "Second byte should be 101");
        },
        Err(e) => {
            assert(false, "Failed to decode hex");
        },
    }
}

// Test hex round-trip
fn test_hex_roundtrip() {
    let original = [1, 2, 3, 4, 5, 255, 128, 64, 32, 16];
    let hex = crypto::hex_encode(&original);
    let decoded_result = crypto::hex_decode(hex);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded.len(), original.len(), "Should decode to same length");
            for i in 0..original.len() {
                assert_eq(decoded[i], original[i], "Bytes should match");
            }
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test password hashing
fn test_password_hashing() {
    let password = "my-secure-password";
    let hash = crypto::hash_password_auto(password);

    assert_eq(hash.algorithm, "PBKDF2-SHA256", "Algorithm should be PBKDF2-SHA256");
    assert_true(hash.iterations >= 100000, "Should use at least 100000 iterations");
    assert_true(hash.salt.len() > 0, "Should have salt");
    assert_true(hash.hash.len() > 0, "Should have hash");
}

// Test password verification
fn test_password_verification() {
    let password = "correct-password";
    let wrong_password = "wrong-password";

    let hash = crypto::hash_password_auto(password);

    // Correct password should verify
    assert_true(hash.verify(password), "Correct password should verify");

    // Wrong password should not verify
    assert_false(hash.verify(wrong_password), "Wrong password should not verify");
}

// Test password hash serialization
fn test_password_hash_serialization() {
    let password = "test-password";
    let hash = crypto::hash_password_auto(password);

    // Serialize to string
    let serialized = hash.to_string();
    assert_true(serialized.len() > 0, "Serialized string should not be empty");
    assert_true(serialized.starts_with("$"), "Should start with $");

    // Deserialize from string
    let parsed_result = PasswordHash::from_string(serialized);
    match parsed_result {
        Ok(parsed) => {
            assert_eq(parsed.algorithm, hash.algorithm, "Algorithm should match");
            assert_eq(parsed.iterations, hash.iterations, "Iterations should match");
            assert_eq(parsed.salt, hash.salt, "Salt should match");
            assert_eq(parsed.hash, hash.hash, "Hash should match");
        },
        Err(e) => {
            assert(false, "Failed to parse password hash");
        },
    }
}

// Test salt generation
fn test_salt_generation() {
    let salt1 = crypto::generate_salt(32);
    let salt2 = crypto::generate_salt(32);

    assert_eq(salt1.len(), 32, "Salt should have specified length");
    assert_eq(salt2.len(), 32, "Salt should have specified length");
    assert_ne(salt1, salt2, "Salts should be different");
}


// Test Crypto Module Implementation

// Test SHA-256 hashing
fn test_sha256() {
    let data = "Hello, World!";
    let hash = crypto::sha256(data);

    assert_true(hash.to_hex().len() > 0, "SHA-256 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA256, "Algorithm should be SHA256");
}

// Test SHA-1 hashing
fn test_sha1() {
    let data = "Hello, World!";
    let hash = crypto::sha1(data);

    assert_true(hash.to_hex().len() > 0, "SHA-1 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA1, "Algorithm should be SHA1");
}

// Test MD5 hashing
fn test_md5() {
    let data = "Hello, World!";
    let hash = crypto::md5(data);

    assert_true(hash.to_hex().len() > 0, "MD5 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::MD5, "Algorithm should be MD5");
}

// Test HMAC
fn test_hmac() {
    let key = "secret-key";
    let data = "message";
    let hmac = crypto::hmac_sha256(key, data);

    assert_true(hmac.to_hex().len() > 0, "HMAC should not be empty");
}

// Test hash comparison
fn test_hash_equality() {
    let data = "test data";
    let hash1 = crypto::sha256(data);
    let hash2 = crypto::sha256(data);

    assert_true(hash1.eq(&hash2), "Same input should produce same hash");
}

// Test random bytes generation
fn test_random_bytes() {
    let bytes1 = crypto::random_bytes(16);
    let bytes2 = crypto::random_bytes(16);

    assert_eq(bytes1.len(), 16, "Should generate 16 bytes");
    assert_eq(bytes2.len(), 16, "Should generate 16 bytes");

    // Random bytes should be different
    let mut different = false;
    for i in 0..16 {
        if bytes1[i] != bytes2[i] {
            different = true;
            break;
        }
    }
    assert_true(different, "Random bytes should be different");
}

// Test random integer generation
fn test_random_int() {
    let num1 = crypto::random_int(0, 100);
    let num2 = crypto::random_int(0, 100);

    assert_true(num1 >= 0 && num1 < 100, "Random int should be in range [0, 100)");
    assert_true(num2 >= 0 && num2 < 100, "Random int should be in range [0, 100)");
}

// Test random float generation
fn test_random_float() {
    let num1 = crypto::random_float();
    let num2 = crypto::random_float();

    assert_true(num1 >= 0.0 && num1 < 1.0, "Random float should be in range [0, 1)");
    assert_true(num2 >= 0.0 && num2 < 1.0, "Random float should be in range [0, 1)");
}

// Test random string generation
fn test_random_string() {
    let charset = "abc123";
    let str1 = crypto::random_string(10, charset);
    let str2 = crypto::random_string(10, charset);

    assert_eq(str1.len(), 10, "Random string should have specified length");
    assert_eq(str2.len(), 10, "Random string should have specified length");

    // All characters should be from charset
    for i in 0..str1.len() {
        let ch = str1.substring(i, i + 1);
        assert_true(charset.contains(ch), "Character should be from charset");
    }
}

// Test random alphanumeric string
fn test_random_alphanumeric() {
    let str = crypto::random_alphanumeric(20);

    assert_eq(str.len(), 20, "Should generate string of specified length");

    // Check if alphanumeric
    for i in 0..str.len() {
        let ch = str.substring(i, i + 1);
        let is_alpha = (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z");
        let is_digit = ch >= "0" && ch <= "9";
        assert_true(is_alpha || is_digit, "Should be alphanumeric");
    }
}

// Test random hex string
fn test_random_hex() {
    let hex = crypto::random_hex(32);

    assert_eq(hex.len(), 32, "Should generate hex string of specified length");

    // Check if hex characters
    for i in 0..hex.len() {
        let ch = hex.substring(i, i + 1);
        let is_hex = (ch >= "0" && ch <= "9") || (ch >= "a" && ch <= "f");
        assert_true(is_hex, "Should be hex character");
    }
}

// Test UUID v4 generation
fn test_uuid_v4() {
    let uuid1 = crypto::uuid_v4();
    let uuid2 = crypto::uuid_v4();

    // UUID format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    assert_eq(uuid1.len(), 36, "UUID should be 36 characters");
    assert_eq(uuid2.len(), 36, "UUID should be 36 characters");

    // Check hyphens at correct positions
    assert_eq(uuid1.substring(8, 9), "-", "Should have hyphen at position 8");
    assert_eq(uuid1.substring(13, 14), "-", "Should have hyphen at position 13");
    assert_eq(uuid1.substring(18, 19), "-", "Should have hyphen at position 18");
    assert_eq(uuid1.substring(23, 24), "-", "Should have hyphen at position 23");

    // Check version bit (4)
    assert_eq(uuid1.substring(14, 15), "4", "Should have version 4");

    // UUIDs should be different
    assert_ne(uuid1, uuid2, "UUIDs should be unique");
}

// Test base64 encoding
fn test_base64_encode() {
    let data = "Hello, World!";
    let encoded = crypto::base64_encode(data);

    assert_true(encoded.len() > 0, "Encoded string should not be empty");

    // Base64 encoded "Hello, World!" should be known value
    // SGVsbG8sIFdvcmxkIQ==
}

// Test base64 decoding
fn test_base64_decode() {
    let encoded = "SGVsbG8sIFdvcmxkIQ==";
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, "Hello, World!", "Should decode correctly");
        },
        Err(e) => {
            assert(false, "Failed to decode base64");
        },
    }
}

// Test base64 round-trip
fn test_base64_roundtrip() {
    let original = "The quick brown fox jumps over the lazy dog";
    let encoded = crypto::base64_encode(original);
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, original, "Round-trip should preserve data");
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test hex encoding
fn test_hex_encode() {
    let bytes = [72, 101, 108, 108, 111];  // "Hello" in ASCII
    let hex = crypto::hex_encode(&bytes);

    assert_eq(hex, "48656c6c6f", "Should encode to correct hex");
}

// Test hex decoding
fn test_hex_decode() {
    let hex = "48656c6c6f";
    let bytes_result = crypto::hex_decode(hex);

    match bytes_result {
        Ok(bytes) => {
            assert_eq(bytes.len(), 5, "Should decode to 5 bytes");
            assert_eq(bytes[0], 72, "First byte should be 72");
            assert_eq(bytes[1], 101, "Second byte should be 101");
        },
        Err(e) => {
            assert(false, "Failed to decode hex");
        },
    }
}

// Test hex round-trip
fn test_hex_roundtrip() {
    let original = [1, 2, 3, 4, 5, 255, 128, 64, 32, 16];
    let hex = crypto::hex_encode(&original);
    let decoded_result = crypto::hex_decode(hex);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded.len(), original.len(), "Should decode to same length");
            for i in 0..original.len() {
                assert_eq(decoded[i], original[i], "Bytes should match");
            }
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test password hashing
fn test_password_hashing() {
    let password = "my-secure-password";
    let hash = crypto::hash_password_auto(password);

    assert_eq(hash.algorithm, "PBKDF2-SHA256", "Algorithm should be PBKDF2-SHA256");
    assert_true(hash.iterations >= 100000, "Should use at least 100000 iterations");
    assert_true(hash.salt.len() > 0, "Should have salt");
    assert_true(hash.hash.len() > 0, "Should have hash");
}

// Test password verification
fn test_password_verification() {
    let password = "correct-password";
    let wrong_password = "wrong-password";

    let hash = crypto::hash_password_auto(password);

    // Correct password should verify
    assert_true(hash.verify(password), "Correct password should verify");

    // Wrong password should not verify
    assert_false(hash.verify(wrong_password), "Wrong password should not verify");
}

// Test password hash serialization
fn test_password_hash_serialization() {
    let password = "test-password";
    let hash = crypto::hash_password_auto(password);

    // Serialize to string
    let serialized = hash.to_string();
    assert_true(serialized.len() > 0, "Serialized string should not be empty");
    assert_true(serialized.starts_with("$"), "Should start with $");

    // Deserialize from string
    let parsed_result = PasswordHash::from_string(serialized);
    match parsed_result {
        Ok(parsed) => {
            assert_eq(parsed.algorithm, hash.algorithm, "Algorithm should match");
            assert_eq(parsed.iterations, hash.iterations, "Iterations should match");
            assert_eq(parsed.salt, hash.salt, "Salt should match");
            assert_eq(parsed.hash, hash.hash, "Hash should match");
        },
        Err(e) => {
            assert(false, "Failed to parse password hash");
        },
    }
}

// Test salt generation
fn test_salt_generation() {
    let salt1 = crypto::generate_salt(32);
    let salt2 = crypto::generate_salt(32);

    assert_eq(salt1.len(), 32, "Salt should have specified length");
    assert_eq(salt2.len(), 32, "Salt should have specified length");
    assert_ne(salt1, salt2, "Salts should be different");
}


// Test Crypto Module Implementation

// Test SHA-256 hashing
fn test_sha256() {
    let data = "Hello, World!";
    let hash = crypto::sha256(data);

    assert_true(hash.to_hex().len() > 0, "SHA-256 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA256, "Algorithm should be SHA256");
}

// Test SHA-1 hashing
fn test_sha1() {
    let data = "Hello, World!";
    let hash = crypto::sha1(data);

    assert_true(hash.to_hex().len() > 0, "SHA-1 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA1, "Algorithm should be SHA1");
}

// Test MD5 hashing
fn test_md5() {
    let data = "Hello, World!";
    let hash = crypto::md5(data);

    assert_true(hash.to_hex().len() > 0, "MD5 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::MD5, "Algorithm should be MD5");
}

// Test HMAC
fn test_hmac() {
    let key = "secret-key";
    let data = "message";
    let hmac = crypto::hmac_sha256(key, data);

    assert_true(hmac.to_hex().len() > 0, "HMAC should not be empty");
}

// Test hash comparison
fn test_hash_equality() {
    let data = "test data";
    let hash1 = crypto::sha256(data);
    let hash2 = crypto::sha256(data);

    assert_true(hash1.eq(&hash2), "Same input should produce same hash");
}

// Test random bytes generation
fn test_random_bytes() {
    let bytes1 = crypto::random_bytes(16);
    let bytes2 = crypto::random_bytes(16);

    assert_eq(bytes1.len(), 16, "Should generate 16 bytes");
    assert_eq(bytes2.len(), 16, "Should generate 16 bytes");

    // Random bytes should be different
    let mut different = false;
    for i in 0..16 {
        if bytes1[i] != bytes2[i] {
            different = true;
            break;
        }
    }
    assert_true(different, "Random bytes should be different");
}

// Test random integer generation
fn test_random_int() {
    let num1 = crypto::random_int(0, 100);
    let num2 = crypto::random_int(0, 100);

    assert_true(num1 >= 0 && num1 < 100, "Random int should be in range [0, 100)");
    assert_true(num2 >= 0 && num2 < 100, "Random int should be in range [0, 100)");
}

// Test random float generation
fn test_random_float() {
    let num1 = crypto::random_float();
    let num2 = crypto::random_float();

    assert_true(num1 >= 0.0 && num1 < 1.0, "Random float should be in range [0, 1)");
    assert_true(num2 >= 0.0 && num2 < 1.0, "Random float should be in range [0, 1)");
}

// Test random string generation
fn test_random_string() {
    let charset = "abc123";
    let str1 = crypto::random_string(10, charset);
    let str2 = crypto::random_string(10, charset);

    assert_eq(str1.len(), 10, "Random string should have specified length");
    assert_eq(str2.len(), 10, "Random string should have specified length");

    // All characters should be from charset
    for i in 0..str1.len() {
        let ch = str1.substring(i, i + 1);
        assert_true(charset.contains(ch), "Character should be from charset");
    }
}

// Test random alphanumeric string
fn test_random_alphanumeric() {
    let str = crypto::random_alphanumeric(20);

    assert_eq(str.len(), 20, "Should generate string of specified length");

    // Check if alphanumeric
    for i in 0..str.len() {
        let ch = str.substring(i, i + 1);
        let is_alpha = (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z");
        let is_digit = ch >= "0" && ch <= "9";
        assert_true(is_alpha || is_digit, "Should be alphanumeric");
    }
}

// Test random hex string
fn test_random_hex() {
    let hex = crypto::random_hex(32);

    assert_eq(hex.len(), 32, "Should generate hex string of specified length");

    // Check if hex characters
    for i in 0..hex.len() {
        let ch = hex.substring(i, i + 1);
        let is_hex = (ch >= "0" && ch <= "9") || (ch >= "a" && ch <= "f");
        assert_true(is_hex, "Should be hex character");
    }
}

// Test UUID v4 generation
fn test_uuid_v4() {
    let uuid1 = crypto::uuid_v4();
    let uuid2 = crypto::uuid_v4();

    // UUID format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    assert_eq(uuid1.len(), 36, "UUID should be 36 characters");
    assert_eq(uuid2.len(), 36, "UUID should be 36 characters");

    // Check hyphens at correct positions
    assert_eq(uuid1.substring(8, 9), "-", "Should have hyphen at position 8");
    assert_eq(uuid1.substring(13, 14), "-", "Should have hyphen at position 13");
    assert_eq(uuid1.substring(18, 19), "-", "Should have hyphen at position 18");
    assert_eq(uuid1.substring(23, 24), "-", "Should have hyphen at position 23");

    // Check version bit (4)
    assert_eq(uuid1.substring(14, 15), "4", "Should have version 4");

    // UUIDs should be different
    assert_ne(uuid1, uuid2, "UUIDs should be unique");
}

// Test base64 encoding
fn test_base64_encode() {
    let data = "Hello, World!";
    let encoded = crypto::base64_encode(data);

    assert_true(encoded.len() > 0, "Encoded string should not be empty");

    // Base64 encoded "Hello, World!" should be known value
    // SGVsbG8sIFdvcmxkIQ==
}

// Test base64 decoding
fn test_base64_decode() {
    let encoded = "SGVsbG8sIFdvcmxkIQ==";
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, "Hello, World!", "Should decode correctly");
        },
        Err(e) => {
            assert(false, "Failed to decode base64");
        },
    }
}

// Test base64 round-trip
fn test_base64_roundtrip() {
    let original = "The quick brown fox jumps over the lazy dog";
    let encoded = crypto::base64_encode(original);
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, original, "Round-trip should preserve data");
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test hex encoding
fn test_hex_encode() {
    let bytes = [72, 101, 108, 108, 111];  // "Hello" in ASCII
    let hex = crypto::hex_encode(&bytes);

    assert_eq(hex, "48656c6c6f", "Should encode to correct hex");
}

// Test hex decoding
fn test_hex_decode() {
    let hex = "48656c6c6f";
    let bytes_result = crypto::hex_decode(hex);

    match bytes_result {
        Ok(bytes) => {
            assert_eq(bytes.len(), 5, "Should decode to 5 bytes");
            assert_eq(bytes[0], 72, "First byte should be 72");
            assert_eq(bytes[1], 101, "Second byte should be 101");
        },
        Err(e) => {
            assert(false, "Failed to decode hex");
        },
    }
}

// Test hex round-trip
fn test_hex_roundtrip() {
    let original = [1, 2, 3, 4, 5, 255, 128, 64, 32, 16];
    let hex = crypto::hex_encode(&original);
    let decoded_result = crypto::hex_decode(hex);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded.len(), original.len(), "Should decode to same length");
            for i in 0..original.len() {
                assert_eq(decoded[i], original[i], "Bytes should match");
            }
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test password hashing
fn test_password_hashing() {
    let password = "my-secure-password";
    let hash = crypto::hash_password_auto(password);

    assert_eq(hash.algorithm, "PBKDF2-SHA256", "Algorithm should be PBKDF2-SHA256");
    assert_true(hash.iterations >= 100000, "Should use at least 100000 iterations");
    assert_true(hash.salt.len() > 0, "Should have salt");
    assert_true(hash.hash.len() > 0, "Should have hash");
}

// Test password verification
fn test_password_verification() {
    let password = "correct-password";
    let wrong_password = "wrong-password";

    let hash = crypto::hash_password_auto(password);

    // Correct password should verify
    assert_true(hash.verify(password), "Correct password should verify");

    // Wrong password should not verify
    assert_false(hash.verify(wrong_password), "Wrong password should not verify");
}

// Test password hash serialization
fn test_password_hash_serialization() {
    let password = "test-password";
    let hash = crypto::hash_password_auto(password);

    // Serialize to string
    let serialized = hash.to_string();
    assert_true(serialized.len() > 0, "Serialized string should not be empty");
    assert_true(serialized.starts_with("$"), "Should start with $");

    // Deserialize from string
    let parsed_result = PasswordHash::from_string(serialized);
    match parsed_result {
        Ok(parsed) => {
            assert_eq(parsed.algorithm, hash.algorithm, "Algorithm should match");
            assert_eq(parsed.iterations, hash.iterations, "Iterations should match");
            assert_eq(parsed.salt, hash.salt, "Salt should match");
            assert_eq(parsed.hash, hash.hash, "Hash should match");
        },
        Err(e) => {
            assert(false, "Failed to parse password hash");
        },
    }
}

// Test salt generation
fn test_salt_generation() {
    let salt1 = crypto::generate_salt(32);
    let salt2 = crypto::generate_salt(32);

    assert_eq(salt1.len(), 32, "Salt should have specified length");
    assert_eq(salt2.len(), 32, "Salt should have specified length");
    assert_ne(salt1, salt2, "Salts should be different");
}


// Test Crypto Module Implementation

// Test SHA-256 hashing
fn test_sha256() {
    let data = "Hello, World!";
    let hash = crypto::sha256(data);

    assert_true(hash.to_hex().len() > 0, "SHA-256 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA256, "Algorithm should be SHA256");
}

// Test SHA-1 hashing
fn test_sha1() {
    let data = "Hello, World!";
    let hash = crypto::sha1(data);

    assert_true(hash.to_hex().len() > 0, "SHA-1 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA1, "Algorithm should be SHA1");
}

// Test MD5 hashing
fn test_md5() {
    let data = "Hello, World!";
    let hash = crypto::md5(data);

    assert_true(hash.to_hex().len() > 0, "MD5 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::MD5, "Algorithm should be MD5");
}

// Test HMAC
fn test_hmac() {
    let key = "secret-key";
    let data = "message";
    let hmac = crypto::hmac_sha256(key, data);

    assert_true(hmac.to_hex().len() > 0, "HMAC should not be empty");
}

// Test hash comparison
fn test_hash_equality() {
    let data = "test data";
    let hash1 = crypto::sha256(data);
    let hash2 = crypto::sha256(data);

    assert_true(hash1.eq(&hash2), "Same input should produce same hash");
}

// Test random bytes generation
fn test_random_bytes() {
    let bytes1 = crypto::random_bytes(16);
    let bytes2 = crypto::random_bytes(16);

    assert_eq(bytes1.len(), 16, "Should generate 16 bytes");
    assert_eq(bytes2.len(), 16, "Should generate 16 bytes");

    // Random bytes should be different
    let mut different = false;
    for i in 0..16 {
        if bytes1[i] != bytes2[i] {
            different = true;
            break;
        }
    }
    assert_true(different, "Random bytes should be different");
}

// Test random integer generation
fn test_random_int() {
    let num1 = crypto::random_int(0, 100);
    let num2 = crypto::random_int(0, 100);

    assert_true(num1 >= 0 && num1 < 100, "Random int should be in range [0, 100)");
    assert_true(num2 >= 0 && num2 < 100, "Random int should be in range [0, 100)");
}

// Test random float generation
fn test_random_float() {
    let num1 = crypto::random_float();
    let num2 = crypto::random_float();

    assert_true(num1 >= 0.0 && num1 < 1.0, "Random float should be in range [0, 1)");
    assert_true(num2 >= 0.0 && num2 < 1.0, "Random float should be in range [0, 1)");
}

// Test random string generation
fn test_random_string() {
    let charset = "abc123";
    let str1 = crypto::random_string(10, charset);
    let str2 = crypto::random_string(10, charset);

    assert_eq(str1.len(), 10, "Random string should have specified length");
    assert_eq(str2.len(), 10, "Random string should have specified length");

    // All characters should be from charset
    for i in 0..str1.len() {
        let ch = str1.substring(i, i + 1);
        assert_true(charset.contains(ch), "Character should be from charset");
    }
}

// Test random alphanumeric string
fn test_random_alphanumeric() {
    let str = crypto::random_alphanumeric(20);

    assert_eq(str.len(), 20, "Should generate string of specified length");

    // Check if alphanumeric
    for i in 0..str.len() {
        let ch = str.substring(i, i + 1);
        let is_alpha = (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z");
        let is_digit = ch >= "0" && ch <= "9";
        assert_true(is_alpha || is_digit, "Should be alphanumeric");
    }
}

// Test random hex string
fn test_random_hex() {
    let hex = crypto::random_hex(32);

    assert_eq(hex.len(), 32, "Should generate hex string of specified length");

    // Check if hex characters
    for i in 0..hex.len() {
        let ch = hex.substring(i, i + 1);
        let is_hex = (ch >= "0" && ch <= "9") || (ch >= "a" && ch <= "f");
        assert_true(is_hex, "Should be hex character");
    }
}

// Test UUID v4 generation
fn test_uuid_v4() {
    let uuid1 = crypto::uuid_v4();
    let uuid2 = crypto::uuid_v4();

    // UUID format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    assert_eq(uuid1.len(), 36, "UUID should be 36 characters");
    assert_eq(uuid2.len(), 36, "UUID should be 36 characters");

    // Check hyphens at correct positions
    assert_eq(uuid1.substring(8, 9), "-", "Should have hyphen at position 8");
    assert_eq(uuid1.substring(13, 14), "-", "Should have hyphen at position 13");
    assert_eq(uuid1.substring(18, 19), "-", "Should have hyphen at position 18");
    assert_eq(uuid1.substring(23, 24), "-", "Should have hyphen at position 23");

    // Check version bit (4)
    assert_eq(uuid1.substring(14, 15), "4", "Should have version 4");

    // UUIDs should be different
    assert_ne(uuid1, uuid2, "UUIDs should be unique");
}

// Test base64 encoding
fn test_base64_encode() {
    let data = "Hello, World!";
    let encoded = crypto::base64_encode(data);

    assert_true(encoded.len() > 0, "Encoded string should not be empty");

    // Base64 encoded "Hello, World!" should be known value
    // SGVsbG8sIFdvcmxkIQ==
}

// Test base64 decoding
fn test_base64_decode() {
    let encoded = "SGVsbG8sIFdvcmxkIQ==";
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, "Hello, World!", "Should decode correctly");
        },
        Err(e) => {
            assert(false, "Failed to decode base64");
        },
    }
}

// Test base64 round-trip
fn test_base64_roundtrip() {
    let original = "The quick brown fox jumps over the lazy dog";
    let encoded = crypto::base64_encode(original);
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, original, "Round-trip should preserve data");
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test hex encoding
fn test_hex_encode() {
    let bytes = [72, 101, 108, 108, 111];  // "Hello" in ASCII
    let hex = crypto::hex_encode(&bytes);

    assert_eq(hex, "48656c6c6f", "Should encode to correct hex");
}

// Test hex decoding
fn test_hex_decode() {
    let hex = "48656c6c6f";
    let bytes_result = crypto::hex_decode(hex);

    match bytes_result {
        Ok(bytes) => {
            assert_eq(bytes.len(), 5, "Should decode to 5 bytes");
            assert_eq(bytes[0], 72, "First byte should be 72");
            assert_eq(bytes[1], 101, "Second byte should be 101");
        },
        Err(e) => {
            assert(false, "Failed to decode hex");
        },
    }
}

// Test hex round-trip
fn test_hex_roundtrip() {
    let original = [1, 2, 3, 4, 5, 255, 128, 64, 32, 16];
    let hex = crypto::hex_encode(&original);
    let decoded_result = crypto::hex_decode(hex);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded.len(), original.len(), "Should decode to same length");
            for i in 0..original.len() {
                assert_eq(decoded[i], original[i], "Bytes should match");
            }
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test password hashing
fn test_password_hashing() {
    let password = "my-secure-password";
    let hash = crypto::hash_password_auto(password);

    assert_eq(hash.algorithm, "PBKDF2-SHA256", "Algorithm should be PBKDF2-SHA256");
    assert_true(hash.iterations >= 100000, "Should use at least 100000 iterations");
    assert_true(hash.salt.len() > 0, "Should have salt");
    assert_true(hash.hash.len() > 0, "Should have hash");
}

// Test password verification
fn test_password_verification() {
    let password = "correct-password";
    let wrong_password = "wrong-password";

    let hash = crypto::hash_password_auto(password);

    // Correct password should verify
    assert_true(hash.verify(password), "Correct password should verify");

    // Wrong password should not verify
    assert_false(hash.verify(wrong_password), "Wrong password should not verify");
}

// Test password hash serialization
fn test_password_hash_serialization() {
    let password = "test-password";
    let hash = crypto::hash_password_auto(password);

    // Serialize to string
    let serialized = hash.to_string();
    assert_true(serialized.len() > 0, "Serialized string should not be empty");
    assert_true(serialized.starts_with("$"), "Should start with $");

    // Deserialize from string
    let parsed_result = PasswordHash::from_string(serialized);
    match parsed_result {
        Ok(parsed) => {
            assert_eq(parsed.algorithm, hash.algorithm, "Algorithm should match");
            assert_eq(parsed.iterations, hash.iterations, "Iterations should match");
            assert_eq(parsed.salt, hash.salt, "Salt should match");
            assert_eq(parsed.hash, hash.hash, "Hash should match");
        },
        Err(e) => {
            assert(false, "Failed to parse password hash");
        },
    }
}

// Test salt generation
fn test_salt_generation() {
    let salt1 = crypto::generate_salt(32);
    let salt2 = crypto::generate_salt(32);

    assert_eq(salt1.len(), 32, "Salt should have specified length");
    assert_eq(salt2.len(), 32, "Salt should have specified length");
    assert_ne(salt1, salt2, "Salts should be different");
}


// Test Crypto Module Implementation

// Test SHA-256 hashing
fn test_sha256() {
    let data = "Hello, World!";
    let hash = crypto::sha256(data);

    assert_true(hash.to_hex().len() > 0, "SHA-256 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA256, "Algorithm should be SHA256");
}

// Test SHA-1 hashing
fn test_sha1() {
    let data = "Hello, World!";
    let hash = crypto::sha1(data);

    assert_true(hash.to_hex().len() > 0, "SHA-1 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA1, "Algorithm should be SHA1");
}

// Test MD5 hashing
fn test_md5() {
    let data = "Hello, World!";
    let hash = crypto::md5(data);

    assert_true(hash.to_hex().len() > 0, "MD5 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::MD5, "Algorithm should be MD5");
}

// Test HMAC
fn test_hmac() {
    let key = "secret-key";
    let data = "message";
    let hmac = crypto::hmac_sha256(key, data);

    assert_true(hmac.to_hex().len() > 0, "HMAC should not be empty");
}

// Test hash comparison
fn test_hash_equality() {
    let data = "test data";
    let hash1 = crypto::sha256(data);
    let hash2 = crypto::sha256(data);

    assert_true(hash1.eq(&hash2), "Same input should produce same hash");
}

// Test random bytes generation
fn test_random_bytes() {
    let bytes1 = crypto::random_bytes(16);
    let bytes2 = crypto::random_bytes(16);

    assert_eq(bytes1.len(), 16, "Should generate 16 bytes");
    assert_eq(bytes2.len(), 16, "Should generate 16 bytes");

    // Random bytes should be different
    let mut different = false;
    for i in 0..16 {
        if bytes1[i] != bytes2[i] {
            different = true;
            break;
        }
    }
    assert_true(different, "Random bytes should be different");
}

// Test random integer generation
fn test_random_int() {
    let num1 = crypto::random_int(0, 100);
    let num2 = crypto::random_int(0, 100);

    assert_true(num1 >= 0 && num1 < 100, "Random int should be in range [0, 100)");
    assert_true(num2 >= 0 && num2 < 100, "Random int should be in range [0, 100)");
}

// Test random float generation
fn test_random_float() {
    let num1 = crypto::random_float();
    let num2 = crypto::random_float();

    assert_true(num1 >= 0.0 && num1 < 1.0, "Random float should be in range [0, 1)");
    assert_true(num2 >= 0.0 && num2 < 1.0, "Random float should be in range [0, 1)");
}

// Test random string generation
fn test_random_string() {
    let charset = "abc123";
    let str1 = crypto::random_string(10, charset);
    let str2 = crypto::random_string(10, charset);

    assert_eq(str1.len(), 10, "Random string should have specified length");
    assert_eq(str2.len(), 10, "Random string should have specified length");

    // All characters should be from charset
    for i in 0..str1.len() {
        let ch = str1.substring(i, i + 1);
        assert_true(charset.contains(ch), "Character should be from charset");
    }
}

// Test random alphanumeric string
fn test_random_alphanumeric() {
    let str = crypto::random_alphanumeric(20);

    assert_eq(str.len(), 20, "Should generate string of specified length");

    // Check if alphanumeric
    for i in 0..str.len() {
        let ch = str.substring(i, i + 1);
        let is_alpha = (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z");
        let is_digit = ch >= "0" && ch <= "9";
        assert_true(is_alpha || is_digit, "Should be alphanumeric");
    }
}

// Test random hex string
fn test_random_hex() {
    let hex = crypto::random_hex(32);

    assert_eq(hex.len(), 32, "Should generate hex string of specified length");

    // Check if hex characters
    for i in 0..hex.len() {
        let ch = hex.substring(i, i + 1);
        let is_hex = (ch >= "0" && ch <= "9") || (ch >= "a" && ch <= "f");
        assert_true(is_hex, "Should be hex character");
    }
}

// Test UUID v4 generation
fn test_uuid_v4() {
    let uuid1 = crypto::uuid_v4();
    let uuid2 = crypto::uuid_v4();

    // UUID format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    assert_eq(uuid1.len(), 36, "UUID should be 36 characters");
    assert_eq(uuid2.len(), 36, "UUID should be 36 characters");

    // Check hyphens at correct positions
    assert_eq(uuid1.substring(8, 9), "-", "Should have hyphen at position 8");
    assert_eq(uuid1.substring(13, 14), "-", "Should have hyphen at position 13");
    assert_eq(uuid1.substring(18, 19), "-", "Should have hyphen at position 18");
    assert_eq(uuid1.substring(23, 24), "-", "Should have hyphen at position 23");

    // Check version bit (4)
    assert_eq(uuid1.substring(14, 15), "4", "Should have version 4");

    // UUIDs should be different
    assert_ne(uuid1, uuid2, "UUIDs should be unique");
}

// Test base64 encoding
fn test_base64_encode() {
    let data = "Hello, World!";
    let encoded = crypto::base64_encode(data);

    assert_true(encoded.len() > 0, "Encoded string should not be empty");

    // Base64 encoded "Hello, World!" should be known value
    // SGVsbG8sIFdvcmxkIQ==
}

// Test base64 decoding
fn test_base64_decode() {
    let encoded = "SGVsbG8sIFdvcmxkIQ==";
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, "Hello, World!", "Should decode correctly");
        },
        Err(e) => {
            assert(false, "Failed to decode base64");
        },
    }
}

// Test base64 round-trip
fn test_base64_roundtrip() {
    let original = "The quick brown fox jumps over the lazy dog";
    let encoded = crypto::base64_encode(original);
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, original, "Round-trip should preserve data");
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test hex encoding
fn test_hex_encode() {
    let bytes = [72, 101, 108, 108, 111];  // "Hello" in ASCII
    let hex = crypto::hex_encode(&bytes);

    assert_eq(hex, "48656c6c6f", "Should encode to correct hex");
}

// Test hex decoding
fn test_hex_decode() {
    let hex = "48656c6c6f";
    let bytes_result = crypto::hex_decode(hex);

    match bytes_result {
        Ok(bytes) => {
            assert_eq(bytes.len(), 5, "Should decode to 5 bytes");
            assert_eq(bytes[0], 72, "First byte should be 72");
            assert_eq(bytes[1], 101, "Second byte should be 101");
        },
        Err(e) => {
            assert(false, "Failed to decode hex");
        },
    }
}

// Test hex round-trip
fn test_hex_roundtrip() {
    let original = [1, 2, 3, 4, 5, 255, 128, 64, 32, 16];
    let hex = crypto::hex_encode(&original);
    let decoded_result = crypto::hex_decode(hex);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded.len(), original.len(), "Should decode to same length");
            for i in 0..original.len() {
                assert_eq(decoded[i], original[i], "Bytes should match");
            }
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test password hashing
fn test_password_hashing() {
    let password = "my-secure-password";
    let hash = crypto::hash_password_auto(password);

    assert_eq(hash.algorithm, "PBKDF2-SHA256", "Algorithm should be PBKDF2-SHA256");
    assert_true(hash.iterations >= 100000, "Should use at least 100000 iterations");
    assert_true(hash.salt.len() > 0, "Should have salt");
    assert_true(hash.hash.len() > 0, "Should have hash");
}

// Test password verification
fn test_password_verification() {
    let password = "correct-password";
    let wrong_password = "wrong-password";

    let hash = crypto::hash_password_auto(password);

    // Correct password should verify
    assert_true(hash.verify(password), "Correct password should verify");

    // Wrong password should not verify
    assert_false(hash.verify(wrong_password), "Wrong password should not verify");
}

// Test password hash serialization
fn test_password_hash_serialization() {
    let password = "test-password";
    let hash = crypto::hash_password_auto(password);

    // Serialize to string
    let serialized = hash.to_string();
    assert_true(serialized.len() > 0, "Serialized string should not be empty");
    assert_true(serialized.starts_with("$"), "Should start with $");

    // Deserialize from string
    let parsed_result = PasswordHash::from_string(serialized);
    match parsed_result {
        Ok(parsed) => {
            assert_eq(parsed.algorithm, hash.algorithm, "Algorithm should match");
            assert_eq(parsed.iterations, hash.iterations, "Iterations should match");
            assert_eq(parsed.salt, hash.salt, "Salt should match");
            assert_eq(parsed.hash, hash.hash, "Hash should match");
        },
        Err(e) => {
            assert(false, "Failed to parse password hash");
        },
    }
}

// Test salt generation
fn test_salt_generation() {
    let salt1 = crypto::generate_salt(32);
    let salt2 = crypto::generate_salt(32);

    assert_eq(salt1.len(), 32, "Salt should have specified length");
    assert_eq(salt2.len(), 32, "Salt should have specified length");
    assert_ne(salt1, salt2, "Salts should be different");
}


// Test Crypto Module Implementation

// Test SHA-256 hashing
fn test_sha256() {
    let data = "Hello, World!";
    let hash = crypto::sha256(data);

    assert_true(hash.to_hex().len() > 0, "SHA-256 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA256, "Algorithm should be SHA256");
}

// Test SHA-1 hashing
fn test_sha1() {
    let data = "Hello, World!";
    let hash = crypto::sha1(data);

    assert_true(hash.to_hex().len() > 0, "SHA-1 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA1, "Algorithm should be SHA1");
}

// Test MD5 hashing
fn test_md5() {
    let data = "Hello, World!";
    let hash = crypto::md5(data);

    assert_true(hash.to_hex().len() > 0, "MD5 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::MD5, "Algorithm should be MD5");
}

// Test HMAC
fn test_hmac() {
    let key = "secret-key";
    let data = "message";
    let hmac = crypto::hmac_sha256(key, data);

    assert_true(hmac.to_hex().len() > 0, "HMAC should not be empty");
}

// Test hash comparison
fn test_hash_equality() {
    let data = "test data";
    let hash1 = crypto::sha256(data);
    let hash2 = crypto::sha256(data);

    assert_true(hash1.eq(&hash2), "Same input should produce same hash");
}

// Test random bytes generation
fn test_random_bytes() {
    let bytes1 = crypto::random_bytes(16);
    let bytes2 = crypto::random_bytes(16);

    assert_eq(bytes1.len(), 16, "Should generate 16 bytes");
    assert_eq(bytes2.len(), 16, "Should generate 16 bytes");

    // Random bytes should be different
    let mut different = false;
    for i in 0..16 {
        if bytes1[i] != bytes2[i] {
            different = true;
            break;
        }
    }
    assert_true(different, "Random bytes should be different");
}

// Test random integer generation
fn test_random_int() {
    let num1 = crypto::random_int(0, 100);
    let num2 = crypto::random_int(0, 100);

    assert_true(num1 >= 0 && num1 < 100, "Random int should be in range [0, 100)");
    assert_true(num2 >= 0 && num2 < 100, "Random int should be in range [0, 100)");
}

// Test random float generation
fn test_random_float() {
    let num1 = crypto::random_float();
    let num2 = crypto::random_float();

    assert_true(num1 >= 0.0 && num1 < 1.0, "Random float should be in range [0, 1)");
    assert_true(num2 >= 0.0 && num2 < 1.0, "Random float should be in range [0, 1)");
}

// Test random string generation
fn test_random_string() {
    let charset = "abc123";
    let str1 = crypto::random_string(10, charset);
    let str2 = crypto::random_string(10, charset);

    assert_eq(str1.len(), 10, "Random string should have specified length");
    assert_eq(str2.len(), 10, "Random string should have specified length");

    // All characters should be from charset
    for i in 0..str1.len() {
        let ch = str1.substring(i, i + 1);
        assert_true(charset.contains(ch), "Character should be from charset");
    }
}

// Test random alphanumeric string
fn test_random_alphanumeric() {
    let str = crypto::random_alphanumeric(20);

    assert_eq(str.len(), 20, "Should generate string of specified length");

    // Check if alphanumeric
    for i in 0..str.len() {
        let ch = str.substring(i, i + 1);
        let is_alpha = (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z");
        let is_digit = ch >= "0" && ch <= "9";
        assert_true(is_alpha || is_digit, "Should be alphanumeric");
    }
}

// Test random hex string
fn test_random_hex() {
    let hex = crypto::random_hex(32);

    assert_eq(hex.len(), 32, "Should generate hex string of specified length");

    // Check if hex characters
    for i in 0..hex.len() {
        let ch = hex.substring(i, i + 1);
        let is_hex = (ch >= "0" && ch <= "9") || (ch >= "a" && ch <= "f");
        assert_true(is_hex, "Should be hex character");
    }
}

// Test UUID v4 generation
fn test_uuid_v4() {
    let uuid1 = crypto::uuid_v4();
    let uuid2 = crypto::uuid_v4();

    // UUID format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    assert_eq(uuid1.len(), 36, "UUID should be 36 characters");
    assert_eq(uuid2.len(), 36, "UUID should be 36 characters");

    // Check hyphens at correct positions
    assert_eq(uuid1.substring(8, 9), "-", "Should have hyphen at position 8");
    assert_eq(uuid1.substring(13, 14), "-", "Should have hyphen at position 13");
    assert_eq(uuid1.substring(18, 19), "-", "Should have hyphen at position 18");
    assert_eq(uuid1.substring(23, 24), "-", "Should have hyphen at position 23");

    // Check version bit (4)
    assert_eq(uuid1.substring(14, 15), "4", "Should have version 4");

    // UUIDs should be different
    assert_ne(uuid1, uuid2, "UUIDs should be unique");
}

// Test base64 encoding
fn test_base64_encode() {
    let data = "Hello, World!";
    let encoded = crypto::base64_encode(data);

    assert_true(encoded.len() > 0, "Encoded string should not be empty");

    // Base64 encoded "Hello, World!" should be known value
    // SGVsbG8sIFdvcmxkIQ==
}

// Test base64 decoding
fn test_base64_decode() {
    let encoded = "SGVsbG8sIFdvcmxkIQ==";
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, "Hello, World!", "Should decode correctly");
        },
        Err(e) => {
            assert(false, "Failed to decode base64");
        },
    }
}

// Test base64 round-trip
fn test_base64_roundtrip() {
    let original = "The quick brown fox jumps over the lazy dog";
    let encoded = crypto::base64_encode(original);
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, original, "Round-trip should preserve data");
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test hex encoding
fn test_hex_encode() {
    let bytes = [72, 101, 108, 108, 111];  // "Hello" in ASCII
    let hex = crypto::hex_encode(&bytes);

    assert_eq(hex, "48656c6c6f", "Should encode to correct hex");
}

// Test hex decoding
fn test_hex_decode() {
    let hex = "48656c6c6f";
    let bytes_result = crypto::hex_decode(hex);

    match bytes_result {
        Ok(bytes) => {
            assert_eq(bytes.len(), 5, "Should decode to 5 bytes");
            assert_eq(bytes[0], 72, "First byte should be 72");
            assert_eq(bytes[1], 101, "Second byte should be 101");
        },
        Err(e) => {
            assert(false, "Failed to decode hex");
        },
    }
}

// Test hex round-trip
fn test_hex_roundtrip() {
    let original = [1, 2, 3, 4, 5, 255, 128, 64, 32, 16];
    let hex = crypto::hex_encode(&original);
    let decoded_result = crypto::hex_decode(hex);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded.len(), original.len(), "Should decode to same length");
            for i in 0..original.len() {
                assert_eq(decoded[i], original[i], "Bytes should match");
            }
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test password hashing
fn test_password_hashing() {
    let password = "my-secure-password";
    let hash = crypto::hash_password_auto(password);

    assert_eq(hash.algorithm, "PBKDF2-SHA256", "Algorithm should be PBKDF2-SHA256");
    assert_true(hash.iterations >= 100000, "Should use at least 100000 iterations");
    assert_true(hash.salt.len() > 0, "Should have salt");
    assert_true(hash.hash.len() > 0, "Should have hash");
}

// Test password verification
fn test_password_verification() {
    let password = "correct-password";
    let wrong_password = "wrong-password";

    let hash = crypto::hash_password_auto(password);

    // Correct password should verify
    assert_true(hash.verify(password), "Correct password should verify");

    // Wrong password should not verify
    assert_false(hash.verify(wrong_password), "Wrong password should not verify");
}

// Test password hash serialization
fn test_password_hash_serialization() {
    let password = "test-password";
    let hash = crypto::hash_password_auto(password);

    // Serialize to string
    let serialized = hash.to_string();
    assert_true(serialized.len() > 0, "Serialized string should not be empty");
    assert_true(serialized.starts_with("$"), "Should start with $");

    // Deserialize from string
    let parsed_result = PasswordHash::from_string(serialized);
    match parsed_result {
        Ok(parsed) => {
            assert_eq(parsed.algorithm, hash.algorithm, "Algorithm should match");
            assert_eq(parsed.iterations, hash.iterations, "Iterations should match");
            assert_eq(parsed.salt, hash.salt, "Salt should match");
            assert_eq(parsed.hash, hash.hash, "Hash should match");
        },
        Err(e) => {
            assert(false, "Failed to parse password hash");
        },
    }
}

// Test salt generation
fn test_salt_generation() {
    let salt1 = crypto::generate_salt(32);
    let salt2 = crypto::generate_salt(32);

    assert_eq(salt1.len(), 32, "Salt should have specified length");
    assert_eq(salt2.len(), 32, "Salt should have specified length");
    assert_ne(salt1, salt2, "Salts should be different");
}


// Test Crypto Module Implementation

// Test SHA-256 hashing
fn test_sha256() {
    let data = "Hello, World!";
    let hash = crypto::sha256(data);

    assert_true(hash.to_hex().len() > 0, "SHA-256 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA256, "Algorithm should be SHA256");
}

// Test SHA-1 hashing
fn test_sha1() {
    let data = "Hello, World!";
    let hash = crypto::sha1(data);

    assert_true(hash.to_hex().len() > 0, "SHA-1 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA1, "Algorithm should be SHA1");
}

// Test MD5 hashing
fn test_md5() {
    let data = "Hello, World!";
    let hash = crypto::md5(data);

    assert_true(hash.to_hex().len() > 0, "MD5 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::MD5, "Algorithm should be MD5");
}

// Test HMAC
fn test_hmac() {
    let key = "secret-key";
    let data = "message";
    let hmac = crypto::hmac_sha256(key, data);

    assert_true(hmac.to_hex().len() > 0, "HMAC should not be empty");
}

// Test hash comparison
fn test_hash_equality() {
    let data = "test data";
    let hash1 = crypto::sha256(data);
    let hash2 = crypto::sha256(data);

    assert_true(hash1.eq(&hash2), "Same input should produce same hash");
}

// Test random bytes generation
fn test_random_bytes() {
    let bytes1 = crypto::random_bytes(16);
    let bytes2 = crypto::random_bytes(16);

    assert_eq(bytes1.len(), 16, "Should generate 16 bytes");
    assert_eq(bytes2.len(), 16, "Should generate 16 bytes");

    // Random bytes should be different
    let mut different = false;
    for i in 0..16 {
        if bytes1[i] != bytes2[i] {
            different = true;
            break;
        }
    }
    assert_true(different, "Random bytes should be different");
}

// Test random integer generation
fn test_random_int() {
    let num1 = crypto::random_int(0, 100);
    let num2 = crypto::random_int(0, 100);

    assert_true(num1 >= 0 && num1 < 100, "Random int should be in range [0, 100)");
    assert_true(num2 >= 0 && num2 < 100, "Random int should be in range [0, 100)");
}

// Test random float generation
fn test_random_float() {
    let num1 = crypto::random_float();
    let num2 = crypto::random_float();

    assert_true(num1 >= 0.0 && num1 < 1.0, "Random float should be in range [0, 1)");
    assert_true(num2 >= 0.0 && num2 < 1.0, "Random float should be in range [0, 1)");
}

// Test random string generation
fn test_random_string() {
    let charset = "abc123";
    let str1 = crypto::random_string(10, charset);
    let str2 = crypto::random_string(10, charset);

    assert_eq(str1.len(), 10, "Random string should have specified length");
    assert_eq(str2.len(), 10, "Random string should have specified length");

    // All characters should be from charset
    for i in 0..str1.len() {
        let ch = str1.substring(i, i + 1);
        assert_true(charset.contains(ch), "Character should be from charset");
    }
}

// Test random alphanumeric string
fn test_random_alphanumeric() {
    let str = crypto::random_alphanumeric(20);

    assert_eq(str.len(), 20, "Should generate string of specified length");

    // Check if alphanumeric
    for i in 0..str.len() {
        let ch = str.substring(i, i + 1);
        let is_alpha = (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z");
        let is_digit = ch >= "0" && ch <= "9";
        assert_true(is_alpha || is_digit, "Should be alphanumeric");
    }
}

// Test random hex string
fn test_random_hex() {
    let hex = crypto::random_hex(32);

    assert_eq(hex.len(), 32, "Should generate hex string of specified length");

    // Check if hex characters
    for i in 0..hex.len() {
        let ch = hex.substring(i, i + 1);
        let is_hex = (ch >= "0" && ch <= "9") || (ch >= "a" && ch <= "f");
        assert_true(is_hex, "Should be hex character");
    }
}

// Test UUID v4 generation
fn test_uuid_v4() {
    let uuid1 = crypto::uuid_v4();
    let uuid2 = crypto::uuid_v4();

    // UUID format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    assert_eq(uuid1.len(), 36, "UUID should be 36 characters");
    assert_eq(uuid2.len(), 36, "UUID should be 36 characters");

    // Check hyphens at correct positions
    assert_eq(uuid1.substring(8, 9), "-", "Should have hyphen at position 8");
    assert_eq(uuid1.substring(13, 14), "-", "Should have hyphen at position 13");
    assert_eq(uuid1.substring(18, 19), "-", "Should have hyphen at position 18");
    assert_eq(uuid1.substring(23, 24), "-", "Should have hyphen at position 23");

    // Check version bit (4)
    assert_eq(uuid1.substring(14, 15), "4", "Should have version 4");

    // UUIDs should be different
    assert_ne(uuid1, uuid2, "UUIDs should be unique");
}

// Test base64 encoding
fn test_base64_encode() {
    let data = "Hello, World!";
    let encoded = crypto::base64_encode(data);

    assert_true(encoded.len() > 0, "Encoded string should not be empty");

    // Base64 encoded "Hello, World!" should be known value
    // SGVsbG8sIFdvcmxkIQ==
}

// Test base64 decoding
fn test_base64_decode() {
    let encoded = "SGVsbG8sIFdvcmxkIQ==";
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, "Hello, World!", "Should decode correctly");
        },
        Err(e) => {
            assert(false, "Failed to decode base64");
        },
    }
}

// Test base64 round-trip
fn test_base64_roundtrip() {
    let original = "The quick brown fox jumps over the lazy dog";
    let encoded = crypto::base64_encode(original);
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, original, "Round-trip should preserve data");
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test hex encoding
fn test_hex_encode() {
    let bytes = [72, 101, 108, 108, 111];  // "Hello" in ASCII
    let hex = crypto::hex_encode(&bytes);

    assert_eq(hex, "48656c6c6f", "Should encode to correct hex");
}

// Test hex decoding
fn test_hex_decode() {
    let hex = "48656c6c6f";
    let bytes_result = crypto::hex_decode(hex);

    match bytes_result {
        Ok(bytes) => {
            assert_eq(bytes.len(), 5, "Should decode to 5 bytes");
            assert_eq(bytes[0], 72, "First byte should be 72");
            assert_eq(bytes[1], 101, "Second byte should be 101");
        },
        Err(e) => {
            assert(false, "Failed to decode hex");
        },
    }
}

// Test hex round-trip
fn test_hex_roundtrip() {
    let original = [1, 2, 3, 4, 5, 255, 128, 64, 32, 16];
    let hex = crypto::hex_encode(&original);
    let decoded_result = crypto::hex_decode(hex);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded.len(), original.len(), "Should decode to same length");
            for i in 0..original.len() {
                assert_eq(decoded[i], original[i], "Bytes should match");
            }
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test password hashing
fn test_password_hashing() {
    let password = "my-secure-password";
    let hash = crypto::hash_password_auto(password);

    assert_eq(hash.algorithm, "PBKDF2-SHA256", "Algorithm should be PBKDF2-SHA256");
    assert_true(hash.iterations >= 100000, "Should use at least 100000 iterations");
    assert_true(hash.salt.len() > 0, "Should have salt");
    assert_true(hash.hash.len() > 0, "Should have hash");
}

// Test password verification
fn test_password_verification() {
    let password = "correct-password";
    let wrong_password = "wrong-password";

    let hash = crypto::hash_password_auto(password);

    // Correct password should verify
    assert_true(hash.verify(password), "Correct password should verify");

    // Wrong password should not verify
    assert_false(hash.verify(wrong_password), "Wrong password should not verify");
}

// Test password hash serialization
fn test_password_hash_serialization() {
    let password = "test-password";
    let hash = crypto::hash_password_auto(password);

    // Serialize to string
    let serialized = hash.to_string();
    assert_true(serialized.len() > 0, "Serialized string should not be empty");
    assert_true(serialized.starts_with("$"), "Should start with $");

    // Deserialize from string
    let parsed_result = PasswordHash::from_string(serialized);
    match parsed_result {
        Ok(parsed) => {
            assert_eq(parsed.algorithm, hash.algorithm, "Algorithm should match");
            assert_eq(parsed.iterations, hash.iterations, "Iterations should match");
            assert_eq(parsed.salt, hash.salt, "Salt should match");
            assert_eq(parsed.hash, hash.hash, "Hash should match");
        },
        Err(e) => {
            assert(false, "Failed to parse password hash");
        },
    }
}

// Test salt generation
fn test_salt_generation() {
    let salt1 = crypto::generate_salt(32);
    let salt2 = crypto::generate_salt(32);

    assert_eq(salt1.len(), 32, "Salt should have specified length");
    assert_eq(salt2.len(), 32, "Salt should have specified length");
    assert_ne(salt1, salt2, "Salts should be different");
}


// Test Crypto Module Implementation

// Test SHA-256 hashing
fn test_sha256() {
    let data = "Hello, World!";
    let hash = crypto::sha256(data);

    assert_true(hash.to_hex().len() > 0, "SHA-256 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA256, "Algorithm should be SHA256");
}

// Test SHA-1 hashing
fn test_sha1() {
    let data = "Hello, World!";
    let hash = crypto::sha1(data);

    assert_true(hash.to_hex().len() > 0, "SHA-1 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA1, "Algorithm should be SHA1");
}

// Test MD5 hashing
fn test_md5() {
    let data = "Hello, World!";
    let hash = crypto::md5(data);

    assert_true(hash.to_hex().len() > 0, "MD5 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::MD5, "Algorithm should be MD5");
}

// Test HMAC
fn test_hmac() {
    let key = "secret-key";
    let data = "message";
    let hmac = crypto::hmac_sha256(key, data);

    assert_true(hmac.to_hex().len() > 0, "HMAC should not be empty");
}

// Test hash comparison
fn test_hash_equality() {
    let data = "test data";
    let hash1 = crypto::sha256(data);
    let hash2 = crypto::sha256(data);

    assert_true(hash1.eq(&hash2), "Same input should produce same hash");
}

// Test random bytes generation
fn test_random_bytes() {
    let bytes1 = crypto::random_bytes(16);
    let bytes2 = crypto::random_bytes(16);

    assert_eq(bytes1.len(), 16, "Should generate 16 bytes");
    assert_eq(bytes2.len(), 16, "Should generate 16 bytes");

    // Random bytes should be different
    let mut different = false;
    for i in 0..16 {
        if bytes1[i] != bytes2[i] {
            different = true;
            break;
        }
    }
    assert_true(different, "Random bytes should be different");
}

// Test random integer generation
fn test_random_int() {
    let num1 = crypto::random_int(0, 100);
    let num2 = crypto::random_int(0, 100);

    assert_true(num1 >= 0 && num1 < 100, "Random int should be in range [0, 100)");
    assert_true(num2 >= 0 && num2 < 100, "Random int should be in range [0, 100)");
}

// Test random float generation
fn test_random_float() {
    let num1 = crypto::random_float();
    let num2 = crypto::random_float();

    assert_true(num1 >= 0.0 && num1 < 1.0, "Random float should be in range [0, 1)");
    assert_true(num2 >= 0.0 && num2 < 1.0, "Random float should be in range [0, 1)");
}

// Test random string generation
fn test_random_string() {
    let charset = "abc123";
    let str1 = crypto::random_string(10, charset);
    let str2 = crypto::random_string(10, charset);

    assert_eq(str1.len(), 10, "Random string should have specified length");
    assert_eq(str2.len(), 10, "Random string should have specified length");

    // All characters should be from charset
    for i in 0..str1.len() {
        let ch = str1.substring(i, i + 1);
        assert_true(charset.contains(ch), "Character should be from charset");
    }
}

// Test random alphanumeric string
fn test_random_alphanumeric() {
    let str = crypto::random_alphanumeric(20);

    assert_eq(str.len(), 20, "Should generate string of specified length");

    // Check if alphanumeric
    for i in 0..str.len() {
        let ch = str.substring(i, i + 1);
        let is_alpha = (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z");
        let is_digit = ch >= "0" && ch <= "9";
        assert_true(is_alpha || is_digit, "Should be alphanumeric");
    }
}

// Test random hex string
fn test_random_hex() {
    let hex = crypto::random_hex(32);

    assert_eq(hex.len(), 32, "Should generate hex string of specified length");

    // Check if hex characters
    for i in 0..hex.len() {
        let ch = hex.substring(i, i + 1);
        let is_hex = (ch >= "0" && ch <= "9") || (ch >= "a" && ch <= "f");
        assert_true(is_hex, "Should be hex character");
    }
}

// Test UUID v4 generation
fn test_uuid_v4() {
    let uuid1 = crypto::uuid_v4();
    let uuid2 = crypto::uuid_v4();

    // UUID format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    assert_eq(uuid1.len(), 36, "UUID should be 36 characters");
    assert_eq(uuid2.len(), 36, "UUID should be 36 characters");

    // Check hyphens at correct positions
    assert_eq(uuid1.substring(8, 9), "-", "Should have hyphen at position 8");
    assert_eq(uuid1.substring(13, 14), "-", "Should have hyphen at position 13");
    assert_eq(uuid1.substring(18, 19), "-", "Should have hyphen at position 18");
    assert_eq(uuid1.substring(23, 24), "-", "Should have hyphen at position 23");

    // Check version bit (4)
    assert_eq(uuid1.substring(14, 15), "4", "Should have version 4");

    // UUIDs should be different
    assert_ne(uuid1, uuid2, "UUIDs should be unique");
}

// Test base64 encoding
fn test_base64_encode() {
    let data = "Hello, World!";
    let encoded = crypto::base64_encode(data);

    assert_true(encoded.len() > 0, "Encoded string should not be empty");

    // Base64 encoded "Hello, World!" should be known value
    // SGVsbG8sIFdvcmxkIQ==
}

// Test base64 decoding
fn test_base64_decode() {
    let encoded = "SGVsbG8sIFdvcmxkIQ==";
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, "Hello, World!", "Should decode correctly");
        },
        Err(e) => {
            assert(false, "Failed to decode base64");
        },
    }
}

// Test base64 round-trip
fn test_base64_roundtrip() {
    let original = "The quick brown fox jumps over the lazy dog";
    let encoded = crypto::base64_encode(original);
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, original, "Round-trip should preserve data");
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test hex encoding
fn test_hex_encode() {
    let bytes = [72, 101, 108, 108, 111];  // "Hello" in ASCII
    let hex = crypto::hex_encode(&bytes);

    assert_eq(hex, "48656c6c6f", "Should encode to correct hex");
}

// Test hex decoding
fn test_hex_decode() {
    let hex = "48656c6c6f";
    let bytes_result = crypto::hex_decode(hex);

    match bytes_result {
        Ok(bytes) => {
            assert_eq(bytes.len(), 5, "Should decode to 5 bytes");
            assert_eq(bytes[0], 72, "First byte should be 72");
            assert_eq(bytes[1], 101, "Second byte should be 101");
        },
        Err(e) => {
            assert(false, "Failed to decode hex");
        },
    }
}

// Test hex round-trip
fn test_hex_roundtrip() {
    let original = [1, 2, 3, 4, 5, 255, 128, 64, 32, 16];
    let hex = crypto::hex_encode(&original);
    let decoded_result = crypto::hex_decode(hex);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded.len(), original.len(), "Should decode to same length");
            for i in 0..original.len() {
                assert_eq(decoded[i], original[i], "Bytes should match");
            }
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test password hashing
fn test_password_hashing() {
    let password = "my-secure-password";
    let hash = crypto::hash_password_auto(password);

    assert_eq(hash.algorithm, "PBKDF2-SHA256", "Algorithm should be PBKDF2-SHA256");
    assert_true(hash.iterations >= 100000, "Should use at least 100000 iterations");
    assert_true(hash.salt.len() > 0, "Should have salt");
    assert_true(hash.hash.len() > 0, "Should have hash");
}

// Test password verification
fn test_password_verification() {
    let password = "correct-password";
    let wrong_password = "wrong-password";

    let hash = crypto::hash_password_auto(password);

    // Correct password should verify
    assert_true(hash.verify(password), "Correct password should verify");

    // Wrong password should not verify
    assert_false(hash.verify(wrong_password), "Wrong password should not verify");
}

// Test password hash serialization
fn test_password_hash_serialization() {
    let password = "test-password";
    let hash = crypto::hash_password_auto(password);

    // Serialize to string
    let serialized = hash.to_string();
    assert_true(serialized.len() > 0, "Serialized string should not be empty");
    assert_true(serialized.starts_with("$"), "Should start with $");

    // Deserialize from string
    let parsed_result = PasswordHash::from_string(serialized);
    match parsed_result {
        Ok(parsed) => {
            assert_eq(parsed.algorithm, hash.algorithm, "Algorithm should match");
            assert_eq(parsed.iterations, hash.iterations, "Iterations should match");
            assert_eq(parsed.salt, hash.salt, "Salt should match");
            assert_eq(parsed.hash, hash.hash, "Hash should match");
        },
        Err(e) => {
            assert(false, "Failed to parse password hash");
        },
    }
}

// Test salt generation
fn test_salt_generation() {
    let salt1 = crypto::generate_salt(32);
    let salt2 = crypto::generate_salt(32);

    assert_eq(salt1.len(), 32, "Salt should have specified length");
    assert_eq(salt2.len(), 32, "Salt should have specified length");
    assert_ne(salt1, salt2, "Salts should be different");
}


// Test Crypto Module Implementation

// Test SHA-256 hashing
fn test_sha256() {
    let data = "Hello, World!";
    let hash = crypto::sha256(data);

    assert_true(hash.to_hex().len() > 0, "SHA-256 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA256, "Algorithm should be SHA256");
}

// Test SHA-1 hashing
fn test_sha1() {
    let data = "Hello, World!";
    let hash = crypto::sha1(data);

    assert_true(hash.to_hex().len() > 0, "SHA-1 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA1, "Algorithm should be SHA1");
}

// Test MD5 hashing
fn test_md5() {
    let data = "Hello, World!";
    let hash = crypto::md5(data);

    assert_true(hash.to_hex().len() > 0, "MD5 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::MD5, "Algorithm should be MD5");
}

// Test HMAC
fn test_hmac() {
    let key = "secret-key";
    let data = "message";
    let hmac = crypto::hmac_sha256(key, data);

    assert_true(hmac.to_hex().len() > 0, "HMAC should not be empty");
}

// Test hash comparison
fn test_hash_equality() {
    let data = "test data";
    let hash1 = crypto::sha256(data);
    let hash2 = crypto::sha256(data);

    assert_true(hash1.eq(&hash2), "Same input should produce same hash");
}

// Test random bytes generation
fn test_random_bytes() {
    let bytes1 = crypto::random_bytes(16);
    let bytes2 = crypto::random_bytes(16);

    assert_eq(bytes1.len(), 16, "Should generate 16 bytes");
    assert_eq(bytes2.len(), 16, "Should generate 16 bytes");

    // Random bytes should be different
    let mut different = false;
    for i in 0..16 {
        if bytes1[i] != bytes2[i] {
            different = true;
            break;
        }
    }
    assert_true(different, "Random bytes should be different");
}

// Test random integer generation
fn test_random_int() {
    let num1 = crypto::random_int(0, 100);
    let num2 = crypto::random_int(0, 100);

    assert_true(num1 >= 0 && num1 < 100, "Random int should be in range [0, 100)");
    assert_true(num2 >= 0 && num2 < 100, "Random int should be in range [0, 100)");
}

// Test random float generation
fn test_random_float() {
    let num1 = crypto::random_float();
    let num2 = crypto::random_float();

    assert_true(num1 >= 0.0 && num1 < 1.0, "Random float should be in range [0, 1)");
    assert_true(num2 >= 0.0 && num2 < 1.0, "Random float should be in range [0, 1)");
}

// Test random string generation
fn test_random_string() {
    let charset = "abc123";
    let str1 = crypto::random_string(10, charset);
    let str2 = crypto::random_string(10, charset);

    assert_eq(str1.len(), 10, "Random string should have specified length");
    assert_eq(str2.len(), 10, "Random string should have specified length");

    // All characters should be from charset
    for i in 0..str1.len() {
        let ch = str1.substring(i, i + 1);
        assert_true(charset.contains(ch), "Character should be from charset");
    }
}

// Test random alphanumeric string
fn test_random_alphanumeric() {
    let str = crypto::random_alphanumeric(20);

    assert_eq(str.len(), 20, "Should generate string of specified length");

    // Check if alphanumeric
    for i in 0..str.len() {
        let ch = str.substring(i, i + 1);
        let is_alpha = (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z");
        let is_digit = ch >= "0" && ch <= "9";
        assert_true(is_alpha || is_digit, "Should be alphanumeric");
    }
}

// Test random hex string
fn test_random_hex() {
    let hex = crypto::random_hex(32);

    assert_eq(hex.len(), 32, "Should generate hex string of specified length");

    // Check if hex characters
    for i in 0..hex.len() {
        let ch = hex.substring(i, i + 1);
        let is_hex = (ch >= "0" && ch <= "9") || (ch >= "a" && ch <= "f");
        assert_true(is_hex, "Should be hex character");
    }
}

// Test UUID v4 generation
fn test_uuid_v4() {
    let uuid1 = crypto::uuid_v4();
    let uuid2 = crypto::uuid_v4();

    // UUID format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    assert_eq(uuid1.len(), 36, "UUID should be 36 characters");
    assert_eq(uuid2.len(), 36, "UUID should be 36 characters");

    // Check hyphens at correct positions
    assert_eq(uuid1.substring(8, 9), "-", "Should have hyphen at position 8");
    assert_eq(uuid1.substring(13, 14), "-", "Should have hyphen at position 13");
    assert_eq(uuid1.substring(18, 19), "-", "Should have hyphen at position 18");
    assert_eq(uuid1.substring(23, 24), "-", "Should have hyphen at position 23");

    // Check version bit (4)
    assert_eq(uuid1.substring(14, 15), "4", "Should have version 4");

    // UUIDs should be different
    assert_ne(uuid1, uuid2, "UUIDs should be unique");
}

// Test base64 encoding
fn test_base64_encode() {
    let data = "Hello, World!";
    let encoded = crypto::base64_encode(data);

    assert_true(encoded.len() > 0, "Encoded string should not be empty");

    // Base64 encoded "Hello, World!" should be known value
    // SGVsbG8sIFdvcmxkIQ==
}

// Test base64 decoding
fn test_base64_decode() {
    let encoded = "SGVsbG8sIFdvcmxkIQ==";
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, "Hello, World!", "Should decode correctly");
        },
        Err(e) => {
            assert(false, "Failed to decode base64");
        },
    }
}

// Test base64 round-trip
fn test_base64_roundtrip() {
    let original = "The quick brown fox jumps over the lazy dog";
    let encoded = crypto::base64_encode(original);
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, original, "Round-trip should preserve data");
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test hex encoding
fn test_hex_encode() {
    let bytes = [72, 101, 108, 108, 111];  // "Hello" in ASCII
    let hex = crypto::hex_encode(&bytes);

    assert_eq(hex, "48656c6c6f", "Should encode to correct hex");
}

// Test hex decoding
fn test_hex_decode() {
    let hex = "48656c6c6f";
    let bytes_result = crypto::hex_decode(hex);

    match bytes_result {
        Ok(bytes) => {
            assert_eq(bytes.len(), 5, "Should decode to 5 bytes");
            assert_eq(bytes[0], 72, "First byte should be 72");
            assert_eq(bytes[1], 101, "Second byte should be 101");
        },
        Err(e) => {
            assert(false, "Failed to decode hex");
        },
    }
}

// Test hex round-trip
fn test_hex_roundtrip() {
    let original = [1, 2, 3, 4, 5, 255, 128, 64, 32, 16];
    let hex = crypto::hex_encode(&original);
    let decoded_result = crypto::hex_decode(hex);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded.len(), original.len(), "Should decode to same length");
            for i in 0..original.len() {
                assert_eq(decoded[i], original[i], "Bytes should match");
            }
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test password hashing
fn test_password_hashing() {
    let password = "my-secure-password";
    let hash = crypto::hash_password_auto(password);

    assert_eq(hash.algorithm, "PBKDF2-SHA256", "Algorithm should be PBKDF2-SHA256");
    assert_true(hash.iterations >= 100000, "Should use at least 100000 iterations");
    assert_true(hash.salt.len() > 0, "Should have salt");
    assert_true(hash.hash.len() > 0, "Should have hash");
}

// Test password verification
fn test_password_verification() {
    let password = "correct-password";
    let wrong_password = "wrong-password";

    let hash = crypto::hash_password_auto(password);

    // Correct password should verify
    assert_true(hash.verify(password), "Correct password should verify");

    // Wrong password should not verify
    assert_false(hash.verify(wrong_password), "Wrong password should not verify");
}

// Test password hash serialization
fn test_password_hash_serialization() {
    let password = "test-password";
    let hash = crypto::hash_password_auto(password);

    // Serialize to string
    let serialized = hash.to_string();
    assert_true(serialized.len() > 0, "Serialized string should not be empty");
    assert_true(serialized.starts_with("$"), "Should start with $");

    // Deserialize from string
    let parsed_result = PasswordHash::from_string(serialized);
    match parsed_result {
        Ok(parsed) => {
            assert_eq(parsed.algorithm, hash.algorithm, "Algorithm should match");
            assert_eq(parsed.iterations, hash.iterations, "Iterations should match");
            assert_eq(parsed.salt, hash.salt, "Salt should match");
            assert_eq(parsed.hash, hash.hash, "Hash should match");
        },
        Err(e) => {
            assert(false, "Failed to parse password hash");
        },
    }
}

// Test salt generation
fn test_salt_generation() {
    let salt1 = crypto::generate_salt(32);
    let salt2 = crypto::generate_salt(32);

    assert_eq(salt1.len(), 32, "Salt should have specified length");
    assert_eq(salt2.len(), 32, "Salt should have specified length");
    assert_ne(salt1, salt2, "Salts should be different");
}


// Test Crypto Module Implementation

// Test SHA-256 hashing
fn test_sha256() {
    let data = "Hello, World!";
    let hash = crypto::sha256(data);

    assert_true(hash.to_hex().len() > 0, "SHA-256 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA256, "Algorithm should be SHA256");
}

// Test SHA-1 hashing
fn test_sha1() {
    let data = "Hello, World!";
    let hash = crypto::sha1(data);

    assert_true(hash.to_hex().len() > 0, "SHA-1 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA1, "Algorithm should be SHA1");
}

// Test MD5 hashing
fn test_md5() {
    let data = "Hello, World!";
    let hash = crypto::md5(data);

    assert_true(hash.to_hex().len() > 0, "MD5 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::MD5, "Algorithm should be MD5");
}

// Test HMAC
fn test_hmac() {
    let key = "secret-key";
    let data = "message";
    let hmac = crypto::hmac_sha256(key, data);

    assert_true(hmac.to_hex().len() > 0, "HMAC should not be empty");
}

// Test hash comparison
fn test_hash_equality() {
    let data = "test data";
    let hash1 = crypto::sha256(data);
    let hash2 = crypto::sha256(data);

    assert_true(hash1.eq(&hash2), "Same input should produce same hash");
}

// Test random bytes generation
fn test_random_bytes() {
    let bytes1 = crypto::random_bytes(16);
    let bytes2 = crypto::random_bytes(16);

    assert_eq(bytes1.len(), 16, "Should generate 16 bytes");
    assert_eq(bytes2.len(), 16, "Should generate 16 bytes");

    // Random bytes should be different
    let mut different = false;
    for i in 0..16 {
        if bytes1[i] != bytes2[i] {
            different = true;
            break;
        }
    }
    assert_true(different, "Random bytes should be different");
}

// Test random integer generation
fn test_random_int() {
    let num1 = crypto::random_int(0, 100);
    let num2 = crypto::random_int(0, 100);

    assert_true(num1 >= 0 && num1 < 100, "Random int should be in range [0, 100)");
    assert_true(num2 >= 0 && num2 < 100, "Random int should be in range [0, 100)");
}

// Test random float generation
fn test_random_float() {
    let num1 = crypto::random_float();
    let num2 = crypto::random_float();

    assert_true(num1 >= 0.0 && num1 < 1.0, "Random float should be in range [0, 1)");
    assert_true(num2 >= 0.0 && num2 < 1.0, "Random float should be in range [0, 1)");
}

// Test random string generation
fn test_random_string() {
    let charset = "abc123";
    let str1 = crypto::random_string(10, charset);
    let str2 = crypto::random_string(10, charset);

    assert_eq(str1.len(), 10, "Random string should have specified length");
    assert_eq(str2.len(), 10, "Random string should have specified length");

    // All characters should be from charset
    for i in 0..str1.len() {
        let ch = str1.substring(i, i + 1);
        assert_true(charset.contains(ch), "Character should be from charset");
    }
}

// Test random alphanumeric string
fn test_random_alphanumeric() {
    let str = crypto::random_alphanumeric(20);

    assert_eq(str.len(), 20, "Should generate string of specified length");

    // Check if alphanumeric
    for i in 0..str.len() {
        let ch = str.substring(i, i + 1);
        let is_alpha = (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z");
        let is_digit = ch >= "0" && ch <= "9";
        assert_true(is_alpha || is_digit, "Should be alphanumeric");
    }
}

// Test random hex string
fn test_random_hex() {
    let hex = crypto::random_hex(32);

    assert_eq(hex.len(), 32, "Should generate hex string of specified length");

    // Check if hex characters
    for i in 0..hex.len() {
        let ch = hex.substring(i, i + 1);
        let is_hex = (ch >= "0" && ch <= "9") || (ch >= "a" && ch <= "f");
        assert_true(is_hex, "Should be hex character");
    }
}

// Test UUID v4 generation
fn test_uuid_v4() {
    let uuid1 = crypto::uuid_v4();
    let uuid2 = crypto::uuid_v4();

    // UUID format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    assert_eq(uuid1.len(), 36, "UUID should be 36 characters");
    assert_eq(uuid2.len(), 36, "UUID should be 36 characters");

    // Check hyphens at correct positions
    assert_eq(uuid1.substring(8, 9), "-", "Should have hyphen at position 8");
    assert_eq(uuid1.substring(13, 14), "-", "Should have hyphen at position 13");
    assert_eq(uuid1.substring(18, 19), "-", "Should have hyphen at position 18");
    assert_eq(uuid1.substring(23, 24), "-", "Should have hyphen at position 23");

    // Check version bit (4)
    assert_eq(uuid1.substring(14, 15), "4", "Should have version 4");

    // UUIDs should be different
    assert_ne(uuid1, uuid2, "UUIDs should be unique");
}

// Test base64 encoding
fn test_base64_encode() {
    let data = "Hello, World!";
    let encoded = crypto::base64_encode(data);

    assert_true(encoded.len() > 0, "Encoded string should not be empty");

    // Base64 encoded "Hello, World!" should be known value
    // SGVsbG8sIFdvcmxkIQ==
}

// Test base64 decoding
fn test_base64_decode() {
    let encoded = "SGVsbG8sIFdvcmxkIQ==";
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, "Hello, World!", "Should decode correctly");
        },
        Err(e) => {
            assert(false, "Failed to decode base64");
        },
    }
}

// Test base64 round-trip
fn test_base64_roundtrip() {
    let original = "The quick brown fox jumps over the lazy dog";
    let encoded = crypto::base64_encode(original);
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, original, "Round-trip should preserve data");
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test hex encoding
fn test_hex_encode() {
    let bytes = [72, 101, 108, 108, 111];  // "Hello" in ASCII
    let hex = crypto::hex_encode(&bytes);

    assert_eq(hex, "48656c6c6f", "Should encode to correct hex");
}

// Test hex decoding
fn test_hex_decode() {
    let hex = "48656c6c6f";
    let bytes_result = crypto::hex_decode(hex);

    match bytes_result {
        Ok(bytes) => {
            assert_eq(bytes.len(), 5, "Should decode to 5 bytes");
            assert_eq(bytes[0], 72, "First byte should be 72");
            assert_eq(bytes[1], 101, "Second byte should be 101");
        },
        Err(e) => {
            assert(false, "Failed to decode hex");
        },
    }
}

// Test hex round-trip
fn test_hex_roundtrip() {
    let original = [1, 2, 3, 4, 5, 255, 128, 64, 32, 16];
    let hex = crypto::hex_encode(&original);
    let decoded_result = crypto::hex_decode(hex);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded.len(), original.len(), "Should decode to same length");
            for i in 0..original.len() {
                assert_eq(decoded[i], original[i], "Bytes should match");
            }
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test password hashing
fn test_password_hashing() {
    let password = "my-secure-password";
    let hash = crypto::hash_password_auto(password);

    assert_eq(hash.algorithm, "PBKDF2-SHA256", "Algorithm should be PBKDF2-SHA256");
    assert_true(hash.iterations >= 100000, "Should use at least 100000 iterations");
    assert_true(hash.salt.len() > 0, "Should have salt");
    assert_true(hash.hash.len() > 0, "Should have hash");
}

// Test password verification
fn test_password_verification() {
    let password = "correct-password";
    let wrong_password = "wrong-password";

    let hash = crypto::hash_password_auto(password);

    // Correct password should verify
    assert_true(hash.verify(password), "Correct password should verify");

    // Wrong password should not verify
    assert_false(hash.verify(wrong_password), "Wrong password should not verify");
}

// Test password hash serialization
fn test_password_hash_serialization() {
    let password = "test-password";
    let hash = crypto::hash_password_auto(password);

    // Serialize to string
    let serialized = hash.to_string();
    assert_true(serialized.len() > 0, "Serialized string should not be empty");
    assert_true(serialized.starts_with("$"), "Should start with $");

    // Deserialize from string
    let parsed_result = PasswordHash::from_string(serialized);
    match parsed_result {
        Ok(parsed) => {
            assert_eq(parsed.algorithm, hash.algorithm, "Algorithm should match");
            assert_eq(parsed.iterations, hash.iterations, "Iterations should match");
            assert_eq(parsed.salt, hash.salt, "Salt should match");
            assert_eq(parsed.hash, hash.hash, "Hash should match");
        },
        Err(e) => {
            assert(false, "Failed to parse password hash");
        },
    }
}

// Test salt generation
fn test_salt_generation() {
    let salt1 = crypto::generate_salt(32);
    let salt2 = crypto::generate_salt(32);

    assert_eq(salt1.len(), 32, "Salt should have specified length");
    assert_eq(salt2.len(), 32, "Salt should have specified length");
    assert_ne(salt1, salt2, "Salts should be different");
}


// Test Crypto Module Implementation

// Test SHA-256 hashing
fn test_sha256() {
    let data = "Hello, World!";
    let hash = crypto::sha256(data);

    assert_true(hash.to_hex().len() > 0, "SHA-256 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA256, "Algorithm should be SHA256");
}

// Test SHA-1 hashing
fn test_sha1() {
    let data = "Hello, World!";
    let hash = crypto::sha1(data);

    assert_true(hash.to_hex().len() > 0, "SHA-1 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA1, "Algorithm should be SHA1");
}

// Test MD5 hashing
fn test_md5() {
    let data = "Hello, World!";
    let hash = crypto::md5(data);

    assert_true(hash.to_hex().len() > 0, "MD5 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::MD5, "Algorithm should be MD5");
}

// Test HMAC
fn test_hmac() {
    let key = "secret-key";
    let data = "message";
    let hmac = crypto::hmac_sha256(key, data);

    assert_true(hmac.to_hex().len() > 0, "HMAC should not be empty");
}

// Test hash comparison
fn test_hash_equality() {
    let data = "test data";
    let hash1 = crypto::sha256(data);
    let hash2 = crypto::sha256(data);

    assert_true(hash1.eq(&hash2), "Same input should produce same hash");
}

// Test random bytes generation
fn test_random_bytes() {
    let bytes1 = crypto::random_bytes(16);
    let bytes2 = crypto::random_bytes(16);

    assert_eq(bytes1.len(), 16, "Should generate 16 bytes");
    assert_eq(bytes2.len(), 16, "Should generate 16 bytes");

    // Random bytes should be different
    let mut different = false;
    for i in 0..16 {
        if bytes1[i] != bytes2[i] {
            different = true;
            break;
        }
    }
    assert_true(different, "Random bytes should be different");
}

// Test random integer generation
fn test_random_int() {
    let num1 = crypto::random_int(0, 100);
    let num2 = crypto::random_int(0, 100);

    assert_true(num1 >= 0 && num1 < 100, "Random int should be in range [0, 100)");
    assert_true(num2 >= 0 && num2 < 100, "Random int should be in range [0, 100)");
}

// Test random float generation
fn test_random_float() {
    let num1 = crypto::random_float();
    let num2 = crypto::random_float();

    assert_true(num1 >= 0.0 && num1 < 1.0, "Random float should be in range [0, 1)");
    assert_true(num2 >= 0.0 && num2 < 1.0, "Random float should be in range [0, 1)");
}

// Test random string generation
fn test_random_string() {
    let charset = "abc123";
    let str1 = crypto::random_string(10, charset);
    let str2 = crypto::random_string(10, charset);

    assert_eq(str1.len(), 10, "Random string should have specified length");
    assert_eq(str2.len(), 10, "Random string should have specified length");

    // All characters should be from charset
    for i in 0..str1.len() {
        let ch = str1.substring(i, i + 1);
        assert_true(charset.contains(ch), "Character should be from charset");
    }
}

// Test random alphanumeric string
fn test_random_alphanumeric() {
    let str = crypto::random_alphanumeric(20);

    assert_eq(str.len(), 20, "Should generate string of specified length");

    // Check if alphanumeric
    for i in 0..str.len() {
        let ch = str.substring(i, i + 1);
        let is_alpha = (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z");
        let is_digit = ch >= "0" && ch <= "9";
        assert_true(is_alpha || is_digit, "Should be alphanumeric");
    }
}

// Test random hex string
fn test_random_hex() {
    let hex = crypto::random_hex(32);

    assert_eq(hex.len(), 32, "Should generate hex string of specified length");

    // Check if hex characters
    for i in 0..hex.len() {
        let ch = hex.substring(i, i + 1);
        let is_hex = (ch >= "0" && ch <= "9") || (ch >= "a" && ch <= "f");
        assert_true(is_hex, "Should be hex character");
    }
}

// Test UUID v4 generation
fn test_uuid_v4() {
    let uuid1 = crypto::uuid_v4();
    let uuid2 = crypto::uuid_v4();

    // UUID format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    assert_eq(uuid1.len(), 36, "UUID should be 36 characters");
    assert_eq(uuid2.len(), 36, "UUID should be 36 characters");

    // Check hyphens at correct positions
    assert_eq(uuid1.substring(8, 9), "-", "Should have hyphen at position 8");
    assert_eq(uuid1.substring(13, 14), "-", "Should have hyphen at position 13");
    assert_eq(uuid1.substring(18, 19), "-", "Should have hyphen at position 18");
    assert_eq(uuid1.substring(23, 24), "-", "Should have hyphen at position 23");

    // Check version bit (4)
    assert_eq(uuid1.substring(14, 15), "4", "Should have version 4");

    // UUIDs should be different
    assert_ne(uuid1, uuid2, "UUIDs should be unique");
}

// Test base64 encoding
fn test_base64_encode() {
    let data = "Hello, World!";
    let encoded = crypto::base64_encode(data);

    assert_true(encoded.len() > 0, "Encoded string should not be empty");

    // Base64 encoded "Hello, World!" should be known value
    // SGVsbG8sIFdvcmxkIQ==
}

// Test base64 decoding
fn test_base64_decode() {
    let encoded = "SGVsbG8sIFdvcmxkIQ==";
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, "Hello, World!", "Should decode correctly");
        },
        Err(e) => {
            assert(false, "Failed to decode base64");
        },
    }
}

// Test base64 round-trip
fn test_base64_roundtrip() {
    let original = "The quick brown fox jumps over the lazy dog";
    let encoded = crypto::base64_encode(original);
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, original, "Round-trip should preserve data");
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test hex encoding
fn test_hex_encode() {
    let bytes = [72, 101, 108, 108, 111];  // "Hello" in ASCII
    let hex = crypto::hex_encode(&bytes);

    assert_eq(hex, "48656c6c6f", "Should encode to correct hex");
}

// Test hex decoding
fn test_hex_decode() {
    let hex = "48656c6c6f";
    let bytes_result = crypto::hex_decode(hex);

    match bytes_result {
        Ok(bytes) => {
            assert_eq(bytes.len(), 5, "Should decode to 5 bytes");
            assert_eq(bytes[0], 72, "First byte should be 72");
            assert_eq(bytes[1], 101, "Second byte should be 101");
        },
        Err(e) => {
            assert(false, "Failed to decode hex");
        },
    }
}

// Test hex round-trip
fn test_hex_roundtrip() {
    let original = [1, 2, 3, 4, 5, 255, 128, 64, 32, 16];
    let hex = crypto::hex_encode(&original);
    let decoded_result = crypto::hex_decode(hex);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded.len(), original.len(), "Should decode to same length");
            for i in 0..original.len() {
                assert_eq(decoded[i], original[i], "Bytes should match");
            }
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test password hashing
fn test_password_hashing() {
    let password = "my-secure-password";
    let hash = crypto::hash_password_auto(password);

    assert_eq(hash.algorithm, "PBKDF2-SHA256", "Algorithm should be PBKDF2-SHA256");
    assert_true(hash.iterations >= 100000, "Should use at least 100000 iterations");
    assert_true(hash.salt.len() > 0, "Should have salt");
    assert_true(hash.hash.len() > 0, "Should have hash");
}

// Test password verification
fn test_password_verification() {
    let password = "correct-password";
    let wrong_password = "wrong-password";

    let hash = crypto::hash_password_auto(password);

    // Correct password should verify
    assert_true(hash.verify(password), "Correct password should verify");

    // Wrong password should not verify
    assert_false(hash.verify(wrong_password), "Wrong password should not verify");
}

// Test password hash serialization
fn test_password_hash_serialization() {
    let password = "test-password";
    let hash = crypto::hash_password_auto(password);

    // Serialize to string
    let serialized = hash.to_string();
    assert_true(serialized.len() > 0, "Serialized string should not be empty");
    assert_true(serialized.starts_with("$"), "Should start with $");

    // Deserialize from string
    let parsed_result = PasswordHash::from_string(serialized);
    match parsed_result {
        Ok(parsed) => {
            assert_eq(parsed.algorithm, hash.algorithm, "Algorithm should match");
            assert_eq(parsed.iterations, hash.iterations, "Iterations should match");
            assert_eq(parsed.salt, hash.salt, "Salt should match");
            assert_eq(parsed.hash, hash.hash, "Hash should match");
        },
        Err(e) => {
            assert(false, "Failed to parse password hash");
        },
    }
}

// Test salt generation
fn test_salt_generation() {
    let salt1 = crypto::generate_salt(32);
    let salt2 = crypto::generate_salt(32);

    assert_eq(salt1.len(), 32, "Salt should have specified length");
    assert_eq(salt2.len(), 32, "Salt should have specified length");
    assert_ne(salt1, salt2, "Salts should be different");
}


// Test Crypto Module Implementation

// Test SHA-256 hashing
fn test_sha256() {
    let data = "Hello, World!";
    let hash = crypto::sha256(data);

    assert_true(hash.to_hex().len() > 0, "SHA-256 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA256, "Algorithm should be SHA256");
}

// Test SHA-1 hashing
fn test_sha1() {
    let data = "Hello, World!";
    let hash = crypto::sha1(data);

    assert_true(hash.to_hex().len() > 0, "SHA-1 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA1, "Algorithm should be SHA1");
}

// Test MD5 hashing
fn test_md5() {
    let data = "Hello, World!";
    let hash = crypto::md5(data);

    assert_true(hash.to_hex().len() > 0, "MD5 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::MD5, "Algorithm should be MD5");
}

// Test HMAC
fn test_hmac() {
    let key = "secret-key";
    let data = "message";
    let hmac = crypto::hmac_sha256(key, data);

    assert_true(hmac.to_hex().len() > 0, "HMAC should not be empty");
}

// Test hash comparison
fn test_hash_equality() {
    let data = "test data";
    let hash1 = crypto::sha256(data);
    let hash2 = crypto::sha256(data);

    assert_true(hash1.eq(&hash2), "Same input should produce same hash");
}

// Test random bytes generation
fn test_random_bytes() {
    let bytes1 = crypto::random_bytes(16);
    let bytes2 = crypto::random_bytes(16);

    assert_eq(bytes1.len(), 16, "Should generate 16 bytes");
    assert_eq(bytes2.len(), 16, "Should generate 16 bytes");

    // Random bytes should be different
    let mut different = false;
    for i in 0..16 {
        if bytes1[i] != bytes2[i] {
            different = true;
            break;
        }
    }
    assert_true(different, "Random bytes should be different");
}

// Test random integer generation
fn test_random_int() {
    let num1 = crypto::random_int(0, 100);
    let num2 = crypto::random_int(0, 100);

    assert_true(num1 >= 0 && num1 < 100, "Random int should be in range [0, 100)");
    assert_true(num2 >= 0 && num2 < 100, "Random int should be in range [0, 100)");
}

// Test random float generation
fn test_random_float() {
    let num1 = crypto::random_float();
    let num2 = crypto::random_float();

    assert_true(num1 >= 0.0 && num1 < 1.0, "Random float should be in range [0, 1)");
    assert_true(num2 >= 0.0 && num2 < 1.0, "Random float should be in range [0, 1)");
}

// Test random string generation
fn test_random_string() {
    let charset = "abc123";
    let str1 = crypto::random_string(10, charset);
    let str2 = crypto::random_string(10, charset);

    assert_eq(str1.len(), 10, "Random string should have specified length");
    assert_eq(str2.len(), 10, "Random string should have specified length");

    // All characters should be from charset
    for i in 0..str1.len() {
        let ch = str1.substring(i, i + 1);
        assert_true(charset.contains(ch), "Character should be from charset");
    }
}

// Test random alphanumeric string
fn test_random_alphanumeric() {
    let str = crypto::random_alphanumeric(20);

    assert_eq(str.len(), 20, "Should generate string of specified length");

    // Check if alphanumeric
    for i in 0..str.len() {
        let ch = str.substring(i, i + 1);
        let is_alpha = (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z");
        let is_digit = ch >= "0" && ch <= "9";
        assert_true(is_alpha || is_digit, "Should be alphanumeric");
    }
}

// Test random hex string
fn test_random_hex() {
    let hex = crypto::random_hex(32);

    assert_eq(hex.len(), 32, "Should generate hex string of specified length");

    // Check if hex characters
    for i in 0..hex.len() {
        let ch = hex.substring(i, i + 1);
        let is_hex = (ch >= "0" && ch <= "9") || (ch >= "a" && ch <= "f");
        assert_true(is_hex, "Should be hex character");
    }
}

// Test UUID v4 generation
fn test_uuid_v4() {
    let uuid1 = crypto::uuid_v4();
    let uuid2 = crypto::uuid_v4();

    // UUID format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    assert_eq(uuid1.len(), 36, "UUID should be 36 characters");
    assert_eq(uuid2.len(), 36, "UUID should be 36 characters");

    // Check hyphens at correct positions
    assert_eq(uuid1.substring(8, 9), "-", "Should have hyphen at position 8");
    assert_eq(uuid1.substring(13, 14), "-", "Should have hyphen at position 13");
    assert_eq(uuid1.substring(18, 19), "-", "Should have hyphen at position 18");
    assert_eq(uuid1.substring(23, 24), "-", "Should have hyphen at position 23");

    // Check version bit (4)
    assert_eq(uuid1.substring(14, 15), "4", "Should have version 4");

    // UUIDs should be different
    assert_ne(uuid1, uuid2, "UUIDs should be unique");
}

// Test base64 encoding
fn test_base64_encode() {
    let data = "Hello, World!";
    let encoded = crypto::base64_encode(data);

    assert_true(encoded.len() > 0, "Encoded string should not be empty");

    // Base64 encoded "Hello, World!" should be known value
    // SGVsbG8sIFdvcmxkIQ==
}

// Test base64 decoding
fn test_base64_decode() {
    let encoded = "SGVsbG8sIFdvcmxkIQ==";
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, "Hello, World!", "Should decode correctly");
        },
        Err(e) => {
            assert(false, "Failed to decode base64");
        },
    }
}

// Test base64 round-trip
fn test_base64_roundtrip() {
    let original = "The quick brown fox jumps over the lazy dog";
    let encoded = crypto::base64_encode(original);
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, original, "Round-trip should preserve data");
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test hex encoding
fn test_hex_encode() {
    let bytes = [72, 101, 108, 108, 111];  // "Hello" in ASCII
    let hex = crypto::hex_encode(&bytes);

    assert_eq(hex, "48656c6c6f", "Should encode to correct hex");
}

// Test hex decoding
fn test_hex_decode() {
    let hex = "48656c6c6f";
    let bytes_result = crypto::hex_decode(hex);

    match bytes_result {
        Ok(bytes) => {
            assert_eq(bytes.len(), 5, "Should decode to 5 bytes");
            assert_eq(bytes[0], 72, "First byte should be 72");
            assert_eq(bytes[1], 101, "Second byte should be 101");
        },
        Err(e) => {
            assert(false, "Failed to decode hex");
        },
    }
}

// Test hex round-trip
fn test_hex_roundtrip() {
    let original = [1, 2, 3, 4, 5, 255, 128, 64, 32, 16];
    let hex = crypto::hex_encode(&original);
    let decoded_result = crypto::hex_decode(hex);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded.len(), original.len(), "Should decode to same length");
            for i in 0..original.len() {
                assert_eq(decoded[i], original[i], "Bytes should match");
            }
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test password hashing
fn test_password_hashing() {
    let password = "my-secure-password";
    let hash = crypto::hash_password_auto(password);

    assert_eq(hash.algorithm, "PBKDF2-SHA256", "Algorithm should be PBKDF2-SHA256");
    assert_true(hash.iterations >= 100000, "Should use at least 100000 iterations");
    assert_true(hash.salt.len() > 0, "Should have salt");
    assert_true(hash.hash.len() > 0, "Should have hash");
}

// Test password verification
fn test_password_verification() {
    let password = "correct-password";
    let wrong_password = "wrong-password";

    let hash = crypto::hash_password_auto(password);

    // Correct password should verify
    assert_true(hash.verify(password), "Correct password should verify");

    // Wrong password should not verify
    assert_false(hash.verify(wrong_password), "Wrong password should not verify");
}

// Test password hash serialization
fn test_password_hash_serialization() {
    let password = "test-password";
    let hash = crypto::hash_password_auto(password);

    // Serialize to string
    let serialized = hash.to_string();
    assert_true(serialized.len() > 0, "Serialized string should not be empty");
    assert_true(serialized.starts_with("$"), "Should start with $");

    // Deserialize from string
    let parsed_result = PasswordHash::from_string(serialized);
    match parsed_result {
        Ok(parsed) => {
            assert_eq(parsed.algorithm, hash.algorithm, "Algorithm should match");
            assert_eq(parsed.iterations, hash.iterations, "Iterations should match");
            assert_eq(parsed.salt, hash.salt, "Salt should match");
            assert_eq(parsed.hash, hash.hash, "Hash should match");
        },
        Err(e) => {
            assert(false, "Failed to parse password hash");
        },
    }
}

// Test salt generation
fn test_salt_generation() {
    let salt1 = crypto::generate_salt(32);
    let salt2 = crypto::generate_salt(32);

    assert_eq(salt1.len(), 32, "Salt should have specified length");
    assert_eq(salt2.len(), 32, "Salt should have specified length");
    assert_ne(salt1, salt2, "Salts should be different");
}


// Test Crypto Module Implementation

// Test SHA-256 hashing
fn test_sha256() {
    let data = "Hello, World!";
    let hash = crypto::sha256(data);

    assert_true(hash.to_hex().len() > 0, "SHA-256 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA256, "Algorithm should be SHA256");
}

// Test SHA-1 hashing
fn test_sha1() {
    let data = "Hello, World!";
    let hash = crypto::sha1(data);

    assert_true(hash.to_hex().len() > 0, "SHA-1 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::SHA1, "Algorithm should be SHA1");
}

// Test MD5 hashing
fn test_md5() {
    let data = "Hello, World!";
    let hash = crypto::md5(data);

    assert_true(hash.to_hex().len() > 0, "MD5 hash should not be empty");
    assert_eq(hash.algorithm, HashAlgorithm::MD5, "Algorithm should be MD5");
}

// Test HMAC
fn test_hmac() {
    let key = "secret-key";
    let data = "message";
    let hmac = crypto::hmac_sha256(key, data);

    assert_true(hmac.to_hex().len() > 0, "HMAC should not be empty");
}

// Test hash comparison
fn test_hash_equality() {
    let data = "test data";
    let hash1 = crypto::sha256(data);
    let hash2 = crypto::sha256(data);

    assert_true(hash1.eq(&hash2), "Same input should produce same hash");
}

// Test random bytes generation
fn test_random_bytes() {
    let bytes1 = crypto::random_bytes(16);
    let bytes2 = crypto::random_bytes(16);

    assert_eq(bytes1.len(), 16, "Should generate 16 bytes");
    assert_eq(bytes2.len(), 16, "Should generate 16 bytes");

    // Random bytes should be different
    let mut different = false;
    for i in 0..16 {
        if bytes1[i] != bytes2[i] {
            different = true;
            break;
        }
    }
    assert_true(different, "Random bytes should be different");
}

// Test random integer generation
fn test_random_int() {
    let num1 = crypto::random_int(0, 100);
    let num2 = crypto::random_int(0, 100);

    assert_true(num1 >= 0 && num1 < 100, "Random int should be in range [0, 100)");
    assert_true(num2 >= 0 && num2 < 100, "Random int should be in range [0, 100)");
}

// Test random float generation
fn test_random_float() {
    let num1 = crypto::random_float();
    let num2 = crypto::random_float();

    assert_true(num1 >= 0.0 && num1 < 1.0, "Random float should be in range [0, 1)");
    assert_true(num2 >= 0.0 && num2 < 1.0, "Random float should be in range [0, 1)");
}

// Test random string generation
fn test_random_string() {
    let charset = "abc123";
    let str1 = crypto::random_string(10, charset);
    let str2 = crypto::random_string(10, charset);

    assert_eq(str1.len(), 10, "Random string should have specified length");
    assert_eq(str2.len(), 10, "Random string should have specified length");

    // All characters should be from charset
    for i in 0..str1.len() {
        let ch = str1.substring(i, i + 1);
        assert_true(charset.contains(ch), "Character should be from charset");
    }
}

// Test random alphanumeric string
fn test_random_alphanumeric() {
    let str = crypto::random_alphanumeric(20);

    assert_eq(str.len(), 20, "Should generate string of specified length");

    // Check if alphanumeric
    for i in 0..str.len() {
        let ch = str.substring(i, i + 1);
        let is_alpha = (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z");
        let is_digit = ch >= "0" && ch <= "9";
        assert_true(is_alpha || is_digit, "Should be alphanumeric");
    }
}

// Test random hex string
fn test_random_hex() {
    let hex = crypto::random_hex(32);

    assert_eq(hex.len(), 32, "Should generate hex string of specified length");

    // Check if hex characters
    for i in 0..hex.len() {
        let ch = hex.substring(i, i + 1);
        let is_hex = (ch >= "0" && ch <= "9") || (ch >= "a" && ch <= "f");
        assert_true(is_hex, "Should be hex character");
    }
}

// Test UUID v4 generation
fn test_uuid_v4() {
    let uuid1 = crypto::uuid_v4();
    let uuid2 = crypto::uuid_v4();

    // UUID format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    assert_eq(uuid1.len(), 36, "UUID should be 36 characters");
    assert_eq(uuid2.len(), 36, "UUID should be 36 characters");

    // Check hyphens at correct positions
    assert_eq(uuid1.substring(8, 9), "-", "Should have hyphen at position 8");
    assert_eq(uuid1.substring(13, 14), "-", "Should have hyphen at position 13");
    assert_eq(uuid1.substring(18, 19), "-", "Should have hyphen at position 18");
    assert_eq(uuid1.substring(23, 24), "-", "Should have hyphen at position 23");

    // Check version bit (4)
    assert_eq(uuid1.substring(14, 15), "4", "Should have version 4");

    // UUIDs should be different
    assert_ne(uuid1, uuid2, "UUIDs should be unique");
}

// Test base64 encoding
fn test_base64_encode() {
    let data = "Hello, World!";
    let encoded = crypto::base64_encode(data);

    assert_true(encoded.len() > 0, "Encoded string should not be empty");

    // Base64 encoded "Hello, World!" should be known value
    // SGVsbG8sIFdvcmxkIQ==
}

// Test base64 decoding
fn test_base64_decode() {
    let encoded = "SGVsbG8sIFdvcmxkIQ==";
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, "Hello, World!", "Should decode correctly");
        },
        Err(e) => {
            assert(false, "Failed to decode base64");
        },
    }
}

// Test base64 round-trip
fn test_base64_roundtrip() {
    let original = "The quick brown fox jumps over the lazy dog";
    let encoded = crypto::base64_encode(original);
    let decoded_result = crypto::base64_decode(encoded);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded, original, "Round-trip should preserve data");
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test hex encoding
fn test_hex_encode() {
    let bytes = [72, 101, 108, 108, 111];  // "Hello" in ASCII
    let hex = crypto::hex_encode(&bytes);

    assert_eq(hex, "48656c6c6f", "Should encode to correct hex");
}

// Test hex decoding
fn test_hex_decode() {
    let hex = "48656c6c6f";
    let bytes_result = crypto::hex_decode(hex);

    match bytes_result {
        Ok(bytes) => {
            assert_eq(bytes.len(), 5, "Should decode to 5 bytes");
            assert_eq(bytes[0], 72, "First byte should be 72");
            assert_eq(bytes[1], 101, "Second byte should be 101");
        },
        Err(e) => {
            assert(false, "Failed to decode hex");
        },
    }
}

// Test hex round-trip
fn test_hex_roundtrip() {
    let original = [1, 2, 3, 4, 5, 255, 128, 64, 32, 16];
    let hex = crypto::hex_encode(&original);
    let decoded_result = crypto::hex_decode(hex);

    match decoded_result {
        Ok(decoded) => {
            assert_eq(decoded.len(), original.len(), "Should decode to same length");
            for i in 0..original.len() {
                assert_eq(decoded[i], original[i], "Bytes should match");
            }
        },
        Err(e) => {
            assert(false, "Round-trip failed");
        },
    }
}

// Test password hashing
fn test_password_hashing() {
    let password = "my-secure-password";
    let hash = crypto::hash_password_auto(password);

    assert_eq(hash.algorithm, "PBKDF2-SHA256", "Algorithm should be PBKDF2-SHA256");
    assert_true(hash.iterations >= 100000, "Should use at least 100000 iterations");
    assert_true(hash.salt.len() > 0, "Should have salt");
    assert_true(hash.hash.len() > 0, "Should have hash");
}

// Test password verification
fn test_password_verification() {
    let password = "correct-password";
    let wrong_password = "wrong-password";

    let hash = crypto::hash_password_auto(password);

    // Correct password should verify
    assert_true(hash.verify(password), "Correct password should verify");

    // Wrong password should not verify
    assert_false(hash.verify(wrong_password), "Wrong password should not verify");
}

// Test password hash serialization
fn test_password_hash_serialization() {
    let password = "test-password";
    let hash = crypto::hash_password_auto(password);

    // Serialize to string
    let serialized = hash.to_string();
    assert_true(serialized.len() > 0, "Serialized string should not be empty");
    assert_true(serialized.starts_with("$"), "Should start with $");

    // Deserialize from string
    let parsed_result = PasswordHash::from_string(serialized);
    match parsed_result {
        Ok(parsed) => {
            assert_eq(parsed.algorithm, hash.algorithm, "Algorithm should match");
            assert_eq(parsed.iterations, hash.iterations, "Iterations should match");
            assert_eq(parsed.salt, hash.salt, "Salt should match");
            assert_eq(parsed.hash, hash.hash, "Hash should match");
        },
        Err(e) => {
            assert(false, "Failed to parse password hash");
        },
    }
}

// Test salt generation
fn test_salt_generation() {
    let salt1 = crypto::generate_salt(32);
    let salt2 = crypto::generate_salt(32);

    assert_eq(salt1.len(), 32, "Salt should have specified length");
    assert_eq(salt2.len(), 32, "Salt should have specified length");
    assert_ne(salt1, salt2, "Salts should be different");
}


// YAML Parser and Serializer Tests

// Test 1: Parse simple scalars
fn test_parse_scalars() {
    // Null
    let null_yaml = yaml::parse("null");
    assert_ok(&null_yaml);
    let null_val = null_yaml.unwrap();
    assert(null_val.is_null(), "Should be null");

    // Boolean
    let true_yaml = yaml::parse("true");
    assert_ok(&true_yaml);
    assert_eq(true_yaml.unwrap().as_bool().unwrap(), true, "Should be true");

    let false_yaml = yaml::parse("false");
    assert_ok(&false_yaml);
    assert_eq(false_yaml.unwrap().as_bool().unwrap(), false, "Should be false");

    // Number
    let num_yaml = yaml::parse("42");
    assert_ok(&num_yaml);
    assert_eq(num_yaml.unwrap().as_number().unwrap(), 42.0, "Should be 42");

    // String
    let str_yaml = yaml::parse("hello");
    assert_ok(&str_yaml);
    assert_eq(str_yaml.unwrap().as_string().unwrap(), "hello", "Should be 'hello'");
}

// Test 2: Parse flow sequences
fn test_parse_flow_sequence() {
    let yaml_str = "[1, 2, 3, 4, 5]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_sequence(), "Should be a sequence");

    let seq = value.as_sequence().unwrap();
    assert_eq(seq.len() as i64, 5, "Should have 5 elements");

    assert_eq(seq[0].as_number().unwrap(), 1.0, "First element should be 1");
    assert_eq(seq[1].as_number().unwrap(), 2.0, "Second element should be 2");
    assert_eq(seq[4].as_number().unwrap(), 5.0, "Fifth element should be 5");
}

// Test 3: Parse flow mappings
fn test_parse_flow_mapping() {
    let yaml_str = "{name: John, age: 30, active: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_mapping(), "Should be a mapping");

    let name = value.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "John", "Name should be John");

    let age = value.get("age").unwrap();
    assert_eq(age.as_number().unwrap(), 30.0, "Age should be 30");

    let active = value.get("active").unwrap();
    assert_eq(active.as_bool().unwrap(), true, "Active should be true");
}

// Test 4: Parse nested structures
fn test_parse_nested() {
    let yaml_str = "{user: {name: Alice, scores: [95, 87, 92]}}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let user = value.get("user").unwrap();
    assert(user.is_mapping(), "User should be a mapping");

    let name = user.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "Alice", "Name should be Alice");

    let scores = user.get("scores").unwrap();
    assert(scores.is_sequence(), "Scores should be a sequence");
    let scores_seq = scores.as_sequence().unwrap();
    assert_eq(scores_seq.len() as i64, 3, "Should have 3 scores");
}

// Test 5: Parse mixed sequences
fn test_parse_mixed_sequence() {
    let yaml_str = "[42, hello, true, null]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    let seq = value.as_sequence().unwrap();

    assert_eq(seq.len() as i64, 4, "Should have 4 elements");
    assert(seq[0].is_number(), "First should be number");
    assert(seq[1].is_string(), "Second should be string");
    assert(seq[2].is_bool(), "Third should be bool");
    assert(seq[3].is_null(), "Fourth should be null");
}

// Test 6: Stringify scalars
fn test_stringify_scalars() {
    let null_val = yaml::yaml_null();
    assert_eq(yaml::stringify(null_val), "null", "Null should stringify to 'null'");

    let bool_val = yaml::yaml_bool(true);
    assert_eq(yaml::stringify(bool_val), "true", "True should stringify to 'true'");

    let num_val = yaml::yaml_number(42.5);
    assert_eq(yaml::stringify(num_val), "42.5", "Number should stringify correctly");

    let str_val = yaml::yaml_string("hello");
    assert_eq(yaml::stringify(str_val), "hello", "String should stringify to itself");
}

// Test 7: Stringify sequences
fn test_stringify_sequence() {
    let mut seq = yaml::yaml_sequence();
    seq.push(yaml::yaml_number(1.0));
    seq.push(yaml::yaml_number(2.0));
    seq.push(yaml::yaml_number(3.0));

    let yaml_str = yaml::stringify(seq);
    assert(yaml_str.contains("- 1"), "Should contain '- 1'");
    assert(yaml_str.contains("- 2"), "Should contain '- 2'");
    assert(yaml_str.contains("- 3"), "Should contain '- 3'");
}

// Test 8: Stringify mappings
fn test_stringify_mapping() {
    let mut map = yaml::yaml_mapping();
    map.set("name", yaml::yaml_string("Alice"));
    map.set("age", yaml::yaml_number(25.0));

    let yaml_str = yaml::stringify(map);
    assert(yaml_str.contains("name:"), "Should contain 'name:'");
    assert(yaml_str.contains("Alice"), "Should contain 'Alice'");
    assert(yaml_str.contains("age:"), "Should contain 'age:'");
    assert(yaml_str.contains("25"), "Should contain '25'");
}

// Test 9: YamlValue manipulation - sequences
fn test_yaml_value_sequence_manipulation() {
    let mut seq = yaml::yaml_sequence();
    assert_eq(seq.len(), 0, "Should start empty");

    seq.push(yaml::yaml_number(10.0));
    seq.push(yaml::yaml_string("test"));
    assert_eq(seq.len(), 2, "Should have 2 elements");

    let first = seq.get_index(0).unwrap();
    assert_eq(first.as_number().unwrap(), 10.0, "First element should be 10");

    let second = seq.get_index(1).unwrap();
    assert_eq(second.as_string().unwrap(), "test", "Second element should be 'test'");
}

// Test 10: YamlValue manipulation - mappings
fn test_yaml_value_mapping_manipulation() {
    let mut map = yaml::yaml_mapping();
    assert_eq(map.len(), 0, "Should start empty");

    map.set("key1", yaml::yaml_string("value1"));
    map.set("key2", yaml::yaml_number(100.0));
    assert_eq(map.len(), 2, "Should have 2 keys");

    let keys = map.keys();
    assert_eq(keys.len() as i64, 2, "Should have 2 keys");

    let val1 = map.get("key1").unwrap();
    assert_eq(val1.as_string().unwrap(), "value1", "Should get correct value");

    let val2 = map.get("key2").unwrap();
    assert_eq(val2.as_number().unwrap(), 100.0, "Should get correct number");
}

// Test 11: Type checking methods
fn test_type_checking() {
    let null_val = yaml::yaml_null();
    assert(null_val.is_null(), "Should be null type");
    assert(!null_val.is_string(), "Should not be string type");

    let bool_val = yaml::yaml_bool(true);
    assert(bool_val.is_bool(), "Should be bool type");
    assert(!bool_val.is_number(), "Should not be number type");

    let num_val = yaml::yaml_number(3.14);
    assert(num_val.is_number(), "Should be number type");
    assert(!num_val.is_sequence(), "Should not be sequence type");

    let str_val = yaml::yaml_string("test");
    assert(str_val.is_string(), "Should be string type");
    assert(!str_val.is_mapping(), "Should not be mapping type");
}

// Test 12: Quoted strings
fn test_quoted_strings() {
    let yaml_str = "\"hello world\"";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert_eq(value.as_string().unwrap(), "hello world", "Should parse quoted string");
}

// Test 13: Empty sequences and mappings
fn test_empty_collections() {
    let empty_seq = yaml::parse("[]");
    assert_ok(&empty_seq);
    let seq = empty_seq.unwrap();
    assert(seq.is_sequence(), "Should be a sequence");
    assert_eq(seq.len(), 0, "Should be empty");

    let empty_map = yaml::parse("{}");
    assert_ok(&empty_map);
    let map = empty_map.unwrap();
    assert(map.is_mapping(), "Should be a mapping");
    assert_eq(map.len(), 0, "Should be empty");
}

// Test 14: Stringify empty collections
fn test_stringify_empty() {
    let empty_seq = yaml::yaml_sequence();
    assert_eq(yaml::stringify(empty_seq), "[]", "Empty sequence should stringify to '[]'");

    let empty_map = yaml::yaml_mapping();
    assert_eq(yaml::stringify(empty_map), "{}", "Empty mapping should stringify to '{}'");
}

// Test 15: Complex nested structure
fn test_complex_nested_structure() {
    let yaml_str = "{database: {host: localhost, port: 5432, credentials: {user: admin, password: secret}}, enabled: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let db = value.get("database").unwrap();
    let host = db.get("host").unwrap();
    assert_eq(host.as_string().unwrap(), "localhost", "Host should be localhost");

    let port = db.get("port").unwrap();
    assert_eq(port.as_number().unwrap(), 5432.0, "Port should be 5432");

    let creds = db.get("credentials").unwrap();
    let user = creds.get("user").unwrap();
    assert_eq(user.as_string().unwrap(), "admin", "User should be admin");

    let enabled = value.get("enabled").unwrap();
    assert_eq(enabled.as_bool().unwrap(), true, "Enabled should be true");
}


// YAML Parser and Serializer Tests

// Test 1: Parse simple scalars
fn test_parse_scalars() {
    // Null
    let null_yaml = yaml::parse("null");
    assert_ok(&null_yaml);
    let null_val = null_yaml.unwrap();
    assert(null_val.is_null(), "Should be null");

    // Boolean
    let true_yaml = yaml::parse("true");
    assert_ok(&true_yaml);
    assert_eq(true_yaml.unwrap().as_bool().unwrap(), true, "Should be true");

    let false_yaml = yaml::parse("false");
    assert_ok(&false_yaml);
    assert_eq(false_yaml.unwrap().as_bool().unwrap(), false, "Should be false");

    // Number
    let num_yaml = yaml::parse("42");
    assert_ok(&num_yaml);
    assert_eq(num_yaml.unwrap().as_number().unwrap(), 42.0, "Should be 42");

    // String
    let str_yaml = yaml::parse("hello");
    assert_ok(&str_yaml);
    assert_eq(str_yaml.unwrap().as_string().unwrap(), "hello", "Should be 'hello'");
}

// Test 2: Parse flow sequences
fn test_parse_flow_sequence() {
    let yaml_str = "[1, 2, 3, 4, 5]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_sequence(), "Should be a sequence");

    let seq = value.as_sequence().unwrap();
    assert_eq(seq.len() as i64, 5, "Should have 5 elements");

    assert_eq(seq[0].as_number().unwrap(), 1.0, "First element should be 1");
    assert_eq(seq[1].as_number().unwrap(), 2.0, "Second element should be 2");
    assert_eq(seq[4].as_number().unwrap(), 5.0, "Fifth element should be 5");
}

// Test 3: Parse flow mappings
fn test_parse_flow_mapping() {
    let yaml_str = "{name: John, age: 30, active: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_mapping(), "Should be a mapping");

    let name = value.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "John", "Name should be John");

    let age = value.get("age").unwrap();
    assert_eq(age.as_number().unwrap(), 30.0, "Age should be 30");

    let active = value.get("active").unwrap();
    assert_eq(active.as_bool().unwrap(), true, "Active should be true");
}

// Test 4: Parse nested structures
fn test_parse_nested() {
    let yaml_str = "{user: {name: Alice, scores: [95, 87, 92]}}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let user = value.get("user").unwrap();
    assert(user.is_mapping(), "User should be a mapping");

    let name = user.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "Alice", "Name should be Alice");

    let scores = user.get("scores").unwrap();
    assert(scores.is_sequence(), "Scores should be a sequence");
    let scores_seq = scores.as_sequence().unwrap();
    assert_eq(scores_seq.len() as i64, 3, "Should have 3 scores");
}

// Test 5: Parse mixed sequences
fn test_parse_mixed_sequence() {
    let yaml_str = "[42, hello, true, null]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    let seq = value.as_sequence().unwrap();

    assert_eq(seq.len() as i64, 4, "Should have 4 elements");
    assert(seq[0].is_number(), "First should be number");
    assert(seq[1].is_string(), "Second should be string");
    assert(seq[2].is_bool(), "Third should be bool");
    assert(seq[3].is_null(), "Fourth should be null");
}

// Test 6: Stringify scalars
fn test_stringify_scalars() {
    let null_val = yaml::yaml_null();
    assert_eq(yaml::stringify(null_val), "null", "Null should stringify to 'null'");

    let bool_val = yaml::yaml_bool(true);
    assert_eq(yaml::stringify(bool_val), "true", "True should stringify to 'true'");

    let num_val = yaml::yaml_number(42.5);
    assert_eq(yaml::stringify(num_val), "42.5", "Number should stringify correctly");

    let str_val = yaml::yaml_string("hello");
    assert_eq(yaml::stringify(str_val), "hello", "String should stringify to itself");
}

// Test 7: Stringify sequences
fn test_stringify_sequence() {
    let mut seq = yaml::yaml_sequence();
    seq.push(yaml::yaml_number(1.0));
    seq.push(yaml::yaml_number(2.0));
    seq.push(yaml::yaml_number(3.0));

    let yaml_str = yaml::stringify(seq);
    assert(yaml_str.contains("- 1"), "Should contain '- 1'");
    assert(yaml_str.contains("- 2"), "Should contain '- 2'");
    assert(yaml_str.contains("- 3"), "Should contain '- 3'");
}

// Test 8: Stringify mappings
fn test_stringify_mapping() {
    let mut map = yaml::yaml_mapping();
    map.set("name", yaml::yaml_string("Alice"));
    map.set("age", yaml::yaml_number(25.0));

    let yaml_str = yaml::stringify(map);
    assert(yaml_str.contains("name:"), "Should contain 'name:'");
    assert(yaml_str.contains("Alice"), "Should contain 'Alice'");
    assert(yaml_str.contains("age:"), "Should contain 'age:'");
    assert(yaml_str.contains("25"), "Should contain '25'");
}

// Test 9: YamlValue manipulation - sequences
fn test_yaml_value_sequence_manipulation() {
    let mut seq = yaml::yaml_sequence();
    assert_eq(seq.len(), 0, "Should start empty");

    seq.push(yaml::yaml_number(10.0));
    seq.push(yaml::yaml_string("test"));
    assert_eq(seq.len(), 2, "Should have 2 elements");

    let first = seq.get_index(0).unwrap();
    assert_eq(first.as_number().unwrap(), 10.0, "First element should be 10");

    let second = seq.get_index(1).unwrap();
    assert_eq(second.as_string().unwrap(), "test", "Second element should be 'test'");
}

// Test 10: YamlValue manipulation - mappings
fn test_yaml_value_mapping_manipulation() {
    let mut map = yaml::yaml_mapping();
    assert_eq(map.len(), 0, "Should start empty");

    map.set("key1", yaml::yaml_string("value1"));
    map.set("key2", yaml::yaml_number(100.0));
    assert_eq(map.len(), 2, "Should have 2 keys");

    let keys = map.keys();
    assert_eq(keys.len() as i64, 2, "Should have 2 keys");

    let val1 = map.get("key1").unwrap();
    assert_eq(val1.as_string().unwrap(), "value1", "Should get correct value");

    let val2 = map.get("key2").unwrap();
    assert_eq(val2.as_number().unwrap(), 100.0, "Should get correct number");
}

// Test 11: Type checking methods
fn test_type_checking() {
    let null_val = yaml::yaml_null();
    assert(null_val.is_null(), "Should be null type");
    assert(!null_val.is_string(), "Should not be string type");

    let bool_val = yaml::yaml_bool(true);
    assert(bool_val.is_bool(), "Should be bool type");
    assert(!bool_val.is_number(), "Should not be number type");

    let num_val = yaml::yaml_number(3.14);
    assert(num_val.is_number(), "Should be number type");
    assert(!num_val.is_sequence(), "Should not be sequence type");

    let str_val = yaml::yaml_string("test");
    assert(str_val.is_string(), "Should be string type");
    assert(!str_val.is_mapping(), "Should not be mapping type");
}

// Test 12: Quoted strings
fn test_quoted_strings() {
    let yaml_str = "\"hello world\"";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert_eq(value.as_string().unwrap(), "hello world", "Should parse quoted string");
}

// Test 13: Empty sequences and mappings
fn test_empty_collections() {
    let empty_seq = yaml::parse("[]");
    assert_ok(&empty_seq);
    let seq = empty_seq.unwrap();
    assert(seq.is_sequence(), "Should be a sequence");
    assert_eq(seq.len(), 0, "Should be empty");

    let empty_map = yaml::parse("{}");
    assert_ok(&empty_map);
    let map = empty_map.unwrap();
    assert(map.is_mapping(), "Should be a mapping");
    assert_eq(map.len(), 0, "Should be empty");
}

// Test 14: Stringify empty collections
fn test_stringify_empty() {
    let empty_seq = yaml::yaml_sequence();
    assert_eq(yaml::stringify(empty_seq), "[]", "Empty sequence should stringify to '[]'");

    let empty_map = yaml::yaml_mapping();
    assert_eq(yaml::stringify(empty_map), "{}", "Empty mapping should stringify to '{}'");
}

// Test 15: Complex nested structure
fn test_complex_nested_structure() {
    let yaml_str = "{database: {host: localhost, port: 5432, credentials: {user: admin, password: secret}}, enabled: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let db = value.get("database").unwrap();
    let host = db.get("host").unwrap();
    assert_eq(host.as_string().unwrap(), "localhost", "Host should be localhost");

    let port = db.get("port").unwrap();
    assert_eq(port.as_number().unwrap(), 5432.0, "Port should be 5432");

    let creds = db.get("credentials").unwrap();
    let user = creds.get("user").unwrap();
    assert_eq(user.as_string().unwrap(), "admin", "User should be admin");

    let enabled = value.get("enabled").unwrap();
    assert_eq(enabled.as_bool().unwrap(), true, "Enabled should be true");
}


// YAML Parser and Serializer Tests

// Test 1: Parse simple scalars
fn test_parse_scalars() {
    // Null
    let null_yaml = yaml::parse("null");
    assert_ok(&null_yaml);
    let null_val = null_yaml.unwrap();
    assert(null_val.is_null(), "Should be null");

    // Boolean
    let true_yaml = yaml::parse("true");
    assert_ok(&true_yaml);
    assert_eq(true_yaml.unwrap().as_bool().unwrap(), true, "Should be true");

    let false_yaml = yaml::parse("false");
    assert_ok(&false_yaml);
    assert_eq(false_yaml.unwrap().as_bool().unwrap(), false, "Should be false");

    // Number
    let num_yaml = yaml::parse("42");
    assert_ok(&num_yaml);
    assert_eq(num_yaml.unwrap().as_number().unwrap(), 42.0, "Should be 42");

    // String
    let str_yaml = yaml::parse("hello");
    assert_ok(&str_yaml);
    assert_eq(str_yaml.unwrap().as_string().unwrap(), "hello", "Should be 'hello'");
}

// Test 2: Parse flow sequences
fn test_parse_flow_sequence() {
    let yaml_str = "[1, 2, 3, 4, 5]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_sequence(), "Should be a sequence");

    let seq = value.as_sequence().unwrap();
    assert_eq(seq.len() as i64, 5, "Should have 5 elements");

    assert_eq(seq[0].as_number().unwrap(), 1.0, "First element should be 1");
    assert_eq(seq[1].as_number().unwrap(), 2.0, "Second element should be 2");
    assert_eq(seq[4].as_number().unwrap(), 5.0, "Fifth element should be 5");
}

// Test 3: Parse flow mappings
fn test_parse_flow_mapping() {
    let yaml_str = "{name: John, age: 30, active: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_mapping(), "Should be a mapping");

    let name = value.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "John", "Name should be John");

    let age = value.get("age").unwrap();
    assert_eq(age.as_number().unwrap(), 30.0, "Age should be 30");

    let active = value.get("active").unwrap();
    assert_eq(active.as_bool().unwrap(), true, "Active should be true");
}

// Test 4: Parse nested structures
fn test_parse_nested() {
    let yaml_str = "{user: {name: Alice, scores: [95, 87, 92]}}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let user = value.get("user").unwrap();
    assert(user.is_mapping(), "User should be a mapping");

    let name = user.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "Alice", "Name should be Alice");

    let scores = user.get("scores").unwrap();
    assert(scores.is_sequence(), "Scores should be a sequence");
    let scores_seq = scores.as_sequence().unwrap();
    assert_eq(scores_seq.len() as i64, 3, "Should have 3 scores");
}

// Test 5: Parse mixed sequences
fn test_parse_mixed_sequence() {
    let yaml_str = "[42, hello, true, null]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    let seq = value.as_sequence().unwrap();

    assert_eq(seq.len() as i64, 4, "Should have 4 elements");
    assert(seq[0].is_number(), "First should be number");
    assert(seq[1].is_string(), "Second should be string");
    assert(seq[2].is_bool(), "Third should be bool");
    assert(seq[3].is_null(), "Fourth should be null");
}

// Test 6: Stringify scalars
fn test_stringify_scalars() {
    let null_val = yaml::yaml_null();
    assert_eq(yaml::stringify(null_val), "null", "Null should stringify to 'null'");

    let bool_val = yaml::yaml_bool(true);
    assert_eq(yaml::stringify(bool_val), "true", "True should stringify to 'true'");

    let num_val = yaml::yaml_number(42.5);
    assert_eq(yaml::stringify(num_val), "42.5", "Number should stringify correctly");

    let str_val = yaml::yaml_string("hello");
    assert_eq(yaml::stringify(str_val), "hello", "String should stringify to itself");
}

// Test 7: Stringify sequences
fn test_stringify_sequence() {
    let mut seq = yaml::yaml_sequence();
    seq.push(yaml::yaml_number(1.0));
    seq.push(yaml::yaml_number(2.0));
    seq.push(yaml::yaml_number(3.0));

    let yaml_str = yaml::stringify(seq);
    assert(yaml_str.contains("- 1"), "Should contain '- 1'");
    assert(yaml_str.contains("- 2"), "Should contain '- 2'");
    assert(yaml_str.contains("- 3"), "Should contain '- 3'");
}

// Test 8: Stringify mappings
fn test_stringify_mapping() {
    let mut map = yaml::yaml_mapping();
    map.set("name", yaml::yaml_string("Alice"));
    map.set("age", yaml::yaml_number(25.0));

    let yaml_str = yaml::stringify(map);
    assert(yaml_str.contains("name:"), "Should contain 'name:'");
    assert(yaml_str.contains("Alice"), "Should contain 'Alice'");
    assert(yaml_str.contains("age:"), "Should contain 'age:'");
    assert(yaml_str.contains("25"), "Should contain '25'");
}

// Test 9: YamlValue manipulation - sequences
fn test_yaml_value_sequence_manipulation() {
    let mut seq = yaml::yaml_sequence();
    assert_eq(seq.len(), 0, "Should start empty");

    seq.push(yaml::yaml_number(10.0));
    seq.push(yaml::yaml_string("test"));
    assert_eq(seq.len(), 2, "Should have 2 elements");

    let first = seq.get_index(0).unwrap();
    assert_eq(first.as_number().unwrap(), 10.0, "First element should be 10");

    let second = seq.get_index(1).unwrap();
    assert_eq(second.as_string().unwrap(), "test", "Second element should be 'test'");
}

// Test 10: YamlValue manipulation - mappings
fn test_yaml_value_mapping_manipulation() {
    let mut map = yaml::yaml_mapping();
    assert_eq(map.len(), 0, "Should start empty");

    map.set("key1", yaml::yaml_string("value1"));
    map.set("key2", yaml::yaml_number(100.0));
    assert_eq(map.len(), 2, "Should have 2 keys");

    let keys = map.keys();
    assert_eq(keys.len() as i64, 2, "Should have 2 keys");

    let val1 = map.get("key1").unwrap();
    assert_eq(val1.as_string().unwrap(), "value1", "Should get correct value");

    let val2 = map.get("key2").unwrap();
    assert_eq(val2.as_number().unwrap(), 100.0, "Should get correct number");
}

// Test 11: Type checking methods
fn test_type_checking() {
    let null_val = yaml::yaml_null();
    assert(null_val.is_null(), "Should be null type");
    assert(!null_val.is_string(), "Should not be string type");

    let bool_val = yaml::yaml_bool(true);
    assert(bool_val.is_bool(), "Should be bool type");
    assert(!bool_val.is_number(), "Should not be number type");

    let num_val = yaml::yaml_number(3.14);
    assert(num_val.is_number(), "Should be number type");
    assert(!num_val.is_sequence(), "Should not be sequence type");

    let str_val = yaml::yaml_string("test");
    assert(str_val.is_string(), "Should be string type");
    assert(!str_val.is_mapping(), "Should not be mapping type");
}

// Test 12: Quoted strings
fn test_quoted_strings() {
    let yaml_str = "\"hello world\"";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert_eq(value.as_string().unwrap(), "hello world", "Should parse quoted string");
}

// Test 13: Empty sequences and mappings
fn test_empty_collections() {
    let empty_seq = yaml::parse("[]");
    assert_ok(&empty_seq);
    let seq = empty_seq.unwrap();
    assert(seq.is_sequence(), "Should be a sequence");
    assert_eq(seq.len(), 0, "Should be empty");

    let empty_map = yaml::parse("{}");
    assert_ok(&empty_map);
    let map = empty_map.unwrap();
    assert(map.is_mapping(), "Should be a mapping");
    assert_eq(map.len(), 0, "Should be empty");
}

// Test 14: Stringify empty collections
fn test_stringify_empty() {
    let empty_seq = yaml::yaml_sequence();
    assert_eq(yaml::stringify(empty_seq), "[]", "Empty sequence should stringify to '[]'");

    let empty_map = yaml::yaml_mapping();
    assert_eq(yaml::stringify(empty_map), "{}", "Empty mapping should stringify to '{}'");
}

// Test 15: Complex nested structure
fn test_complex_nested_structure() {
    let yaml_str = "{database: {host: localhost, port: 5432, credentials: {user: admin, password: secret}}, enabled: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let db = value.get("database").unwrap();
    let host = db.get("host").unwrap();
    assert_eq(host.as_string().unwrap(), "localhost", "Host should be localhost");

    let port = db.get("port").unwrap();
    assert_eq(port.as_number().unwrap(), 5432.0, "Port should be 5432");

    let creds = db.get("credentials").unwrap();
    let user = creds.get("user").unwrap();
    assert_eq(user.as_string().unwrap(), "admin", "User should be admin");

    let enabled = value.get("enabled").unwrap();
    assert_eq(enabled.as_bool().unwrap(), true, "Enabled should be true");
}


// YAML Parser and Serializer Tests

// Test 1: Parse simple scalars
fn test_parse_scalars() {
    // Null
    let null_yaml = yaml::parse("null");
    assert_ok(&null_yaml);
    let null_val = null_yaml.unwrap();
    assert(null_val.is_null(), "Should be null");

    // Boolean
    let true_yaml = yaml::parse("true");
    assert_ok(&true_yaml);
    assert_eq(true_yaml.unwrap().as_bool().unwrap(), true, "Should be true");

    let false_yaml = yaml::parse("false");
    assert_ok(&false_yaml);
    assert_eq(false_yaml.unwrap().as_bool().unwrap(), false, "Should be false");

    // Number
    let num_yaml = yaml::parse("42");
    assert_ok(&num_yaml);
    assert_eq(num_yaml.unwrap().as_number().unwrap(), 42.0, "Should be 42");

    // String
    let str_yaml = yaml::parse("hello");
    assert_ok(&str_yaml);
    assert_eq(str_yaml.unwrap().as_string().unwrap(), "hello", "Should be 'hello'");
}

// Test 2: Parse flow sequences
fn test_parse_flow_sequence() {
    let yaml_str = "[1, 2, 3, 4, 5]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_sequence(), "Should be a sequence");

    let seq = value.as_sequence().unwrap();
    assert_eq(seq.len() as i64, 5, "Should have 5 elements");

    assert_eq(seq[0].as_number().unwrap(), 1.0, "First element should be 1");
    assert_eq(seq[1].as_number().unwrap(), 2.0, "Second element should be 2");
    assert_eq(seq[4].as_number().unwrap(), 5.0, "Fifth element should be 5");
}

// Test 3: Parse flow mappings
fn test_parse_flow_mapping() {
    let yaml_str = "{name: John, age: 30, active: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_mapping(), "Should be a mapping");

    let name = value.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "John", "Name should be John");

    let age = value.get("age").unwrap();
    assert_eq(age.as_number().unwrap(), 30.0, "Age should be 30");

    let active = value.get("active").unwrap();
    assert_eq(active.as_bool().unwrap(), true, "Active should be true");
}

// Test 4: Parse nested structures
fn test_parse_nested() {
    let yaml_str = "{user: {name: Alice, scores: [95, 87, 92]}}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let user = value.get("user").unwrap();
    assert(user.is_mapping(), "User should be a mapping");

    let name = user.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "Alice", "Name should be Alice");

    let scores = user.get("scores").unwrap();
    assert(scores.is_sequence(), "Scores should be a sequence");
    let scores_seq = scores.as_sequence().unwrap();
    assert_eq(scores_seq.len() as i64, 3, "Should have 3 scores");
}

// Test 5: Parse mixed sequences
fn test_parse_mixed_sequence() {
    let yaml_str = "[42, hello, true, null]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    let seq = value.as_sequence().unwrap();

    assert_eq(seq.len() as i64, 4, "Should have 4 elements");
    assert(seq[0].is_number(), "First should be number");
    assert(seq[1].is_string(), "Second should be string");
    assert(seq[2].is_bool(), "Third should be bool");
    assert(seq[3].is_null(), "Fourth should be null");
}

// Test 6: Stringify scalars
fn test_stringify_scalars() {
    let null_val = yaml::yaml_null();
    assert_eq(yaml::stringify(null_val), "null", "Null should stringify to 'null'");

    let bool_val = yaml::yaml_bool(true);
    assert_eq(yaml::stringify(bool_val), "true", "True should stringify to 'true'");

    let num_val = yaml::yaml_number(42.5);
    assert_eq(yaml::stringify(num_val), "42.5", "Number should stringify correctly");

    let str_val = yaml::yaml_string("hello");
    assert_eq(yaml::stringify(str_val), "hello", "String should stringify to itself");
}

// Test 7: Stringify sequences
fn test_stringify_sequence() {
    let mut seq = yaml::yaml_sequence();
    seq.push(yaml::yaml_number(1.0));
    seq.push(yaml::yaml_number(2.0));
    seq.push(yaml::yaml_number(3.0));

    let yaml_str = yaml::stringify(seq);
    assert(yaml_str.contains("- 1"), "Should contain '- 1'");
    assert(yaml_str.contains("- 2"), "Should contain '- 2'");
    assert(yaml_str.contains("- 3"), "Should contain '- 3'");
}

// Test 8: Stringify mappings
fn test_stringify_mapping() {
    let mut map = yaml::yaml_mapping();
    map.set("name", yaml::yaml_string("Alice"));
    map.set("age", yaml::yaml_number(25.0));

    let yaml_str = yaml::stringify(map);
    assert(yaml_str.contains("name:"), "Should contain 'name:'");
    assert(yaml_str.contains("Alice"), "Should contain 'Alice'");
    assert(yaml_str.contains("age:"), "Should contain 'age:'");
    assert(yaml_str.contains("25"), "Should contain '25'");
}

// Test 9: YamlValue manipulation - sequences
fn test_yaml_value_sequence_manipulation() {
    let mut seq = yaml::yaml_sequence();
    assert_eq(seq.len(), 0, "Should start empty");

    seq.push(yaml::yaml_number(10.0));
    seq.push(yaml::yaml_string("test"));
    assert_eq(seq.len(), 2, "Should have 2 elements");

    let first = seq.get_index(0).unwrap();
    assert_eq(first.as_number().unwrap(), 10.0, "First element should be 10");

    let second = seq.get_index(1).unwrap();
    assert_eq(second.as_string().unwrap(), "test", "Second element should be 'test'");
}

// Test 10: YamlValue manipulation - mappings
fn test_yaml_value_mapping_manipulation() {
    let mut map = yaml::yaml_mapping();
    assert_eq(map.len(), 0, "Should start empty");

    map.set("key1", yaml::yaml_string("value1"));
    map.set("key2", yaml::yaml_number(100.0));
    assert_eq(map.len(), 2, "Should have 2 keys");

    let keys = map.keys();
    assert_eq(keys.len() as i64, 2, "Should have 2 keys");

    let val1 = map.get("key1").unwrap();
    assert_eq(val1.as_string().unwrap(), "value1", "Should get correct value");

    let val2 = map.get("key2").unwrap();
    assert_eq(val2.as_number().unwrap(), 100.0, "Should get correct number");
}

// Test 11: Type checking methods
fn test_type_checking() {
    let null_val = yaml::yaml_null();
    assert(null_val.is_null(), "Should be null type");
    assert(!null_val.is_string(), "Should not be string type");

    let bool_val = yaml::yaml_bool(true);
    assert(bool_val.is_bool(), "Should be bool type");
    assert(!bool_val.is_number(), "Should not be number type");

    let num_val = yaml::yaml_number(3.14);
    assert(num_val.is_number(), "Should be number type");
    assert(!num_val.is_sequence(), "Should not be sequence type");

    let str_val = yaml::yaml_string("test");
    assert(str_val.is_string(), "Should be string type");
    assert(!str_val.is_mapping(), "Should not be mapping type");
}

// Test 12: Quoted strings
fn test_quoted_strings() {
    let yaml_str = "\"hello world\"";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert_eq(value.as_string().unwrap(), "hello world", "Should parse quoted string");
}

// Test 13: Empty sequences and mappings
fn test_empty_collections() {
    let empty_seq = yaml::parse("[]");
    assert_ok(&empty_seq);
    let seq = empty_seq.unwrap();
    assert(seq.is_sequence(), "Should be a sequence");
    assert_eq(seq.len(), 0, "Should be empty");

    let empty_map = yaml::parse("{}");
    assert_ok(&empty_map);
    let map = empty_map.unwrap();
    assert(map.is_mapping(), "Should be a mapping");
    assert_eq(map.len(), 0, "Should be empty");
}

// Test 14: Stringify empty collections
fn test_stringify_empty() {
    let empty_seq = yaml::yaml_sequence();
    assert_eq(yaml::stringify(empty_seq), "[]", "Empty sequence should stringify to '[]'");

    let empty_map = yaml::yaml_mapping();
    assert_eq(yaml::stringify(empty_map), "{}", "Empty mapping should stringify to '{}'");
}

// Test 15: Complex nested structure
fn test_complex_nested_structure() {
    let yaml_str = "{database: {host: localhost, port: 5432, credentials: {user: admin, password: secret}}, enabled: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let db = value.get("database").unwrap();
    let host = db.get("host").unwrap();
    assert_eq(host.as_string().unwrap(), "localhost", "Host should be localhost");

    let port = db.get("port").unwrap();
    assert_eq(port.as_number().unwrap(), 5432.0, "Port should be 5432");

    let creds = db.get("credentials").unwrap();
    let user = creds.get("user").unwrap();
    assert_eq(user.as_string().unwrap(), "admin", "User should be admin");

    let enabled = value.get("enabled").unwrap();
    assert_eq(enabled.as_bool().unwrap(), true, "Enabled should be true");
}


// YAML Parser and Serializer Tests

// Test 1: Parse simple scalars
fn test_parse_scalars() {
    // Null
    let null_yaml = yaml::parse("null");
    assert_ok(&null_yaml);
    let null_val = null_yaml.unwrap();
    assert(null_val.is_null(), "Should be null");

    // Boolean
    let true_yaml = yaml::parse("true");
    assert_ok(&true_yaml);
    assert_eq(true_yaml.unwrap().as_bool().unwrap(), true, "Should be true");

    let false_yaml = yaml::parse("false");
    assert_ok(&false_yaml);
    assert_eq(false_yaml.unwrap().as_bool().unwrap(), false, "Should be false");

    // Number
    let num_yaml = yaml::parse("42");
    assert_ok(&num_yaml);
    assert_eq(num_yaml.unwrap().as_number().unwrap(), 42.0, "Should be 42");

    // String
    let str_yaml = yaml::parse("hello");
    assert_ok(&str_yaml);
    assert_eq(str_yaml.unwrap().as_string().unwrap(), "hello", "Should be 'hello'");
}

// Test 2: Parse flow sequences
fn test_parse_flow_sequence() {
    let yaml_str = "[1, 2, 3, 4, 5]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_sequence(), "Should be a sequence");

    let seq = value.as_sequence().unwrap();
    assert_eq(seq.len() as i64, 5, "Should have 5 elements");

    assert_eq(seq[0].as_number().unwrap(), 1.0, "First element should be 1");
    assert_eq(seq[1].as_number().unwrap(), 2.0, "Second element should be 2");
    assert_eq(seq[4].as_number().unwrap(), 5.0, "Fifth element should be 5");
}

// Test 3: Parse flow mappings
fn test_parse_flow_mapping() {
    let yaml_str = "{name: John, age: 30, active: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_mapping(), "Should be a mapping");

    let name = value.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "John", "Name should be John");

    let age = value.get("age").unwrap();
    assert_eq(age.as_number().unwrap(), 30.0, "Age should be 30");

    let active = value.get("active").unwrap();
    assert_eq(active.as_bool().unwrap(), true, "Active should be true");
}

// Test 4: Parse nested structures
fn test_parse_nested() {
    let yaml_str = "{user: {name: Alice, scores: [95, 87, 92]}}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let user = value.get("user").unwrap();
    assert(user.is_mapping(), "User should be a mapping");

    let name = user.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "Alice", "Name should be Alice");

    let scores = user.get("scores").unwrap();
    assert(scores.is_sequence(), "Scores should be a sequence");
    let scores_seq = scores.as_sequence().unwrap();
    assert_eq(scores_seq.len() as i64, 3, "Should have 3 scores");
}

// Test 5: Parse mixed sequences
fn test_parse_mixed_sequence() {
    let yaml_str = "[42, hello, true, null]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    let seq = value.as_sequence().unwrap();

    assert_eq(seq.len() as i64, 4, "Should have 4 elements");
    assert(seq[0].is_number(), "First should be number");
    assert(seq[1].is_string(), "Second should be string");
    assert(seq[2].is_bool(), "Third should be bool");
    assert(seq[3].is_null(), "Fourth should be null");
}

// Test 6: Stringify scalars
fn test_stringify_scalars() {
    let null_val = yaml::yaml_null();
    assert_eq(yaml::stringify(null_val), "null", "Null should stringify to 'null'");

    let bool_val = yaml::yaml_bool(true);
    assert_eq(yaml::stringify(bool_val), "true", "True should stringify to 'true'");

    let num_val = yaml::yaml_number(42.5);
    assert_eq(yaml::stringify(num_val), "42.5", "Number should stringify correctly");

    let str_val = yaml::yaml_string("hello");
    assert_eq(yaml::stringify(str_val), "hello", "String should stringify to itself");
}

// Test 7: Stringify sequences
fn test_stringify_sequence() {
    let mut seq = yaml::yaml_sequence();
    seq.push(yaml::yaml_number(1.0));
    seq.push(yaml::yaml_number(2.0));
    seq.push(yaml::yaml_number(3.0));

    let yaml_str = yaml::stringify(seq);
    assert(yaml_str.contains("- 1"), "Should contain '- 1'");
    assert(yaml_str.contains("- 2"), "Should contain '- 2'");
    assert(yaml_str.contains("- 3"), "Should contain '- 3'");
}

// Test 8: Stringify mappings
fn test_stringify_mapping() {
    let mut map = yaml::yaml_mapping();
    map.set("name", yaml::yaml_string("Alice"));
    map.set("age", yaml::yaml_number(25.0));

    let yaml_str = yaml::stringify(map);
    assert(yaml_str.contains("name:"), "Should contain 'name:'");
    assert(yaml_str.contains("Alice"), "Should contain 'Alice'");
    assert(yaml_str.contains("age:"), "Should contain 'age:'");
    assert(yaml_str.contains("25"), "Should contain '25'");
}

// Test 9: YamlValue manipulation - sequences
fn test_yaml_value_sequence_manipulation() {
    let mut seq = yaml::yaml_sequence();
    assert_eq(seq.len(), 0, "Should start empty");

    seq.push(yaml::yaml_number(10.0));
    seq.push(yaml::yaml_string("test"));
    assert_eq(seq.len(), 2, "Should have 2 elements");

    let first = seq.get_index(0).unwrap();
    assert_eq(first.as_number().unwrap(), 10.0, "First element should be 10");

    let second = seq.get_index(1).unwrap();
    assert_eq(second.as_string().unwrap(), "test", "Second element should be 'test'");
}

// Test 10: YamlValue manipulation - mappings
fn test_yaml_value_mapping_manipulation() {
    let mut map = yaml::yaml_mapping();
    assert_eq(map.len(), 0, "Should start empty");

    map.set("key1", yaml::yaml_string("value1"));
    map.set("key2", yaml::yaml_number(100.0));
    assert_eq(map.len(), 2, "Should have 2 keys");

    let keys = map.keys();
    assert_eq(keys.len() as i64, 2, "Should have 2 keys");

    let val1 = map.get("key1").unwrap();
    assert_eq(val1.as_string().unwrap(), "value1", "Should get correct value");

    let val2 = map.get("key2").unwrap();
    assert_eq(val2.as_number().unwrap(), 100.0, "Should get correct number");
}

// Test 11: Type checking methods
fn test_type_checking() {
    let null_val = yaml::yaml_null();
    assert(null_val.is_null(), "Should be null type");
    assert(!null_val.is_string(), "Should not be string type");

    let bool_val = yaml::yaml_bool(true);
    assert(bool_val.is_bool(), "Should be bool type");
    assert(!bool_val.is_number(), "Should not be number type");

    let num_val = yaml::yaml_number(3.14);
    assert(num_val.is_number(), "Should be number type");
    assert(!num_val.is_sequence(), "Should not be sequence type");

    let str_val = yaml::yaml_string("test");
    assert(str_val.is_string(), "Should be string type");
    assert(!str_val.is_mapping(), "Should not be mapping type");
}

// Test 12: Quoted strings
fn test_quoted_strings() {
    let yaml_str = "\"hello world\"";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert_eq(value.as_string().unwrap(), "hello world", "Should parse quoted string");
}

// Test 13: Empty sequences and mappings
fn test_empty_collections() {
    let empty_seq = yaml::parse("[]");
    assert_ok(&empty_seq);
    let seq = empty_seq.unwrap();
    assert(seq.is_sequence(), "Should be a sequence");
    assert_eq(seq.len(), 0, "Should be empty");

    let empty_map = yaml::parse("{}");
    assert_ok(&empty_map);
    let map = empty_map.unwrap();
    assert(map.is_mapping(), "Should be a mapping");
    assert_eq(map.len(), 0, "Should be empty");
}

// Test 14: Stringify empty collections
fn test_stringify_empty() {
    let empty_seq = yaml::yaml_sequence();
    assert_eq(yaml::stringify(empty_seq), "[]", "Empty sequence should stringify to '[]'");

    let empty_map = yaml::yaml_mapping();
    assert_eq(yaml::stringify(empty_map), "{}", "Empty mapping should stringify to '{}'");
}

// Test 15: Complex nested structure
fn test_complex_nested_structure() {
    let yaml_str = "{database: {host: localhost, port: 5432, credentials: {user: admin, password: secret}}, enabled: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let db = value.get("database").unwrap();
    let host = db.get("host").unwrap();
    assert_eq(host.as_string().unwrap(), "localhost", "Host should be localhost");

    let port = db.get("port").unwrap();
    assert_eq(port.as_number().unwrap(), 5432.0, "Port should be 5432");

    let creds = db.get("credentials").unwrap();
    let user = creds.get("user").unwrap();
    assert_eq(user.as_string().unwrap(), "admin", "User should be admin");

    let enabled = value.get("enabled").unwrap();
    assert_eq(enabled.as_bool().unwrap(), true, "Enabled should be true");
}


// YAML Parser and Serializer Tests

// Test 1: Parse simple scalars
fn test_parse_scalars() {
    // Null
    let null_yaml = yaml::parse("null");
    assert_ok(&null_yaml);
    let null_val = null_yaml.unwrap();
    assert(null_val.is_null(), "Should be null");

    // Boolean
    let true_yaml = yaml::parse("true");
    assert_ok(&true_yaml);
    assert_eq(true_yaml.unwrap().as_bool().unwrap(), true, "Should be true");

    let false_yaml = yaml::parse("false");
    assert_ok(&false_yaml);
    assert_eq(false_yaml.unwrap().as_bool().unwrap(), false, "Should be false");

    // Number
    let num_yaml = yaml::parse("42");
    assert_ok(&num_yaml);
    assert_eq(num_yaml.unwrap().as_number().unwrap(), 42.0, "Should be 42");

    // String
    let str_yaml = yaml::parse("hello");
    assert_ok(&str_yaml);
    assert_eq(str_yaml.unwrap().as_string().unwrap(), "hello", "Should be 'hello'");
}

// Test 2: Parse flow sequences
fn test_parse_flow_sequence() {
    let yaml_str = "[1, 2, 3, 4, 5]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_sequence(), "Should be a sequence");

    let seq = value.as_sequence().unwrap();
    assert_eq(seq.len() as i64, 5, "Should have 5 elements");

    assert_eq(seq[0].as_number().unwrap(), 1.0, "First element should be 1");
    assert_eq(seq[1].as_number().unwrap(), 2.0, "Second element should be 2");
    assert_eq(seq[4].as_number().unwrap(), 5.0, "Fifth element should be 5");
}

// Test 3: Parse flow mappings
fn test_parse_flow_mapping() {
    let yaml_str = "{name: John, age: 30, active: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_mapping(), "Should be a mapping");

    let name = value.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "John", "Name should be John");

    let age = value.get("age").unwrap();
    assert_eq(age.as_number().unwrap(), 30.0, "Age should be 30");

    let active = value.get("active").unwrap();
    assert_eq(active.as_bool().unwrap(), true, "Active should be true");
}

// Test 4: Parse nested structures
fn test_parse_nested() {
    let yaml_str = "{user: {name: Alice, scores: [95, 87, 92]}}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let user = value.get("user").unwrap();
    assert(user.is_mapping(), "User should be a mapping");

    let name = user.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "Alice", "Name should be Alice");

    let scores = user.get("scores").unwrap();
    assert(scores.is_sequence(), "Scores should be a sequence");
    let scores_seq = scores.as_sequence().unwrap();
    assert_eq(scores_seq.len() as i64, 3, "Should have 3 scores");
}

// Test 5: Parse mixed sequences
fn test_parse_mixed_sequence() {
    let yaml_str = "[42, hello, true, null]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    let seq = value.as_sequence().unwrap();

    assert_eq(seq.len() as i64, 4, "Should have 4 elements");
    assert(seq[0].is_number(), "First should be number");
    assert(seq[1].is_string(), "Second should be string");
    assert(seq[2].is_bool(), "Third should be bool");
    assert(seq[3].is_null(), "Fourth should be null");
}

// Test 6: Stringify scalars
fn test_stringify_scalars() {
    let null_val = yaml::yaml_null();
    assert_eq(yaml::stringify(null_val), "null", "Null should stringify to 'null'");

    let bool_val = yaml::yaml_bool(true);
    assert_eq(yaml::stringify(bool_val), "true", "True should stringify to 'true'");

    let num_val = yaml::yaml_number(42.5);
    assert_eq(yaml::stringify(num_val), "42.5", "Number should stringify correctly");

    let str_val = yaml::yaml_string("hello");
    assert_eq(yaml::stringify(str_val), "hello", "String should stringify to itself");
}

// Test 7: Stringify sequences
fn test_stringify_sequence() {
    let mut seq = yaml::yaml_sequence();
    seq.push(yaml::yaml_number(1.0));
    seq.push(yaml::yaml_number(2.0));
    seq.push(yaml::yaml_number(3.0));

    let yaml_str = yaml::stringify(seq);
    assert(yaml_str.contains("- 1"), "Should contain '- 1'");
    assert(yaml_str.contains("- 2"), "Should contain '- 2'");
    assert(yaml_str.contains("- 3"), "Should contain '- 3'");
}

// Test 8: Stringify mappings
fn test_stringify_mapping() {
    let mut map = yaml::yaml_mapping();
    map.set("name", yaml::yaml_string("Alice"));
    map.set("age", yaml::yaml_number(25.0));

    let yaml_str = yaml::stringify(map);
    assert(yaml_str.contains("name:"), "Should contain 'name:'");
    assert(yaml_str.contains("Alice"), "Should contain 'Alice'");
    assert(yaml_str.contains("age:"), "Should contain 'age:'");
    assert(yaml_str.contains("25"), "Should contain '25'");
}

// Test 9: YamlValue manipulation - sequences
fn test_yaml_value_sequence_manipulation() {
    let mut seq = yaml::yaml_sequence();
    assert_eq(seq.len(), 0, "Should start empty");

    seq.push(yaml::yaml_number(10.0));
    seq.push(yaml::yaml_string("test"));
    assert_eq(seq.len(), 2, "Should have 2 elements");

    let first = seq.get_index(0).unwrap();
    assert_eq(first.as_number().unwrap(), 10.0, "First element should be 10");

    let second = seq.get_index(1).unwrap();
    assert_eq(second.as_string().unwrap(), "test", "Second element should be 'test'");
}

// Test 10: YamlValue manipulation - mappings
fn test_yaml_value_mapping_manipulation() {
    let mut map = yaml::yaml_mapping();
    assert_eq(map.len(), 0, "Should start empty");

    map.set("key1", yaml::yaml_string("value1"));
    map.set("key2", yaml::yaml_number(100.0));
    assert_eq(map.len(), 2, "Should have 2 keys");

    let keys = map.keys();
    assert_eq(keys.len() as i64, 2, "Should have 2 keys");

    let val1 = map.get("key1").unwrap();
    assert_eq(val1.as_string().unwrap(), "value1", "Should get correct value");

    let val2 = map.get("key2").unwrap();
    assert_eq(val2.as_number().unwrap(), 100.0, "Should get correct number");
}

// Test 11: Type checking methods
fn test_type_checking() {
    let null_val = yaml::yaml_null();
    assert(null_val.is_null(), "Should be null type");
    assert(!null_val.is_string(), "Should not be string type");

    let bool_val = yaml::yaml_bool(true);
    assert(bool_val.is_bool(), "Should be bool type");
    assert(!bool_val.is_number(), "Should not be number type");

    let num_val = yaml::yaml_number(3.14);
    assert(num_val.is_number(), "Should be number type");
    assert(!num_val.is_sequence(), "Should not be sequence type");

    let str_val = yaml::yaml_string("test");
    assert(str_val.is_string(), "Should be string type");
    assert(!str_val.is_mapping(), "Should not be mapping type");
}

// Test 12: Quoted strings
fn test_quoted_strings() {
    let yaml_str = "\"hello world\"";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert_eq(value.as_string().unwrap(), "hello world", "Should parse quoted string");
}

// Test 13: Empty sequences and mappings
fn test_empty_collections() {
    let empty_seq = yaml::parse("[]");
    assert_ok(&empty_seq);
    let seq = empty_seq.unwrap();
    assert(seq.is_sequence(), "Should be a sequence");
    assert_eq(seq.len(), 0, "Should be empty");

    let empty_map = yaml::parse("{}");
    assert_ok(&empty_map);
    let map = empty_map.unwrap();
    assert(map.is_mapping(), "Should be a mapping");
    assert_eq(map.len(), 0, "Should be empty");
}

// Test 14: Stringify empty collections
fn test_stringify_empty() {
    let empty_seq = yaml::yaml_sequence();
    assert_eq(yaml::stringify(empty_seq), "[]", "Empty sequence should stringify to '[]'");

    let empty_map = yaml::yaml_mapping();
    assert_eq(yaml::stringify(empty_map), "{}", "Empty mapping should stringify to '{}'");
}

// Test 15: Complex nested structure
fn test_complex_nested_structure() {
    let yaml_str = "{database: {host: localhost, port: 5432, credentials: {user: admin, password: secret}}, enabled: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let db = value.get("database").unwrap();
    let host = db.get("host").unwrap();
    assert_eq(host.as_string().unwrap(), "localhost", "Host should be localhost");

    let port = db.get("port").unwrap();
    assert_eq(port.as_number().unwrap(), 5432.0, "Port should be 5432");

    let creds = db.get("credentials").unwrap();
    let user = creds.get("user").unwrap();
    assert_eq(user.as_string().unwrap(), "admin", "User should be admin");

    let enabled = value.get("enabled").unwrap();
    assert_eq(enabled.as_bool().unwrap(), true, "Enabled should be true");
}


// YAML Parser and Serializer Tests

// Test 1: Parse simple scalars
fn test_parse_scalars() {
    // Null
    let null_yaml = yaml::parse("null");
    assert_ok(&null_yaml);
    let null_val = null_yaml.unwrap();
    assert(null_val.is_null(), "Should be null");

    // Boolean
    let true_yaml = yaml::parse("true");
    assert_ok(&true_yaml);
    assert_eq(true_yaml.unwrap().as_bool().unwrap(), true, "Should be true");

    let false_yaml = yaml::parse("false");
    assert_ok(&false_yaml);
    assert_eq(false_yaml.unwrap().as_bool().unwrap(), false, "Should be false");

    // Number
    let num_yaml = yaml::parse("42");
    assert_ok(&num_yaml);
    assert_eq(num_yaml.unwrap().as_number().unwrap(), 42.0, "Should be 42");

    // String
    let str_yaml = yaml::parse("hello");
    assert_ok(&str_yaml);
    assert_eq(str_yaml.unwrap().as_string().unwrap(), "hello", "Should be 'hello'");
}

// Test 2: Parse flow sequences
fn test_parse_flow_sequence() {
    let yaml_str = "[1, 2, 3, 4, 5]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_sequence(), "Should be a sequence");

    let seq = value.as_sequence().unwrap();
    assert_eq(seq.len() as i64, 5, "Should have 5 elements");

    assert_eq(seq[0].as_number().unwrap(), 1.0, "First element should be 1");
    assert_eq(seq[1].as_number().unwrap(), 2.0, "Second element should be 2");
    assert_eq(seq[4].as_number().unwrap(), 5.0, "Fifth element should be 5");
}

// Test 3: Parse flow mappings
fn test_parse_flow_mapping() {
    let yaml_str = "{name: John, age: 30, active: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_mapping(), "Should be a mapping");

    let name = value.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "John", "Name should be John");

    let age = value.get("age").unwrap();
    assert_eq(age.as_number().unwrap(), 30.0, "Age should be 30");

    let active = value.get("active").unwrap();
    assert_eq(active.as_bool().unwrap(), true, "Active should be true");
}

// Test 4: Parse nested structures
fn test_parse_nested() {
    let yaml_str = "{user: {name: Alice, scores: [95, 87, 92]}}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let user = value.get("user").unwrap();
    assert(user.is_mapping(), "User should be a mapping");

    let name = user.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "Alice", "Name should be Alice");

    let scores = user.get("scores").unwrap();
    assert(scores.is_sequence(), "Scores should be a sequence");
    let scores_seq = scores.as_sequence().unwrap();
    assert_eq(scores_seq.len() as i64, 3, "Should have 3 scores");
}

// Test 5: Parse mixed sequences
fn test_parse_mixed_sequence() {
    let yaml_str = "[42, hello, true, null]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    let seq = value.as_sequence().unwrap();

    assert_eq(seq.len() as i64, 4, "Should have 4 elements");
    assert(seq[0].is_number(), "First should be number");
    assert(seq[1].is_string(), "Second should be string");
    assert(seq[2].is_bool(), "Third should be bool");
    assert(seq[3].is_null(), "Fourth should be null");
}

// Test 6: Stringify scalars
fn test_stringify_scalars() {
    let null_val = yaml::yaml_null();
    assert_eq(yaml::stringify(null_val), "null", "Null should stringify to 'null'");

    let bool_val = yaml::yaml_bool(true);
    assert_eq(yaml::stringify(bool_val), "true", "True should stringify to 'true'");

    let num_val = yaml::yaml_number(42.5);
    assert_eq(yaml::stringify(num_val), "42.5", "Number should stringify correctly");

    let str_val = yaml::yaml_string("hello");
    assert_eq(yaml::stringify(str_val), "hello", "String should stringify to itself");
}

// Test 7: Stringify sequences
fn test_stringify_sequence() {
    let mut seq = yaml::yaml_sequence();
    seq.push(yaml::yaml_number(1.0));
    seq.push(yaml::yaml_number(2.0));
    seq.push(yaml::yaml_number(3.0));

    let yaml_str = yaml::stringify(seq);
    assert(yaml_str.contains("- 1"), "Should contain '- 1'");
    assert(yaml_str.contains("- 2"), "Should contain '- 2'");
    assert(yaml_str.contains("- 3"), "Should contain '- 3'");
}

// Test 8: Stringify mappings
fn test_stringify_mapping() {
    let mut map = yaml::yaml_mapping();
    map.set("name", yaml::yaml_string("Alice"));
    map.set("age", yaml::yaml_number(25.0));

    let yaml_str = yaml::stringify(map);
    assert(yaml_str.contains("name:"), "Should contain 'name:'");
    assert(yaml_str.contains("Alice"), "Should contain 'Alice'");
    assert(yaml_str.contains("age:"), "Should contain 'age:'");
    assert(yaml_str.contains("25"), "Should contain '25'");
}

// Test 9: YamlValue manipulation - sequences
fn test_yaml_value_sequence_manipulation() {
    let mut seq = yaml::yaml_sequence();
    assert_eq(seq.len(), 0, "Should start empty");

    seq.push(yaml::yaml_number(10.0));
    seq.push(yaml::yaml_string("test"));
    assert_eq(seq.len(), 2, "Should have 2 elements");

    let first = seq.get_index(0).unwrap();
    assert_eq(first.as_number().unwrap(), 10.0, "First element should be 10");

    let second = seq.get_index(1).unwrap();
    assert_eq(second.as_string().unwrap(), "test", "Second element should be 'test'");
}

// Test 10: YamlValue manipulation - mappings
fn test_yaml_value_mapping_manipulation() {
    let mut map = yaml::yaml_mapping();
    assert_eq(map.len(), 0, "Should start empty");

    map.set("key1", yaml::yaml_string("value1"));
    map.set("key2", yaml::yaml_number(100.0));
    assert_eq(map.len(), 2, "Should have 2 keys");

    let keys = map.keys();
    assert_eq(keys.len() as i64, 2, "Should have 2 keys");

    let val1 = map.get("key1").unwrap();
    assert_eq(val1.as_string().unwrap(), "value1", "Should get correct value");

    let val2 = map.get("key2").unwrap();
    assert_eq(val2.as_number().unwrap(), 100.0, "Should get correct number");
}

// Test 11: Type checking methods
fn test_type_checking() {
    let null_val = yaml::yaml_null();
    assert(null_val.is_null(), "Should be null type");
    assert(!null_val.is_string(), "Should not be string type");

    let bool_val = yaml::yaml_bool(true);
    assert(bool_val.is_bool(), "Should be bool type");
    assert(!bool_val.is_number(), "Should not be number type");

    let num_val = yaml::yaml_number(3.14);
    assert(num_val.is_number(), "Should be number type");
    assert(!num_val.is_sequence(), "Should not be sequence type");

    let str_val = yaml::yaml_string("test");
    assert(str_val.is_string(), "Should be string type");
    assert(!str_val.is_mapping(), "Should not be mapping type");
}

// Test 12: Quoted strings
fn test_quoted_strings() {
    let yaml_str = "\"hello world\"";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert_eq(value.as_string().unwrap(), "hello world", "Should parse quoted string");
}

// Test 13: Empty sequences and mappings
fn test_empty_collections() {
    let empty_seq = yaml::parse("[]");
    assert_ok(&empty_seq);
    let seq = empty_seq.unwrap();
    assert(seq.is_sequence(), "Should be a sequence");
    assert_eq(seq.len(), 0, "Should be empty");

    let empty_map = yaml::parse("{}");
    assert_ok(&empty_map);
    let map = empty_map.unwrap();
    assert(map.is_mapping(), "Should be a mapping");
    assert_eq(map.len(), 0, "Should be empty");
}

// Test 14: Stringify empty collections
fn test_stringify_empty() {
    let empty_seq = yaml::yaml_sequence();
    assert_eq(yaml::stringify(empty_seq), "[]", "Empty sequence should stringify to '[]'");

    let empty_map = yaml::yaml_mapping();
    assert_eq(yaml::stringify(empty_map), "{}", "Empty mapping should stringify to '{}'");
}

// Test 15: Complex nested structure
fn test_complex_nested_structure() {
    let yaml_str = "{database: {host: localhost, port: 5432, credentials: {user: admin, password: secret}}, enabled: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let db = value.get("database").unwrap();
    let host = db.get("host").unwrap();
    assert_eq(host.as_string().unwrap(), "localhost", "Host should be localhost");

    let port = db.get("port").unwrap();
    assert_eq(port.as_number().unwrap(), 5432.0, "Port should be 5432");

    let creds = db.get("credentials").unwrap();
    let user = creds.get("user").unwrap();
    assert_eq(user.as_string().unwrap(), "admin", "User should be admin");

    let enabled = value.get("enabled").unwrap();
    assert_eq(enabled.as_bool().unwrap(), true, "Enabled should be true");
}


// YAML Parser and Serializer Tests

// Test 1: Parse simple scalars
fn test_parse_scalars() {
    // Null
    let null_yaml = yaml::parse("null");
    assert_ok(&null_yaml);
    let null_val = null_yaml.unwrap();
    assert(null_val.is_null(), "Should be null");

    // Boolean
    let true_yaml = yaml::parse("true");
    assert_ok(&true_yaml);
    assert_eq(true_yaml.unwrap().as_bool().unwrap(), true, "Should be true");

    let false_yaml = yaml::parse("false");
    assert_ok(&false_yaml);
    assert_eq(false_yaml.unwrap().as_bool().unwrap(), false, "Should be false");

    // Number
    let num_yaml = yaml::parse("42");
    assert_ok(&num_yaml);
    assert_eq(num_yaml.unwrap().as_number().unwrap(), 42.0, "Should be 42");

    // String
    let str_yaml = yaml::parse("hello");
    assert_ok(&str_yaml);
    assert_eq(str_yaml.unwrap().as_string().unwrap(), "hello", "Should be 'hello'");
}

// Test 2: Parse flow sequences
fn test_parse_flow_sequence() {
    let yaml_str = "[1, 2, 3, 4, 5]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_sequence(), "Should be a sequence");

    let seq = value.as_sequence().unwrap();
    assert_eq(seq.len() as i64, 5, "Should have 5 elements");

    assert_eq(seq[0].as_number().unwrap(), 1.0, "First element should be 1");
    assert_eq(seq[1].as_number().unwrap(), 2.0, "Second element should be 2");
    assert_eq(seq[4].as_number().unwrap(), 5.0, "Fifth element should be 5");
}

// Test 3: Parse flow mappings
fn test_parse_flow_mapping() {
    let yaml_str = "{name: John, age: 30, active: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_mapping(), "Should be a mapping");

    let name = value.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "John", "Name should be John");

    let age = value.get("age").unwrap();
    assert_eq(age.as_number().unwrap(), 30.0, "Age should be 30");

    let active = value.get("active").unwrap();
    assert_eq(active.as_bool().unwrap(), true, "Active should be true");
}

// Test 4: Parse nested structures
fn test_parse_nested() {
    let yaml_str = "{user: {name: Alice, scores: [95, 87, 92]}}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let user = value.get("user").unwrap();
    assert(user.is_mapping(), "User should be a mapping");

    let name = user.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "Alice", "Name should be Alice");

    let scores = user.get("scores").unwrap();
    assert(scores.is_sequence(), "Scores should be a sequence");
    let scores_seq = scores.as_sequence().unwrap();
    assert_eq(scores_seq.len() as i64, 3, "Should have 3 scores");
}

// Test 5: Parse mixed sequences
fn test_parse_mixed_sequence() {
    let yaml_str = "[42, hello, true, null]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    let seq = value.as_sequence().unwrap();

    assert_eq(seq.len() as i64, 4, "Should have 4 elements");
    assert(seq[0].is_number(), "First should be number");
    assert(seq[1].is_string(), "Second should be string");
    assert(seq[2].is_bool(), "Third should be bool");
    assert(seq[3].is_null(), "Fourth should be null");
}

// Test 6: Stringify scalars
fn test_stringify_scalars() {
    let null_val = yaml::yaml_null();
    assert_eq(yaml::stringify(null_val), "null", "Null should stringify to 'null'");

    let bool_val = yaml::yaml_bool(true);
    assert_eq(yaml::stringify(bool_val), "true", "True should stringify to 'true'");

    let num_val = yaml::yaml_number(42.5);
    assert_eq(yaml::stringify(num_val), "42.5", "Number should stringify correctly");

    let str_val = yaml::yaml_string("hello");
    assert_eq(yaml::stringify(str_val), "hello", "String should stringify to itself");
}

// Test 7: Stringify sequences
fn test_stringify_sequence() {
    let mut seq = yaml::yaml_sequence();
    seq.push(yaml::yaml_number(1.0));
    seq.push(yaml::yaml_number(2.0));
    seq.push(yaml::yaml_number(3.0));

    let yaml_str = yaml::stringify(seq);
    assert(yaml_str.contains("- 1"), "Should contain '- 1'");
    assert(yaml_str.contains("- 2"), "Should contain '- 2'");
    assert(yaml_str.contains("- 3"), "Should contain '- 3'");
}

// Test 8: Stringify mappings
fn test_stringify_mapping() {
    let mut map = yaml::yaml_mapping();
    map.set("name", yaml::yaml_string("Alice"));
    map.set("age", yaml::yaml_number(25.0));

    let yaml_str = yaml::stringify(map);
    assert(yaml_str.contains("name:"), "Should contain 'name:'");
    assert(yaml_str.contains("Alice"), "Should contain 'Alice'");
    assert(yaml_str.contains("age:"), "Should contain 'age:'");
    assert(yaml_str.contains("25"), "Should contain '25'");
}

// Test 9: YamlValue manipulation - sequences
fn test_yaml_value_sequence_manipulation() {
    let mut seq = yaml::yaml_sequence();
    assert_eq(seq.len(), 0, "Should start empty");

    seq.push(yaml::yaml_number(10.0));
    seq.push(yaml::yaml_string("test"));
    assert_eq(seq.len(), 2, "Should have 2 elements");

    let first = seq.get_index(0).unwrap();
    assert_eq(first.as_number().unwrap(), 10.0, "First element should be 10");

    let second = seq.get_index(1).unwrap();
    assert_eq(second.as_string().unwrap(), "test", "Second element should be 'test'");
}

// Test 10: YamlValue manipulation - mappings
fn test_yaml_value_mapping_manipulation() {
    let mut map = yaml::yaml_mapping();
    assert_eq(map.len(), 0, "Should start empty");

    map.set("key1", yaml::yaml_string("value1"));
    map.set("key2", yaml::yaml_number(100.0));
    assert_eq(map.len(), 2, "Should have 2 keys");

    let keys = map.keys();
    assert_eq(keys.len() as i64, 2, "Should have 2 keys");

    let val1 = map.get("key1").unwrap();
    assert_eq(val1.as_string().unwrap(), "value1", "Should get correct value");

    let val2 = map.get("key2").unwrap();
    assert_eq(val2.as_number().unwrap(), 100.0, "Should get correct number");
}

// Test 11: Type checking methods
fn test_type_checking() {
    let null_val = yaml::yaml_null();
    assert(null_val.is_null(), "Should be null type");
    assert(!null_val.is_string(), "Should not be string type");

    let bool_val = yaml::yaml_bool(true);
    assert(bool_val.is_bool(), "Should be bool type");
    assert(!bool_val.is_number(), "Should not be number type");

    let num_val = yaml::yaml_number(3.14);
    assert(num_val.is_number(), "Should be number type");
    assert(!num_val.is_sequence(), "Should not be sequence type");

    let str_val = yaml::yaml_string("test");
    assert(str_val.is_string(), "Should be string type");
    assert(!str_val.is_mapping(), "Should not be mapping type");
}

// Test 12: Quoted strings
fn test_quoted_strings() {
    let yaml_str = "\"hello world\"";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert_eq(value.as_string().unwrap(), "hello world", "Should parse quoted string");
}

// Test 13: Empty sequences and mappings
fn test_empty_collections() {
    let empty_seq = yaml::parse("[]");
    assert_ok(&empty_seq);
    let seq = empty_seq.unwrap();
    assert(seq.is_sequence(), "Should be a sequence");
    assert_eq(seq.len(), 0, "Should be empty");

    let empty_map = yaml::parse("{}");
    assert_ok(&empty_map);
    let map = empty_map.unwrap();
    assert(map.is_mapping(), "Should be a mapping");
    assert_eq(map.len(), 0, "Should be empty");
}

// Test 14: Stringify empty collections
fn test_stringify_empty() {
    let empty_seq = yaml::yaml_sequence();
    assert_eq(yaml::stringify(empty_seq), "[]", "Empty sequence should stringify to '[]'");

    let empty_map = yaml::yaml_mapping();
    assert_eq(yaml::stringify(empty_map), "{}", "Empty mapping should stringify to '{}'");
}

// Test 15: Complex nested structure
fn test_complex_nested_structure() {
    let yaml_str = "{database: {host: localhost, port: 5432, credentials: {user: admin, password: secret}}, enabled: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let db = value.get("database").unwrap();
    let host = db.get("host").unwrap();
    assert_eq(host.as_string().unwrap(), "localhost", "Host should be localhost");

    let port = db.get("port").unwrap();
    assert_eq(port.as_number().unwrap(), 5432.0, "Port should be 5432");

    let creds = db.get("credentials").unwrap();
    let user = creds.get("user").unwrap();
    assert_eq(user.as_string().unwrap(), "admin", "User should be admin");

    let enabled = value.get("enabled").unwrap();
    assert_eq(enabled.as_bool().unwrap(), true, "Enabled should be true");
}


// YAML Parser and Serializer Tests

// Test 1: Parse simple scalars
fn test_parse_scalars() {
    // Null
    let null_yaml = yaml::parse("null");
    assert_ok(&null_yaml);
    let null_val = null_yaml.unwrap();
    assert(null_val.is_null(), "Should be null");

    // Boolean
    let true_yaml = yaml::parse("true");
    assert_ok(&true_yaml);
    assert_eq(true_yaml.unwrap().as_bool().unwrap(), true, "Should be true");

    let false_yaml = yaml::parse("false");
    assert_ok(&false_yaml);
    assert_eq(false_yaml.unwrap().as_bool().unwrap(), false, "Should be false");

    // Number
    let num_yaml = yaml::parse("42");
    assert_ok(&num_yaml);
    assert_eq(num_yaml.unwrap().as_number().unwrap(), 42.0, "Should be 42");

    // String
    let str_yaml = yaml::parse("hello");
    assert_ok(&str_yaml);
    assert_eq(str_yaml.unwrap().as_string().unwrap(), "hello", "Should be 'hello'");
}

// Test 2: Parse flow sequences
fn test_parse_flow_sequence() {
    let yaml_str = "[1, 2, 3, 4, 5]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_sequence(), "Should be a sequence");

    let seq = value.as_sequence().unwrap();
    assert_eq(seq.len() as i64, 5, "Should have 5 elements");

    assert_eq(seq[0].as_number().unwrap(), 1.0, "First element should be 1");
    assert_eq(seq[1].as_number().unwrap(), 2.0, "Second element should be 2");
    assert_eq(seq[4].as_number().unwrap(), 5.0, "Fifth element should be 5");
}

// Test 3: Parse flow mappings
fn test_parse_flow_mapping() {
    let yaml_str = "{name: John, age: 30, active: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_mapping(), "Should be a mapping");

    let name = value.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "John", "Name should be John");

    let age = value.get("age").unwrap();
    assert_eq(age.as_number().unwrap(), 30.0, "Age should be 30");

    let active = value.get("active").unwrap();
    assert_eq(active.as_bool().unwrap(), true, "Active should be true");
}

// Test 4: Parse nested structures
fn test_parse_nested() {
    let yaml_str = "{user: {name: Alice, scores: [95, 87, 92]}}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let user = value.get("user").unwrap();
    assert(user.is_mapping(), "User should be a mapping");

    let name = user.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "Alice", "Name should be Alice");

    let scores = user.get("scores").unwrap();
    assert(scores.is_sequence(), "Scores should be a sequence");
    let scores_seq = scores.as_sequence().unwrap();
    assert_eq(scores_seq.len() as i64, 3, "Should have 3 scores");
}

// Test 5: Parse mixed sequences
fn test_parse_mixed_sequence() {
    let yaml_str = "[42, hello, true, null]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    let seq = value.as_sequence().unwrap();

    assert_eq(seq.len() as i64, 4, "Should have 4 elements");
    assert(seq[0].is_number(), "First should be number");
    assert(seq[1].is_string(), "Second should be string");
    assert(seq[2].is_bool(), "Third should be bool");
    assert(seq[3].is_null(), "Fourth should be null");
}

// Test 6: Stringify scalars
fn test_stringify_scalars() {
    let null_val = yaml::yaml_null();
    assert_eq(yaml::stringify(null_val), "null", "Null should stringify to 'null'");

    let bool_val = yaml::yaml_bool(true);
    assert_eq(yaml::stringify(bool_val), "true", "True should stringify to 'true'");

    let num_val = yaml::yaml_number(42.5);
    assert_eq(yaml::stringify(num_val), "42.5", "Number should stringify correctly");

    let str_val = yaml::yaml_string("hello");
    assert_eq(yaml::stringify(str_val), "hello", "String should stringify to itself");
}

// Test 7: Stringify sequences
fn test_stringify_sequence() {
    let mut seq = yaml::yaml_sequence();
    seq.push(yaml::yaml_number(1.0));
    seq.push(yaml::yaml_number(2.0));
    seq.push(yaml::yaml_number(3.0));

    let yaml_str = yaml::stringify(seq);
    assert(yaml_str.contains("- 1"), "Should contain '- 1'");
    assert(yaml_str.contains("- 2"), "Should contain '- 2'");
    assert(yaml_str.contains("- 3"), "Should contain '- 3'");
}

// Test 8: Stringify mappings
fn test_stringify_mapping() {
    let mut map = yaml::yaml_mapping();
    map.set("name", yaml::yaml_string("Alice"));
    map.set("age", yaml::yaml_number(25.0));

    let yaml_str = yaml::stringify(map);
    assert(yaml_str.contains("name:"), "Should contain 'name:'");
    assert(yaml_str.contains("Alice"), "Should contain 'Alice'");
    assert(yaml_str.contains("age:"), "Should contain 'age:'");
    assert(yaml_str.contains("25"), "Should contain '25'");
}

// Test 9: YamlValue manipulation - sequences
fn test_yaml_value_sequence_manipulation() {
    let mut seq = yaml::yaml_sequence();
    assert_eq(seq.len(), 0, "Should start empty");

    seq.push(yaml::yaml_number(10.0));
    seq.push(yaml::yaml_string("test"));
    assert_eq(seq.len(), 2, "Should have 2 elements");

    let first = seq.get_index(0).unwrap();
    assert_eq(first.as_number().unwrap(), 10.0, "First element should be 10");

    let second = seq.get_index(1).unwrap();
    assert_eq(second.as_string().unwrap(), "test", "Second element should be 'test'");
}

// Test 10: YamlValue manipulation - mappings
fn test_yaml_value_mapping_manipulation() {
    let mut map = yaml::yaml_mapping();
    assert_eq(map.len(), 0, "Should start empty");

    map.set("key1", yaml::yaml_string("value1"));
    map.set("key2", yaml::yaml_number(100.0));
    assert_eq(map.len(), 2, "Should have 2 keys");

    let keys = map.keys();
    assert_eq(keys.len() as i64, 2, "Should have 2 keys");

    let val1 = map.get("key1").unwrap();
    assert_eq(val1.as_string().unwrap(), "value1", "Should get correct value");

    let val2 = map.get("key2").unwrap();
    assert_eq(val2.as_number().unwrap(), 100.0, "Should get correct number");
}

// Test 11: Type checking methods
fn test_type_checking() {
    let null_val = yaml::yaml_null();
    assert(null_val.is_null(), "Should be null type");
    assert(!null_val.is_string(), "Should not be string type");

    let bool_val = yaml::yaml_bool(true);
    assert(bool_val.is_bool(), "Should be bool type");
    assert(!bool_val.is_number(), "Should not be number type");

    let num_val = yaml::yaml_number(3.14);
    assert(num_val.is_number(), "Should be number type");
    assert(!num_val.is_sequence(), "Should not be sequence type");

    let str_val = yaml::yaml_string("test");
    assert(str_val.is_string(), "Should be string type");
    assert(!str_val.is_mapping(), "Should not be mapping type");
}

// Test 12: Quoted strings
fn test_quoted_strings() {
    let yaml_str = "\"hello world\"";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert_eq(value.as_string().unwrap(), "hello world", "Should parse quoted string");
}

// Test 13: Empty sequences and mappings
fn test_empty_collections() {
    let empty_seq = yaml::parse("[]");
    assert_ok(&empty_seq);
    let seq = empty_seq.unwrap();
    assert(seq.is_sequence(), "Should be a sequence");
    assert_eq(seq.len(), 0, "Should be empty");

    let empty_map = yaml::parse("{}");
    assert_ok(&empty_map);
    let map = empty_map.unwrap();
    assert(map.is_mapping(), "Should be a mapping");
    assert_eq(map.len(), 0, "Should be empty");
}

// Test 14: Stringify empty collections
fn test_stringify_empty() {
    let empty_seq = yaml::yaml_sequence();
    assert_eq(yaml::stringify(empty_seq), "[]", "Empty sequence should stringify to '[]'");

    let empty_map = yaml::yaml_mapping();
    assert_eq(yaml::stringify(empty_map), "{}", "Empty mapping should stringify to '{}'");
}

// Test 15: Complex nested structure
fn test_complex_nested_structure() {
    let yaml_str = "{database: {host: localhost, port: 5432, credentials: {user: admin, password: secret}}, enabled: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let db = value.get("database").unwrap();
    let host = db.get("host").unwrap();
    assert_eq(host.as_string().unwrap(), "localhost", "Host should be localhost");

    let port = db.get("port").unwrap();
    assert_eq(port.as_number().unwrap(), 5432.0, "Port should be 5432");

    let creds = db.get("credentials").unwrap();
    let user = creds.get("user").unwrap();
    assert_eq(user.as_string().unwrap(), "admin", "User should be admin");

    let enabled = value.get("enabled").unwrap();
    assert_eq(enabled.as_bool().unwrap(), true, "Enabled should be true");
}


// YAML Parser and Serializer Tests

// Test 1: Parse simple scalars
fn test_parse_scalars() {
    // Null
    let null_yaml = yaml::parse("null");
    assert_ok(&null_yaml);
    let null_val = null_yaml.unwrap();
    assert(null_val.is_null(), "Should be null");

    // Boolean
    let true_yaml = yaml::parse("true");
    assert_ok(&true_yaml);
    assert_eq(true_yaml.unwrap().as_bool().unwrap(), true, "Should be true");

    let false_yaml = yaml::parse("false");
    assert_ok(&false_yaml);
    assert_eq(false_yaml.unwrap().as_bool().unwrap(), false, "Should be false");

    // Number
    let num_yaml = yaml::parse("42");
    assert_ok(&num_yaml);
    assert_eq(num_yaml.unwrap().as_number().unwrap(), 42.0, "Should be 42");

    // String
    let str_yaml = yaml::parse("hello");
    assert_ok(&str_yaml);
    assert_eq(str_yaml.unwrap().as_string().unwrap(), "hello", "Should be 'hello'");
}

// Test 2: Parse flow sequences
fn test_parse_flow_sequence() {
    let yaml_str = "[1, 2, 3, 4, 5]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_sequence(), "Should be a sequence");

    let seq = value.as_sequence().unwrap();
    assert_eq(seq.len() as i64, 5, "Should have 5 elements");

    assert_eq(seq[0].as_number().unwrap(), 1.0, "First element should be 1");
    assert_eq(seq[1].as_number().unwrap(), 2.0, "Second element should be 2");
    assert_eq(seq[4].as_number().unwrap(), 5.0, "Fifth element should be 5");
}

// Test 3: Parse flow mappings
fn test_parse_flow_mapping() {
    let yaml_str = "{name: John, age: 30, active: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_mapping(), "Should be a mapping");

    let name = value.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "John", "Name should be John");

    let age = value.get("age").unwrap();
    assert_eq(age.as_number().unwrap(), 30.0, "Age should be 30");

    let active = value.get("active").unwrap();
    assert_eq(active.as_bool().unwrap(), true, "Active should be true");
}

// Test 4: Parse nested structures
fn test_parse_nested() {
    let yaml_str = "{user: {name: Alice, scores: [95, 87, 92]}}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let user = value.get("user").unwrap();
    assert(user.is_mapping(), "User should be a mapping");

    let name = user.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "Alice", "Name should be Alice");

    let scores = user.get("scores").unwrap();
    assert(scores.is_sequence(), "Scores should be a sequence");
    let scores_seq = scores.as_sequence().unwrap();
    assert_eq(scores_seq.len() as i64, 3, "Should have 3 scores");
}

// Test 5: Parse mixed sequences
fn test_parse_mixed_sequence() {
    let yaml_str = "[42, hello, true, null]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    let seq = value.as_sequence().unwrap();

    assert_eq(seq.len() as i64, 4, "Should have 4 elements");
    assert(seq[0].is_number(), "First should be number");
    assert(seq[1].is_string(), "Second should be string");
    assert(seq[2].is_bool(), "Third should be bool");
    assert(seq[3].is_null(), "Fourth should be null");
}

// Test 6: Stringify scalars
fn test_stringify_scalars() {
    let null_val = yaml::yaml_null();
    assert_eq(yaml::stringify(null_val), "null", "Null should stringify to 'null'");

    let bool_val = yaml::yaml_bool(true);
    assert_eq(yaml::stringify(bool_val), "true", "True should stringify to 'true'");

    let num_val = yaml::yaml_number(42.5);
    assert_eq(yaml::stringify(num_val), "42.5", "Number should stringify correctly");

    let str_val = yaml::yaml_string("hello");
    assert_eq(yaml::stringify(str_val), "hello", "String should stringify to itself");
}

// Test 7: Stringify sequences
fn test_stringify_sequence() {
    let mut seq = yaml::yaml_sequence();
    seq.push(yaml::yaml_number(1.0));
    seq.push(yaml::yaml_number(2.0));
    seq.push(yaml::yaml_number(3.0));

    let yaml_str = yaml::stringify(seq);
    assert(yaml_str.contains("- 1"), "Should contain '- 1'");
    assert(yaml_str.contains("- 2"), "Should contain '- 2'");
    assert(yaml_str.contains("- 3"), "Should contain '- 3'");
}

// Test 8: Stringify mappings
fn test_stringify_mapping() {
    let mut map = yaml::yaml_mapping();
    map.set("name", yaml::yaml_string("Alice"));
    map.set("age", yaml::yaml_number(25.0));

    let yaml_str = yaml::stringify(map);
    assert(yaml_str.contains("name:"), "Should contain 'name:'");
    assert(yaml_str.contains("Alice"), "Should contain 'Alice'");
    assert(yaml_str.contains("age:"), "Should contain 'age:'");
    assert(yaml_str.contains("25"), "Should contain '25'");
}

// Test 9: YamlValue manipulation - sequences
fn test_yaml_value_sequence_manipulation() {
    let mut seq = yaml::yaml_sequence();
    assert_eq(seq.len(), 0, "Should start empty");

    seq.push(yaml::yaml_number(10.0));
    seq.push(yaml::yaml_string("test"));
    assert_eq(seq.len(), 2, "Should have 2 elements");

    let first = seq.get_index(0).unwrap();
    assert_eq(first.as_number().unwrap(), 10.0, "First element should be 10");

    let second = seq.get_index(1).unwrap();
    assert_eq(second.as_string().unwrap(), "test", "Second element should be 'test'");
}

// Test 10: YamlValue manipulation - mappings
fn test_yaml_value_mapping_manipulation() {
    let mut map = yaml::yaml_mapping();
    assert_eq(map.len(), 0, "Should start empty");

    map.set("key1", yaml::yaml_string("value1"));
    map.set("key2", yaml::yaml_number(100.0));
    assert_eq(map.len(), 2, "Should have 2 keys");

    let keys = map.keys();
    assert_eq(keys.len() as i64, 2, "Should have 2 keys");

    let val1 = map.get("key1").unwrap();
    assert_eq(val1.as_string().unwrap(), "value1", "Should get correct value");

    let val2 = map.get("key2").unwrap();
    assert_eq(val2.as_number().unwrap(), 100.0, "Should get correct number");
}

// Test 11: Type checking methods
fn test_type_checking() {
    let null_val = yaml::yaml_null();
    assert(null_val.is_null(), "Should be null type");
    assert(!null_val.is_string(), "Should not be string type");

    let bool_val = yaml::yaml_bool(true);
    assert(bool_val.is_bool(), "Should be bool type");
    assert(!bool_val.is_number(), "Should not be number type");

    let num_val = yaml::yaml_number(3.14);
    assert(num_val.is_number(), "Should be number type");
    assert(!num_val.is_sequence(), "Should not be sequence type");

    let str_val = yaml::yaml_string("test");
    assert(str_val.is_string(), "Should be string type");
    assert(!str_val.is_mapping(), "Should not be mapping type");
}

// Test 12: Quoted strings
fn test_quoted_strings() {
    let yaml_str = "\"hello world\"";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert_eq(value.as_string().unwrap(), "hello world", "Should parse quoted string");
}

// Test 13: Empty sequences and mappings
fn test_empty_collections() {
    let empty_seq = yaml::parse("[]");
    assert_ok(&empty_seq);
    let seq = empty_seq.unwrap();
    assert(seq.is_sequence(), "Should be a sequence");
    assert_eq(seq.len(), 0, "Should be empty");

    let empty_map = yaml::parse("{}");
    assert_ok(&empty_map);
    let map = empty_map.unwrap();
    assert(map.is_mapping(), "Should be a mapping");
    assert_eq(map.len(), 0, "Should be empty");
}

// Test 14: Stringify empty collections
fn test_stringify_empty() {
    let empty_seq = yaml::yaml_sequence();
    assert_eq(yaml::stringify(empty_seq), "[]", "Empty sequence should stringify to '[]'");

    let empty_map = yaml::yaml_mapping();
    assert_eq(yaml::stringify(empty_map), "{}", "Empty mapping should stringify to '{}'");
}

// Test 15: Complex nested structure
fn test_complex_nested_structure() {
    let yaml_str = "{database: {host: localhost, port: 5432, credentials: {user: admin, password: secret}}, enabled: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let db = value.get("database").unwrap();
    let host = db.get("host").unwrap();
    assert_eq(host.as_string().unwrap(), "localhost", "Host should be localhost");

    let port = db.get("port").unwrap();
    assert_eq(port.as_number().unwrap(), 5432.0, "Port should be 5432");

    let creds = db.get("credentials").unwrap();
    let user = creds.get("user").unwrap();
    assert_eq(user.as_string().unwrap(), "admin", "User should be admin");

    let enabled = value.get("enabled").unwrap();
    assert_eq(enabled.as_bool().unwrap(), true, "Enabled should be true");
}


// YAML Parser and Serializer Tests

// Test 1: Parse simple scalars
fn test_parse_scalars() {
    // Null
    let null_yaml = yaml::parse("null");
    assert_ok(&null_yaml);
    let null_val = null_yaml.unwrap();
    assert(null_val.is_null(), "Should be null");

    // Boolean
    let true_yaml = yaml::parse("true");
    assert_ok(&true_yaml);
    assert_eq(true_yaml.unwrap().as_bool().unwrap(), true, "Should be true");

    let false_yaml = yaml::parse("false");
    assert_ok(&false_yaml);
    assert_eq(false_yaml.unwrap().as_bool().unwrap(), false, "Should be false");

    // Number
    let num_yaml = yaml::parse("42");
    assert_ok(&num_yaml);
    assert_eq(num_yaml.unwrap().as_number().unwrap(), 42.0, "Should be 42");

    // String
    let str_yaml = yaml::parse("hello");
    assert_ok(&str_yaml);
    assert_eq(str_yaml.unwrap().as_string().unwrap(), "hello", "Should be 'hello'");
}

// Test 2: Parse flow sequences
fn test_parse_flow_sequence() {
    let yaml_str = "[1, 2, 3, 4, 5]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_sequence(), "Should be a sequence");

    let seq = value.as_sequence().unwrap();
    assert_eq(seq.len() as i64, 5, "Should have 5 elements");

    assert_eq(seq[0].as_number().unwrap(), 1.0, "First element should be 1");
    assert_eq(seq[1].as_number().unwrap(), 2.0, "Second element should be 2");
    assert_eq(seq[4].as_number().unwrap(), 5.0, "Fifth element should be 5");
}

// Test 3: Parse flow mappings
fn test_parse_flow_mapping() {
    let yaml_str = "{name: John, age: 30, active: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_mapping(), "Should be a mapping");

    let name = value.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "John", "Name should be John");

    let age = value.get("age").unwrap();
    assert_eq(age.as_number().unwrap(), 30.0, "Age should be 30");

    let active = value.get("active").unwrap();
    assert_eq(active.as_bool().unwrap(), true, "Active should be true");
}

// Test 4: Parse nested structures
fn test_parse_nested() {
    let yaml_str = "{user: {name: Alice, scores: [95, 87, 92]}}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let user = value.get("user").unwrap();
    assert(user.is_mapping(), "User should be a mapping");

    let name = user.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "Alice", "Name should be Alice");

    let scores = user.get("scores").unwrap();
    assert(scores.is_sequence(), "Scores should be a sequence");
    let scores_seq = scores.as_sequence().unwrap();
    assert_eq(scores_seq.len() as i64, 3, "Should have 3 scores");
}

// Test 5: Parse mixed sequences
fn test_parse_mixed_sequence() {
    let yaml_str = "[42, hello, true, null]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    let seq = value.as_sequence().unwrap();

    assert_eq(seq.len() as i64, 4, "Should have 4 elements");
    assert(seq[0].is_number(), "First should be number");
    assert(seq[1].is_string(), "Second should be string");
    assert(seq[2].is_bool(), "Third should be bool");
    assert(seq[3].is_null(), "Fourth should be null");
}

// Test 6: Stringify scalars
fn test_stringify_scalars() {
    let null_val = yaml::yaml_null();
    assert_eq(yaml::stringify(null_val), "null", "Null should stringify to 'null'");

    let bool_val = yaml::yaml_bool(true);
    assert_eq(yaml::stringify(bool_val), "true", "True should stringify to 'true'");

    let num_val = yaml::yaml_number(42.5);
    assert_eq(yaml::stringify(num_val), "42.5", "Number should stringify correctly");

    let str_val = yaml::yaml_string("hello");
    assert_eq(yaml::stringify(str_val), "hello", "String should stringify to itself");
}

// Test 7: Stringify sequences
fn test_stringify_sequence() {
    let mut seq = yaml::yaml_sequence();
    seq.push(yaml::yaml_number(1.0));
    seq.push(yaml::yaml_number(2.0));
    seq.push(yaml::yaml_number(3.0));

    let yaml_str = yaml::stringify(seq);
    assert(yaml_str.contains("- 1"), "Should contain '- 1'");
    assert(yaml_str.contains("- 2"), "Should contain '- 2'");
    assert(yaml_str.contains("- 3"), "Should contain '- 3'");
}

// Test 8: Stringify mappings
fn test_stringify_mapping() {
    let mut map = yaml::yaml_mapping();
    map.set("name", yaml::yaml_string("Alice"));
    map.set("age", yaml::yaml_number(25.0));

    let yaml_str = yaml::stringify(map);
    assert(yaml_str.contains("name:"), "Should contain 'name:'");
    assert(yaml_str.contains("Alice"), "Should contain 'Alice'");
    assert(yaml_str.contains("age:"), "Should contain 'age:'");
    assert(yaml_str.contains("25"), "Should contain '25'");
}

// Test 9: YamlValue manipulation - sequences
fn test_yaml_value_sequence_manipulation() {
    let mut seq = yaml::yaml_sequence();
    assert_eq(seq.len(), 0, "Should start empty");

    seq.push(yaml::yaml_number(10.0));
    seq.push(yaml::yaml_string("test"));
    assert_eq(seq.len(), 2, "Should have 2 elements");

    let first = seq.get_index(0).unwrap();
    assert_eq(first.as_number().unwrap(), 10.0, "First element should be 10");

    let second = seq.get_index(1).unwrap();
    assert_eq(second.as_string().unwrap(), "test", "Second element should be 'test'");
}

// Test 10: YamlValue manipulation - mappings
fn test_yaml_value_mapping_manipulation() {
    let mut map = yaml::yaml_mapping();
    assert_eq(map.len(), 0, "Should start empty");

    map.set("key1", yaml::yaml_string("value1"));
    map.set("key2", yaml::yaml_number(100.0));
    assert_eq(map.len(), 2, "Should have 2 keys");

    let keys = map.keys();
    assert_eq(keys.len() as i64, 2, "Should have 2 keys");

    let val1 = map.get("key1").unwrap();
    assert_eq(val1.as_string().unwrap(), "value1", "Should get correct value");

    let val2 = map.get("key2").unwrap();
    assert_eq(val2.as_number().unwrap(), 100.0, "Should get correct number");
}

// Test 11: Type checking methods
fn test_type_checking() {
    let null_val = yaml::yaml_null();
    assert(null_val.is_null(), "Should be null type");
    assert(!null_val.is_string(), "Should not be string type");

    let bool_val = yaml::yaml_bool(true);
    assert(bool_val.is_bool(), "Should be bool type");
    assert(!bool_val.is_number(), "Should not be number type");

    let num_val = yaml::yaml_number(3.14);
    assert(num_val.is_number(), "Should be number type");
    assert(!num_val.is_sequence(), "Should not be sequence type");

    let str_val = yaml::yaml_string("test");
    assert(str_val.is_string(), "Should be string type");
    assert(!str_val.is_mapping(), "Should not be mapping type");
}

// Test 12: Quoted strings
fn test_quoted_strings() {
    let yaml_str = "\"hello world\"";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert_eq(value.as_string().unwrap(), "hello world", "Should parse quoted string");
}

// Test 13: Empty sequences and mappings
fn test_empty_collections() {
    let empty_seq = yaml::parse("[]");
    assert_ok(&empty_seq);
    let seq = empty_seq.unwrap();
    assert(seq.is_sequence(), "Should be a sequence");
    assert_eq(seq.len(), 0, "Should be empty");

    let empty_map = yaml::parse("{}");
    assert_ok(&empty_map);
    let map = empty_map.unwrap();
    assert(map.is_mapping(), "Should be a mapping");
    assert_eq(map.len(), 0, "Should be empty");
}

// Test 14: Stringify empty collections
fn test_stringify_empty() {
    let empty_seq = yaml::yaml_sequence();
    assert_eq(yaml::stringify(empty_seq), "[]", "Empty sequence should stringify to '[]'");

    let empty_map = yaml::yaml_mapping();
    assert_eq(yaml::stringify(empty_map), "{}", "Empty mapping should stringify to '{}'");
}

// Test 15: Complex nested structure
fn test_complex_nested_structure() {
    let yaml_str = "{database: {host: localhost, port: 5432, credentials: {user: admin, password: secret}}, enabled: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let db = value.get("database").unwrap();
    let host = db.get("host").unwrap();
    assert_eq(host.as_string().unwrap(), "localhost", "Host should be localhost");

    let port = db.get("port").unwrap();
    assert_eq(port.as_number().unwrap(), 5432.0, "Port should be 5432");

    let creds = db.get("credentials").unwrap();
    let user = creds.get("user").unwrap();
    assert_eq(user.as_string().unwrap(), "admin", "User should be admin");

    let enabled = value.get("enabled").unwrap();
    assert_eq(enabled.as_bool().unwrap(), true, "Enabled should be true");
}


// YAML Parser and Serializer Tests

// Test 1: Parse simple scalars
fn test_parse_scalars() {
    // Null
    let null_yaml = yaml::parse("null");
    assert_ok(&null_yaml);
    let null_val = null_yaml.unwrap();
    assert(null_val.is_null(), "Should be null");

    // Boolean
    let true_yaml = yaml::parse("true");
    assert_ok(&true_yaml);
    assert_eq(true_yaml.unwrap().as_bool().unwrap(), true, "Should be true");

    let false_yaml = yaml::parse("false");
    assert_ok(&false_yaml);
    assert_eq(false_yaml.unwrap().as_bool().unwrap(), false, "Should be false");

    // Number
    let num_yaml = yaml::parse("42");
    assert_ok(&num_yaml);
    assert_eq(num_yaml.unwrap().as_number().unwrap(), 42.0, "Should be 42");

    // String
    let str_yaml = yaml::parse("hello");
    assert_ok(&str_yaml);
    assert_eq(str_yaml.unwrap().as_string().unwrap(), "hello", "Should be 'hello'");
}

// Test 2: Parse flow sequences
fn test_parse_flow_sequence() {
    let yaml_str = "[1, 2, 3, 4, 5]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_sequence(), "Should be a sequence");

    let seq = value.as_sequence().unwrap();
    assert_eq(seq.len() as i64, 5, "Should have 5 elements");

    assert_eq(seq[0].as_number().unwrap(), 1.0, "First element should be 1");
    assert_eq(seq[1].as_number().unwrap(), 2.0, "Second element should be 2");
    assert_eq(seq[4].as_number().unwrap(), 5.0, "Fifth element should be 5");
}

// Test 3: Parse flow mappings
fn test_parse_flow_mapping() {
    let yaml_str = "{name: John, age: 30, active: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_mapping(), "Should be a mapping");

    let name = value.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "John", "Name should be John");

    let age = value.get("age").unwrap();
    assert_eq(age.as_number().unwrap(), 30.0, "Age should be 30");

    let active = value.get("active").unwrap();
    assert_eq(active.as_bool().unwrap(), true, "Active should be true");
}

// Test 4: Parse nested structures
fn test_parse_nested() {
    let yaml_str = "{user: {name: Alice, scores: [95, 87, 92]}}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let user = value.get("user").unwrap();
    assert(user.is_mapping(), "User should be a mapping");

    let name = user.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "Alice", "Name should be Alice");

    let scores = user.get("scores").unwrap();
    assert(scores.is_sequence(), "Scores should be a sequence");
    let scores_seq = scores.as_sequence().unwrap();
    assert_eq(scores_seq.len() as i64, 3, "Should have 3 scores");
}

// Test 5: Parse mixed sequences
fn test_parse_mixed_sequence() {
    let yaml_str = "[42, hello, true, null]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    let seq = value.as_sequence().unwrap();

    assert_eq(seq.len() as i64, 4, "Should have 4 elements");
    assert(seq[0].is_number(), "First should be number");
    assert(seq[1].is_string(), "Second should be string");
    assert(seq[2].is_bool(), "Third should be bool");
    assert(seq[3].is_null(), "Fourth should be null");
}

// Test 6: Stringify scalars
fn test_stringify_scalars() {
    let null_val = yaml::yaml_null();
    assert_eq(yaml::stringify(null_val), "null", "Null should stringify to 'null'");

    let bool_val = yaml::yaml_bool(true);
    assert_eq(yaml::stringify(bool_val), "true", "True should stringify to 'true'");

    let num_val = yaml::yaml_number(42.5);
    assert_eq(yaml::stringify(num_val), "42.5", "Number should stringify correctly");

    let str_val = yaml::yaml_string("hello");
    assert_eq(yaml::stringify(str_val), "hello", "String should stringify to itself");
}

// Test 7: Stringify sequences
fn test_stringify_sequence() {
    let mut seq = yaml::yaml_sequence();
    seq.push(yaml::yaml_number(1.0));
    seq.push(yaml::yaml_number(2.0));
    seq.push(yaml::yaml_number(3.0));

    let yaml_str = yaml::stringify(seq);
    assert(yaml_str.contains("- 1"), "Should contain '- 1'");
    assert(yaml_str.contains("- 2"), "Should contain '- 2'");
    assert(yaml_str.contains("- 3"), "Should contain '- 3'");
}

// Test 8: Stringify mappings
fn test_stringify_mapping() {
    let mut map = yaml::yaml_mapping();
    map.set("name", yaml::yaml_string("Alice"));
    map.set("age", yaml::yaml_number(25.0));

    let yaml_str = yaml::stringify(map);
    assert(yaml_str.contains("name:"), "Should contain 'name:'");
    assert(yaml_str.contains("Alice"), "Should contain 'Alice'");
    assert(yaml_str.contains("age:"), "Should contain 'age:'");
    assert(yaml_str.contains("25"), "Should contain '25'");
}

// Test 9: YamlValue manipulation - sequences
fn test_yaml_value_sequence_manipulation() {
    let mut seq = yaml::yaml_sequence();
    assert_eq(seq.len(), 0, "Should start empty");

    seq.push(yaml::yaml_number(10.0));
    seq.push(yaml::yaml_string("test"));
    assert_eq(seq.len(), 2, "Should have 2 elements");

    let first = seq.get_index(0).unwrap();
    assert_eq(first.as_number().unwrap(), 10.0, "First element should be 10");

    let second = seq.get_index(1).unwrap();
    assert_eq(second.as_string().unwrap(), "test", "Second element should be 'test'");
}

// Test 10: YamlValue manipulation - mappings
fn test_yaml_value_mapping_manipulation() {
    let mut map = yaml::yaml_mapping();
    assert_eq(map.len(), 0, "Should start empty");

    map.set("key1", yaml::yaml_string("value1"));
    map.set("key2", yaml::yaml_number(100.0));
    assert_eq(map.len(), 2, "Should have 2 keys");

    let keys = map.keys();
    assert_eq(keys.len() as i64, 2, "Should have 2 keys");

    let val1 = map.get("key1").unwrap();
    assert_eq(val1.as_string().unwrap(), "value1", "Should get correct value");

    let val2 = map.get("key2").unwrap();
    assert_eq(val2.as_number().unwrap(), 100.0, "Should get correct number");
}

// Test 11: Type checking methods
fn test_type_checking() {
    let null_val = yaml::yaml_null();
    assert(null_val.is_null(), "Should be null type");
    assert(!null_val.is_string(), "Should not be string type");

    let bool_val = yaml::yaml_bool(true);
    assert(bool_val.is_bool(), "Should be bool type");
    assert(!bool_val.is_number(), "Should not be number type");

    let num_val = yaml::yaml_number(3.14);
    assert(num_val.is_number(), "Should be number type");
    assert(!num_val.is_sequence(), "Should not be sequence type");

    let str_val = yaml::yaml_string("test");
    assert(str_val.is_string(), "Should be string type");
    assert(!str_val.is_mapping(), "Should not be mapping type");
}

// Test 12: Quoted strings
fn test_quoted_strings() {
    let yaml_str = "\"hello world\"";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert_eq(value.as_string().unwrap(), "hello world", "Should parse quoted string");
}

// Test 13: Empty sequences and mappings
fn test_empty_collections() {
    let empty_seq = yaml::parse("[]");
    assert_ok(&empty_seq);
    let seq = empty_seq.unwrap();
    assert(seq.is_sequence(), "Should be a sequence");
    assert_eq(seq.len(), 0, "Should be empty");

    let empty_map = yaml::parse("{}");
    assert_ok(&empty_map);
    let map = empty_map.unwrap();
    assert(map.is_mapping(), "Should be a mapping");
    assert_eq(map.len(), 0, "Should be empty");
}

// Test 14: Stringify empty collections
fn test_stringify_empty() {
    let empty_seq = yaml::yaml_sequence();
    assert_eq(yaml::stringify(empty_seq), "[]", "Empty sequence should stringify to '[]'");

    let empty_map = yaml::yaml_mapping();
    assert_eq(yaml::stringify(empty_map), "{}", "Empty mapping should stringify to '{}'");
}

// Test 15: Complex nested structure
fn test_complex_nested_structure() {
    let yaml_str = "{database: {host: localhost, port: 5432, credentials: {user: admin, password: secret}}, enabled: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let db = value.get("database").unwrap();
    let host = db.get("host").unwrap();
    assert_eq(host.as_string().unwrap(), "localhost", "Host should be localhost");

    let port = db.get("port").unwrap();
    assert_eq(port.as_number().unwrap(), 5432.0, "Port should be 5432");

    let creds = db.get("credentials").unwrap();
    let user = creds.get("user").unwrap();
    assert_eq(user.as_string().unwrap(), "admin", "User should be admin");

    let enabled = value.get("enabled").unwrap();
    assert_eq(enabled.as_bool().unwrap(), true, "Enabled should be true");
}


// YAML Parser and Serializer Tests

// Test 1: Parse simple scalars
fn test_parse_scalars() {
    // Null
    let null_yaml = yaml::parse("null");
    assert_ok(&null_yaml);
    let null_val = null_yaml.unwrap();
    assert(null_val.is_null(), "Should be null");

    // Boolean
    let true_yaml = yaml::parse("true");
    assert_ok(&true_yaml);
    assert_eq(true_yaml.unwrap().as_bool().unwrap(), true, "Should be true");

    let false_yaml = yaml::parse("false");
    assert_ok(&false_yaml);
    assert_eq(false_yaml.unwrap().as_bool().unwrap(), false, "Should be false");

    // Number
    let num_yaml = yaml::parse("42");
    assert_ok(&num_yaml);
    assert_eq(num_yaml.unwrap().as_number().unwrap(), 42.0, "Should be 42");

    // String
    let str_yaml = yaml::parse("hello");
    assert_ok(&str_yaml);
    assert_eq(str_yaml.unwrap().as_string().unwrap(), "hello", "Should be 'hello'");
}

// Test 2: Parse flow sequences
fn test_parse_flow_sequence() {
    let yaml_str = "[1, 2, 3, 4, 5]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_sequence(), "Should be a sequence");

    let seq = value.as_sequence().unwrap();
    assert_eq(seq.len() as i64, 5, "Should have 5 elements");

    assert_eq(seq[0].as_number().unwrap(), 1.0, "First element should be 1");
    assert_eq(seq[1].as_number().unwrap(), 2.0, "Second element should be 2");
    assert_eq(seq[4].as_number().unwrap(), 5.0, "Fifth element should be 5");
}

// Test 3: Parse flow mappings
fn test_parse_flow_mapping() {
    let yaml_str = "{name: John, age: 30, active: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_mapping(), "Should be a mapping");

    let name = value.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "John", "Name should be John");

    let age = value.get("age").unwrap();
    assert_eq(age.as_number().unwrap(), 30.0, "Age should be 30");

    let active = value.get("active").unwrap();
    assert_eq(active.as_bool().unwrap(), true, "Active should be true");
}

// Test 4: Parse nested structures
fn test_parse_nested() {
    let yaml_str = "{user: {name: Alice, scores: [95, 87, 92]}}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let user = value.get("user").unwrap();
    assert(user.is_mapping(), "User should be a mapping");

    let name = user.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "Alice", "Name should be Alice");

    let scores = user.get("scores").unwrap();
    assert(scores.is_sequence(), "Scores should be a sequence");
    let scores_seq = scores.as_sequence().unwrap();
    assert_eq(scores_seq.len() as i64, 3, "Should have 3 scores");
}

// Test 5: Parse mixed sequences
fn test_parse_mixed_sequence() {
    let yaml_str = "[42, hello, true, null]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    let seq = value.as_sequence().unwrap();

    assert_eq(seq.len() as i64, 4, "Should have 4 elements");
    assert(seq[0].is_number(), "First should be number");
    assert(seq[1].is_string(), "Second should be string");
    assert(seq[2].is_bool(), "Third should be bool");
    assert(seq[3].is_null(), "Fourth should be null");
}

// Test 6: Stringify scalars
fn test_stringify_scalars() {
    let null_val = yaml::yaml_null();
    assert_eq(yaml::stringify(null_val), "null", "Null should stringify to 'null'");

    let bool_val = yaml::yaml_bool(true);
    assert_eq(yaml::stringify(bool_val), "true", "True should stringify to 'true'");

    let num_val = yaml::yaml_number(42.5);
    assert_eq(yaml::stringify(num_val), "42.5", "Number should stringify correctly");

    let str_val = yaml::yaml_string("hello");
    assert_eq(yaml::stringify(str_val), "hello", "String should stringify to itself");
}

// Test 7: Stringify sequences
fn test_stringify_sequence() {
    let mut seq = yaml::yaml_sequence();
    seq.push(yaml::yaml_number(1.0));
    seq.push(yaml::yaml_number(2.0));
    seq.push(yaml::yaml_number(3.0));

    let yaml_str = yaml::stringify(seq);
    assert(yaml_str.contains("- 1"), "Should contain '- 1'");
    assert(yaml_str.contains("- 2"), "Should contain '- 2'");
    assert(yaml_str.contains("- 3"), "Should contain '- 3'");
}

// Test 8: Stringify mappings
fn test_stringify_mapping() {
    let mut map = yaml::yaml_mapping();
    map.set("name", yaml::yaml_string("Alice"));
    map.set("age", yaml::yaml_number(25.0));

    let yaml_str = yaml::stringify(map);
    assert(yaml_str.contains("name:"), "Should contain 'name:'");
    assert(yaml_str.contains("Alice"), "Should contain 'Alice'");
    assert(yaml_str.contains("age:"), "Should contain 'age:'");
    assert(yaml_str.contains("25"), "Should contain '25'");
}

// Test 9: YamlValue manipulation - sequences
fn test_yaml_value_sequence_manipulation() {
    let mut seq = yaml::yaml_sequence();
    assert_eq(seq.len(), 0, "Should start empty");

    seq.push(yaml::yaml_number(10.0));
    seq.push(yaml::yaml_string("test"));
    assert_eq(seq.len(), 2, "Should have 2 elements");

    let first = seq.get_index(0).unwrap();
    assert_eq(first.as_number().unwrap(), 10.0, "First element should be 10");

    let second = seq.get_index(1).unwrap();
    assert_eq(second.as_string().unwrap(), "test", "Second element should be 'test'");
}

// Test 10: YamlValue manipulation - mappings
fn test_yaml_value_mapping_manipulation() {
    let mut map = yaml::yaml_mapping();
    assert_eq(map.len(), 0, "Should start empty");

    map.set("key1", yaml::yaml_string("value1"));
    map.set("key2", yaml::yaml_number(100.0));
    assert_eq(map.len(), 2, "Should have 2 keys");

    let keys = map.keys();
    assert_eq(keys.len() as i64, 2, "Should have 2 keys");

    let val1 = map.get("key1").unwrap();
    assert_eq(val1.as_string().unwrap(), "value1", "Should get correct value");

    let val2 = map.get("key2").unwrap();
    assert_eq(val2.as_number().unwrap(), 100.0, "Should get correct number");
}

// Test 11: Type checking methods
fn test_type_checking() {
    let null_val = yaml::yaml_null();
    assert(null_val.is_null(), "Should be null type");
    assert(!null_val.is_string(), "Should not be string type");

    let bool_val = yaml::yaml_bool(true);
    assert(bool_val.is_bool(), "Should be bool type");
    assert(!bool_val.is_number(), "Should not be number type");

    let num_val = yaml::yaml_number(3.14);
    assert(num_val.is_number(), "Should be number type");
    assert(!num_val.is_sequence(), "Should not be sequence type");

    let str_val = yaml::yaml_string("test");
    assert(str_val.is_string(), "Should be string type");
    assert(!str_val.is_mapping(), "Should not be mapping type");
}

// Test 12: Quoted strings
fn test_quoted_strings() {
    let yaml_str = "\"hello world\"";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert_eq(value.as_string().unwrap(), "hello world", "Should parse quoted string");
}

// Test 13: Empty sequences and mappings
fn test_empty_collections() {
    let empty_seq = yaml::parse("[]");
    assert_ok(&empty_seq);
    let seq = empty_seq.unwrap();
    assert(seq.is_sequence(), "Should be a sequence");
    assert_eq(seq.len(), 0, "Should be empty");

    let empty_map = yaml::parse("{}");
    assert_ok(&empty_map);
    let map = empty_map.unwrap();
    assert(map.is_mapping(), "Should be a mapping");
    assert_eq(map.len(), 0, "Should be empty");
}

// Test 14: Stringify empty collections
fn test_stringify_empty() {
    let empty_seq = yaml::yaml_sequence();
    assert_eq(yaml::stringify(empty_seq), "[]", "Empty sequence should stringify to '[]'");

    let empty_map = yaml::yaml_mapping();
    assert_eq(yaml::stringify(empty_map), "{}", "Empty mapping should stringify to '{}'");
}

// Test 15: Complex nested structure
fn test_complex_nested_structure() {
    let yaml_str = "{database: {host: localhost, port: 5432, credentials: {user: admin, password: secret}}, enabled: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let db = value.get("database").unwrap();
    let host = db.get("host").unwrap();
    assert_eq(host.as_string().unwrap(), "localhost", "Host should be localhost");

    let port = db.get("port").unwrap();
    assert_eq(port.as_number().unwrap(), 5432.0, "Port should be 5432");

    let creds = db.get("credentials").unwrap();
    let user = creds.get("user").unwrap();
    assert_eq(user.as_string().unwrap(), "admin", "User should be admin");

    let enabled = value.get("enabled").unwrap();
    assert_eq(enabled.as_bool().unwrap(), true, "Enabled should be true");
}


// YAML Parser and Serializer Tests

// Test 1: Parse simple scalars
fn test_parse_scalars() {
    // Null
    let null_yaml = yaml::parse("null");
    assert_ok(&null_yaml);
    let null_val = null_yaml.unwrap();
    assert(null_val.is_null(), "Should be null");

    // Boolean
    let true_yaml = yaml::parse("true");
    assert_ok(&true_yaml);
    assert_eq(true_yaml.unwrap().as_bool().unwrap(), true, "Should be true");

    let false_yaml = yaml::parse("false");
    assert_ok(&false_yaml);
    assert_eq(false_yaml.unwrap().as_bool().unwrap(), false, "Should be false");

    // Number
    let num_yaml = yaml::parse("42");
    assert_ok(&num_yaml);
    assert_eq(num_yaml.unwrap().as_number().unwrap(), 42.0, "Should be 42");

    // String
    let str_yaml = yaml::parse("hello");
    assert_ok(&str_yaml);
    assert_eq(str_yaml.unwrap().as_string().unwrap(), "hello", "Should be 'hello'");
}

// Test 2: Parse flow sequences
fn test_parse_flow_sequence() {
    let yaml_str = "[1, 2, 3, 4, 5]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_sequence(), "Should be a sequence");

    let seq = value.as_sequence().unwrap();
    assert_eq(seq.len() as i64, 5, "Should have 5 elements");

    assert_eq(seq[0].as_number().unwrap(), 1.0, "First element should be 1");
    assert_eq(seq[1].as_number().unwrap(), 2.0, "Second element should be 2");
    assert_eq(seq[4].as_number().unwrap(), 5.0, "Fifth element should be 5");
}

// Test 3: Parse flow mappings
fn test_parse_flow_mapping() {
    let yaml_str = "{name: John, age: 30, active: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_mapping(), "Should be a mapping");

    let name = value.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "John", "Name should be John");

    let age = value.get("age").unwrap();
    assert_eq(age.as_number().unwrap(), 30.0, "Age should be 30");

    let active = value.get("active").unwrap();
    assert_eq(active.as_bool().unwrap(), true, "Active should be true");
}

// Test 4: Parse nested structures
fn test_parse_nested() {
    let yaml_str = "{user: {name: Alice, scores: [95, 87, 92]}}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let user = value.get("user").unwrap();
    assert(user.is_mapping(), "User should be a mapping");

    let name = user.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "Alice", "Name should be Alice");

    let scores = user.get("scores").unwrap();
    assert(scores.is_sequence(), "Scores should be a sequence");
    let scores_seq = scores.as_sequence().unwrap();
    assert_eq(scores_seq.len() as i64, 3, "Should have 3 scores");
}

// Test 5: Parse mixed sequences
fn test_parse_mixed_sequence() {
    let yaml_str = "[42, hello, true, null]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    let seq = value.as_sequence().unwrap();

    assert_eq(seq.len() as i64, 4, "Should have 4 elements");
    assert(seq[0].is_number(), "First should be number");
    assert(seq[1].is_string(), "Second should be string");
    assert(seq[2].is_bool(), "Third should be bool");
    assert(seq[3].is_null(), "Fourth should be null");
}

// Test 6: Stringify scalars
fn test_stringify_scalars() {
    let null_val = yaml::yaml_null();
    assert_eq(yaml::stringify(null_val), "null", "Null should stringify to 'null'");

    let bool_val = yaml::yaml_bool(true);
    assert_eq(yaml::stringify(bool_val), "true", "True should stringify to 'true'");

    let num_val = yaml::yaml_number(42.5);
    assert_eq(yaml::stringify(num_val), "42.5", "Number should stringify correctly");

    let str_val = yaml::yaml_string("hello");
    assert_eq(yaml::stringify(str_val), "hello", "String should stringify to itself");
}

// Test 7: Stringify sequences
fn test_stringify_sequence() {
    let mut seq = yaml::yaml_sequence();
    seq.push(yaml::yaml_number(1.0));
    seq.push(yaml::yaml_number(2.0));
    seq.push(yaml::yaml_number(3.0));

    let yaml_str = yaml::stringify(seq);
    assert(yaml_str.contains("- 1"), "Should contain '- 1'");
    assert(yaml_str.contains("- 2"), "Should contain '- 2'");
    assert(yaml_str.contains("- 3"), "Should contain '- 3'");
}

// Test 8: Stringify mappings
fn test_stringify_mapping() {
    let mut map = yaml::yaml_mapping();
    map.set("name", yaml::yaml_string("Alice"));
    map.set("age", yaml::yaml_number(25.0));

    let yaml_str = yaml::stringify(map);
    assert(yaml_str.contains("name:"), "Should contain 'name:'");
    assert(yaml_str.contains("Alice"), "Should contain 'Alice'");
    assert(yaml_str.contains("age:"), "Should contain 'age:'");
    assert(yaml_str.contains("25"), "Should contain '25'");
}

// Test 9: YamlValue manipulation - sequences
fn test_yaml_value_sequence_manipulation() {
    let mut seq = yaml::yaml_sequence();
    assert_eq(seq.len(), 0, "Should start empty");

    seq.push(yaml::yaml_number(10.0));
    seq.push(yaml::yaml_string("test"));
    assert_eq(seq.len(), 2, "Should have 2 elements");

    let first = seq.get_index(0).unwrap();
    assert_eq(first.as_number().unwrap(), 10.0, "First element should be 10");

    let second = seq.get_index(1).unwrap();
    assert_eq(second.as_string().unwrap(), "test", "Second element should be 'test'");
}

// Test 10: YamlValue manipulation - mappings
fn test_yaml_value_mapping_manipulation() {
    let mut map = yaml::yaml_mapping();
    assert_eq(map.len(), 0, "Should start empty");

    map.set("key1", yaml::yaml_string("value1"));
    map.set("key2", yaml::yaml_number(100.0));
    assert_eq(map.len(), 2, "Should have 2 keys");

    let keys = map.keys();
    assert_eq(keys.len() as i64, 2, "Should have 2 keys");

    let val1 = map.get("key1").unwrap();
    assert_eq(val1.as_string().unwrap(), "value1", "Should get correct value");

    let val2 = map.get("key2").unwrap();
    assert_eq(val2.as_number().unwrap(), 100.0, "Should get correct number");
}

// Test 11: Type checking methods
fn test_type_checking() {
    let null_val = yaml::yaml_null();
    assert(null_val.is_null(), "Should be null type");
    assert(!null_val.is_string(), "Should not be string type");

    let bool_val = yaml::yaml_bool(true);
    assert(bool_val.is_bool(), "Should be bool type");
    assert(!bool_val.is_number(), "Should not be number type");

    let num_val = yaml::yaml_number(3.14);
    assert(num_val.is_number(), "Should be number type");
    assert(!num_val.is_sequence(), "Should not be sequence type");

    let str_val = yaml::yaml_string("test");
    assert(str_val.is_string(), "Should be string type");
    assert(!str_val.is_mapping(), "Should not be mapping type");
}

// Test 12: Quoted strings
fn test_quoted_strings() {
    let yaml_str = "\"hello world\"";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert_eq(value.as_string().unwrap(), "hello world", "Should parse quoted string");
}

// Test 13: Empty sequences and mappings
fn test_empty_collections() {
    let empty_seq = yaml::parse("[]");
    assert_ok(&empty_seq);
    let seq = empty_seq.unwrap();
    assert(seq.is_sequence(), "Should be a sequence");
    assert_eq(seq.len(), 0, "Should be empty");

    let empty_map = yaml::parse("{}");
    assert_ok(&empty_map);
    let map = empty_map.unwrap();
    assert(map.is_mapping(), "Should be a mapping");
    assert_eq(map.len(), 0, "Should be empty");
}

// Test 14: Stringify empty collections
fn test_stringify_empty() {
    let empty_seq = yaml::yaml_sequence();
    assert_eq(yaml::stringify(empty_seq), "[]", "Empty sequence should stringify to '[]'");

    let empty_map = yaml::yaml_mapping();
    assert_eq(yaml::stringify(empty_map), "{}", "Empty mapping should stringify to '{}'");
}

// Test 15: Complex nested structure
fn test_complex_nested_structure() {
    let yaml_str = "{database: {host: localhost, port: 5432, credentials: {user: admin, password: secret}}, enabled: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let db = value.get("database").unwrap();
    let host = db.get("host").unwrap();
    assert_eq(host.as_string().unwrap(), "localhost", "Host should be localhost");

    let port = db.get("port").unwrap();
    assert_eq(port.as_number().unwrap(), 5432.0, "Port should be 5432");

    let creds = db.get("credentials").unwrap();
    let user = creds.get("user").unwrap();
    assert_eq(user.as_string().unwrap(), "admin", "User should be admin");

    let enabled = value.get("enabled").unwrap();
    assert_eq(enabled.as_bool().unwrap(), true, "Enabled should be true");
}


// YAML Parser and Serializer Tests

// Test 1: Parse simple scalars
fn test_parse_scalars() {
    // Null
    let null_yaml = yaml::parse("null");
    assert_ok(&null_yaml);
    let null_val = null_yaml.unwrap();
    assert(null_val.is_null(), "Should be null");

    // Boolean
    let true_yaml = yaml::parse("true");
    assert_ok(&true_yaml);
    assert_eq(true_yaml.unwrap().as_bool().unwrap(), true, "Should be true");

    let false_yaml = yaml::parse("false");
    assert_ok(&false_yaml);
    assert_eq(false_yaml.unwrap().as_bool().unwrap(), false, "Should be false");

    // Number
    let num_yaml = yaml::parse("42");
    assert_ok(&num_yaml);
    assert_eq(num_yaml.unwrap().as_number().unwrap(), 42.0, "Should be 42");

    // String
    let str_yaml = yaml::parse("hello");
    assert_ok(&str_yaml);
    assert_eq(str_yaml.unwrap().as_string().unwrap(), "hello", "Should be 'hello'");
}

// Test 2: Parse flow sequences
fn test_parse_flow_sequence() {
    let yaml_str = "[1, 2, 3, 4, 5]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_sequence(), "Should be a sequence");

    let seq = value.as_sequence().unwrap();
    assert_eq(seq.len() as i64, 5, "Should have 5 elements");

    assert_eq(seq[0].as_number().unwrap(), 1.0, "First element should be 1");
    assert_eq(seq[1].as_number().unwrap(), 2.0, "Second element should be 2");
    assert_eq(seq[4].as_number().unwrap(), 5.0, "Fifth element should be 5");
}

// Test 3: Parse flow mappings
fn test_parse_flow_mapping() {
    let yaml_str = "{name: John, age: 30, active: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert(value.is_mapping(), "Should be a mapping");

    let name = value.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "John", "Name should be John");

    let age = value.get("age").unwrap();
    assert_eq(age.as_number().unwrap(), 30.0, "Age should be 30");

    let active = value.get("active").unwrap();
    assert_eq(active.as_bool().unwrap(), true, "Active should be true");
}

// Test 4: Parse nested structures
fn test_parse_nested() {
    let yaml_str = "{user: {name: Alice, scores: [95, 87, 92]}}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let user = value.get("user").unwrap();
    assert(user.is_mapping(), "User should be a mapping");

    let name = user.get("name").unwrap();
    assert_eq(name.as_string().unwrap(), "Alice", "Name should be Alice");

    let scores = user.get("scores").unwrap();
    assert(scores.is_sequence(), "Scores should be a sequence");
    let scores_seq = scores.as_sequence().unwrap();
    assert_eq(scores_seq.len() as i64, 3, "Should have 3 scores");
}

// Test 5: Parse mixed sequences
fn test_parse_mixed_sequence() {
    let yaml_str = "[42, hello, true, null]";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    let seq = value.as_sequence().unwrap();

    assert_eq(seq.len() as i64, 4, "Should have 4 elements");
    assert(seq[0].is_number(), "First should be number");
    assert(seq[1].is_string(), "Second should be string");
    assert(seq[2].is_bool(), "Third should be bool");
    assert(seq[3].is_null(), "Fourth should be null");
}

// Test 6: Stringify scalars
fn test_stringify_scalars() {
    let null_val = yaml::yaml_null();
    assert_eq(yaml::stringify(null_val), "null", "Null should stringify to 'null'");

    let bool_val = yaml::yaml_bool(true);
    assert_eq(yaml::stringify(bool_val), "true", "True should stringify to 'true'");

    let num_val = yaml::yaml_number(42.5);
    assert_eq(yaml::stringify(num_val), "42.5", "Number should stringify correctly");

    let str_val = yaml::yaml_string("hello");
    assert_eq(yaml::stringify(str_val), "hello", "String should stringify to itself");
}

// Test 7: Stringify sequences
fn test_stringify_sequence() {
    let mut seq = yaml::yaml_sequence();
    seq.push(yaml::yaml_number(1.0));
    seq.push(yaml::yaml_number(2.0));
    seq.push(yaml::yaml_number(3.0));

    let yaml_str = yaml::stringify(seq);
    assert(yaml_str.contains("- 1"), "Should contain '- 1'");
    assert(yaml_str.contains("- 2"), "Should contain '- 2'");
    assert(yaml_str.contains("- 3"), "Should contain '- 3'");
}

// Test 8: Stringify mappings
fn test_stringify_mapping() {
    let mut map = yaml::yaml_mapping();
    map.set("name", yaml::yaml_string("Alice"));
    map.set("age", yaml::yaml_number(25.0));

    let yaml_str = yaml::stringify(map);
    assert(yaml_str.contains("name:"), "Should contain 'name:'");
    assert(yaml_str.contains("Alice"), "Should contain 'Alice'");
    assert(yaml_str.contains("age:"), "Should contain 'age:'");
    assert(yaml_str.contains("25"), "Should contain '25'");
}

// Test 9: YamlValue manipulation - sequences
fn test_yaml_value_sequence_manipulation() {
    let mut seq = yaml::yaml_sequence();
    assert_eq(seq.len(), 0, "Should start empty");

    seq.push(yaml::yaml_number(10.0));
    seq.push(yaml::yaml_string("test"));
    assert_eq(seq.len(), 2, "Should have 2 elements");

    let first = seq.get_index(0).unwrap();
    assert_eq(first.as_number().unwrap(), 10.0, "First element should be 10");

    let second = seq.get_index(1).unwrap();
    assert_eq(second.as_string().unwrap(), "test", "Second element should be 'test'");
}

// Test 10: YamlValue manipulation - mappings
fn test_yaml_value_mapping_manipulation() {
    let mut map = yaml::yaml_mapping();
    assert_eq(map.len(), 0, "Should start empty");

    map.set("key1", yaml::yaml_string("value1"));
    map.set("key2", yaml::yaml_number(100.0));
    assert_eq(map.len(), 2, "Should have 2 keys");

    let keys = map.keys();
    assert_eq(keys.len() as i64, 2, "Should have 2 keys");

    let val1 = map.get("key1").unwrap();
    assert_eq(val1.as_string().unwrap(), "value1", "Should get correct value");

    let val2 = map.get("key2").unwrap();
    assert_eq(val2.as_number().unwrap(), 100.0, "Should get correct number");
}

// Test 11: Type checking methods
fn test_type_checking() {
    let null_val = yaml::yaml_null();
    assert(null_val.is_null(), "Should be null type");
    assert(!null_val.is_string(), "Should not be string type");

    let bool_val = yaml::yaml_bool(true);
    assert(bool_val.is_bool(), "Should be bool type");
    assert(!bool_val.is_number(), "Should not be number type");

    let num_val = yaml::yaml_number(3.14);
    assert(num_val.is_number(), "Should be number type");
    assert(!num_val.is_sequence(), "Should not be sequence type");

    let str_val = yaml::yaml_string("test");
    assert(str_val.is_string(), "Should be string type");
    assert(!str_val.is_mapping(), "Should not be mapping type");
}

// Test 12: Quoted strings
fn test_quoted_strings() {
    let yaml_str = "\"hello world\"";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();
    assert_eq(value.as_string().unwrap(), "hello world", "Should parse quoted string");
}

// Test 13: Empty sequences and mappings
fn test_empty_collections() {
    let empty_seq = yaml::parse("[]");
    assert_ok(&empty_seq);
    let seq = empty_seq.unwrap();
    assert(seq.is_sequence(), "Should be a sequence");
    assert_eq(seq.len(), 0, "Should be empty");

    let empty_map = yaml::parse("{}");
    assert_ok(&empty_map);
    let map = empty_map.unwrap();
    assert(map.is_mapping(), "Should be a mapping");
    assert_eq(map.len(), 0, "Should be empty");
}

// Test 14: Stringify empty collections
fn test_stringify_empty() {
    let empty_seq = yaml::yaml_sequence();
    assert_eq(yaml::stringify(empty_seq), "[]", "Empty sequence should stringify to '[]'");

    let empty_map = yaml::yaml_mapping();
    assert_eq(yaml::stringify(empty_map), "{}", "Empty mapping should stringify to '{}'");
}

// Test 15: Complex nested structure
fn test_complex_nested_structure() {
    let yaml_str = "{database: {host: localhost, port: 5432, credentials: {user: admin, password: secret}}, enabled: true}";
    let result = yaml::parse(yaml_str);

    assert_ok(&result);
    let value = result.unwrap();

    let db = value.get("database").unwrap();
    let host = db.get("host").unwrap();
    assert_eq(host.as_string().unwrap(), "localhost", "Host should be localhost");

    let port = db.get("port").unwrap();
    assert_eq(port.as_number().unwrap(), 5432.0, "Port should be 5432");

    let creds = db.get("credentials").unwrap();
    let user = creds.get("user").unwrap();
    assert_eq(user.as_string().unwrap(), "admin", "User should be admin");

    let enabled = value.get("enabled").unwrap();
    assert_eq(enabled.as_bool().unwrap(), true, "Enabled should be true");
}


// File System Tests for Jounce
// Tests basic file and directory operations

// Test writing and reading a text file
fn test_write_and_read() {
    let test_file = "test_temp.txt";
    let content = "Hello, Jounce File I/O!";

    // Write file
    let write_result = fs::write(test_file, content);
    assert_true(write_result.is_ok(), "Should write file successfully");

    // Read file
    let read_result = fs::read_to_string(test_file);
    assert_true(read_result.is_ok(), "Should read file successfully");

    let read_content = read_result.unwrap();
    assert_eq(read_content, content, "Content should match");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test file exists check
fn test_file_exists() {
    let test_file = "test_exists.txt";

    // File should not exist initially
    assert_false(fs::exists(test_file), "File should not exist initially");

    // Create file
    let _ = fs::write(test_file, "test");

    // File should exist now
    assert_true(fs::exists(test_file), "File should exist after creation");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test file metadata
fn test_metadata() {
    let test_file = "test_metadata.txt";
    let content = "Hello World";

    // Create file
    let _ = fs::write(test_file, content);

    // Get metadata
    let meta_result = fs::metadata(test_file);
    assert_true(meta_result.is_ok(), "Should get metadata");

    let meta = meta_result.unwrap();
    assert_true(meta.is_file(), "Should be a file");
    assert_false(meta.is_directory(), "Should not be a directory");
    assert_true(meta.len() > 0, "File size should be greater than 0");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test appending to file
fn test_append() {
    let test_file = "test_append.txt";

    // Write initial content
    let _ = fs::write(test_file, "Line 1\n");

    // Append more content
    let append_result = fs::append(test_file, "Line 2\n");
    assert_true(append_result.is_ok(), "Should append successfully");

    // Read and verify
    let content = fs::read_to_string(test_file).unwrap();
    assert_true(content.contains("Line 1"), "Should contain Line 1");
    assert_true(content.contains("Line 2"), "Should contain Line 2");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test directory creation
fn test_create_directory() {
    let test_dir = "test_temp_dir";

    // Create directory
    let create_result = fs::create_dir(test_dir);
    assert_true(create_result.is_ok(), "Should create directory");

    // Check it exists
    assert_true(fs::exists(test_dir), "Directory should exist");

    // Get metadata
    let meta = fs::metadata(test_dir).unwrap();
    assert_true(meta.is_directory(), "Should be a directory");
    assert_false(meta.is_file(), "Should not be a file");

    // Clean up
    let _ = fs::remove_dir(test_dir);
}

// Test reading directory contents
fn test_read_directory() {
    let test_dir = "test_read_dir";
    let test_file1 = "test_read_dir/file1.txt";
    let test_file2 = "test_read_dir/file2.txt";

    // Create directory
    let _ = fs::create_dir(test_dir);

    // Create files in directory
    let _ = fs::write(test_file1, "File 1");
    let _ = fs::write(test_file2, "File 2");

    // Read directory
    let entries_result = fs::read_dir(test_dir);
    assert_true(entries_result.is_ok(), "Should read directory");

    let entries = entries_result.unwrap();
    assert_eq(entries.len(), 2, "Should have 2 entries");

    // Check entry names
    let entry1 = entries[0];
    let entry2 = entries[1];
    assert_true(entry1.is_file(), "Entry should be a file");
    assert_true(entry2.is_file(), "Entry should be a file");

    // Clean up
    let _ = fs::remove_file(test_file1);
    let _ = fs::remove_file(test_file2);
    let _ = fs::remove_dir(test_dir);
}

// Test file removal
fn test_remove_file() {
    let test_file = "test_remove.txt";

    // Create file
    let _ = fs::write(test_file, "Remove me");
    assert_true(fs::exists(test_file), "File should exist");

    // Remove file
    let remove_result = fs::remove_file(test_file);
    assert_true(remove_result.is_ok(), "Should remove file");

    // Verify removed
    assert_false(fs::exists(test_file), "File should not exist");
}

// Test copying files
fn test_copy_file() {
    let source = "test_source.txt";
    let dest = "test_dest.txt";
    let content = "Copy me!";

    // Create source file
    let _ = fs::write(source, content);

    // Copy file
    let copy_result = fs::copy(source, dest);
    assert_true(copy_result.is_ok(), "Should copy file");

    // Verify both files exist
    assert_true(fs::exists(source), "Source should exist");
    assert_true(fs::exists(dest), "Destination should exist");

    // Verify content matches
    let dest_content = fs::read_to_string(dest).unwrap();
    assert_eq(dest_content, content, "Content should match");

    // Clean up
    let _ = fs::remove_file(source);
    let _ = fs::remove_file(dest);
}

// Test renaming files
fn test_rename_file() {
    let old_name = "test_old.txt";
    let new_name = "test_new.txt";
    let content = "Rename me!";

    // Create file
    let _ = fs::write(old_name, content);

    // Rename file
    let rename_result = fs::rename(old_name, new_name);
    assert_true(rename_result.is_ok(), "Should rename file");

    // Verify old name doesn't exist
    assert_false(fs::exists(old_name), "Old file should not exist");

    // Verify new name exists
    assert_true(fs::exists(new_name), "New file should exist");

    // Verify content preserved
    let new_content = fs::read_to_string(new_name).unwrap();
    assert_eq(new_content, content, "Content should be preserved");

    // Clean up
    let _ = fs::remove_file(new_name);
}

// Test creating nested directories
fn test_create_dir_all() {
    let nested_dir = "test_parent/test_child";

    // Create nested directories
    let create_result = fs::create_dir_all(nested_dir);
    assert_true(create_result.is_ok(), "Should create nested directories");

    // Verify both exist
    assert_true(fs::exists("test_parent"), "Parent directory should exist");
    assert_true(fs::exists(nested_dir), "Child directory should exist");

    // Clean up
    let _ = fs::remove_dir_all("test_parent");
}


// File System Tests for Jounce
// Tests basic file and directory operations

// Test writing and reading a text file
fn test_write_and_read() {
    let test_file = "test_temp.txt";
    let content = "Hello, Jounce File I/O!";

    // Write file
    let write_result = fs::write(test_file, content);
    assert_true(write_result.is_ok(), "Should write file successfully");

    // Read file
    let read_result = fs::read_to_string(test_file);
    assert_true(read_result.is_ok(), "Should read file successfully");

    let read_content = read_result.unwrap();
    assert_eq(read_content, content, "Content should match");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test file exists check
fn test_file_exists() {
    let test_file = "test_exists.txt";

    // File should not exist initially
    assert_false(fs::exists(test_file), "File should not exist initially");

    // Create file
    let _ = fs::write(test_file, "test");

    // File should exist now
    assert_true(fs::exists(test_file), "File should exist after creation");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test file metadata
fn test_metadata() {
    let test_file = "test_metadata.txt";
    let content = "Hello World";

    // Create file
    let _ = fs::write(test_file, content);

    // Get metadata
    let meta_result = fs::metadata(test_file);
    assert_true(meta_result.is_ok(), "Should get metadata");

    let meta = meta_result.unwrap();
    assert_true(meta.is_file(), "Should be a file");
    assert_false(meta.is_directory(), "Should not be a directory");
    assert_true(meta.len() > 0, "File size should be greater than 0");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test appending to file
fn test_append() {
    let test_file = "test_append.txt";

    // Write initial content
    let _ = fs::write(test_file, "Line 1\n");

    // Append more content
    let append_result = fs::append(test_file, "Line 2\n");
    assert_true(append_result.is_ok(), "Should append successfully");

    // Read and verify
    let content = fs::read_to_string(test_file).unwrap();
    assert_true(content.contains("Line 1"), "Should contain Line 1");
    assert_true(content.contains("Line 2"), "Should contain Line 2");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test directory creation
fn test_create_directory() {
    let test_dir = "test_temp_dir";

    // Create directory
    let create_result = fs::create_dir(test_dir);
    assert_true(create_result.is_ok(), "Should create directory");

    // Check it exists
    assert_true(fs::exists(test_dir), "Directory should exist");

    // Get metadata
    let meta = fs::metadata(test_dir).unwrap();
    assert_true(meta.is_directory(), "Should be a directory");
    assert_false(meta.is_file(), "Should not be a file");

    // Clean up
    let _ = fs::remove_dir(test_dir);
}

// Test reading directory contents
fn test_read_directory() {
    let test_dir = "test_read_dir";
    let test_file1 = "test_read_dir/file1.txt";
    let test_file2 = "test_read_dir/file2.txt";

    // Create directory
    let _ = fs::create_dir(test_dir);

    // Create files in directory
    let _ = fs::write(test_file1, "File 1");
    let _ = fs::write(test_file2, "File 2");

    // Read directory
    let entries_result = fs::read_dir(test_dir);
    assert_true(entries_result.is_ok(), "Should read directory");

    let entries = entries_result.unwrap();
    assert_eq(entries.len(), 2, "Should have 2 entries");

    // Check entry names
    let entry1 = entries[0];
    let entry2 = entries[1];
    assert_true(entry1.is_file(), "Entry should be a file");
    assert_true(entry2.is_file(), "Entry should be a file");

    // Clean up
    let _ = fs::remove_file(test_file1);
    let _ = fs::remove_file(test_file2);
    let _ = fs::remove_dir(test_dir);
}

// Test file removal
fn test_remove_file() {
    let test_file = "test_remove.txt";

    // Create file
    let _ = fs::write(test_file, "Remove me");
    assert_true(fs::exists(test_file), "File should exist");

    // Remove file
    let remove_result = fs::remove_file(test_file);
    assert_true(remove_result.is_ok(), "Should remove file");

    // Verify removed
    assert_false(fs::exists(test_file), "File should not exist");
}

// Test copying files
fn test_copy_file() {
    let source = "test_source.txt";
    let dest = "test_dest.txt";
    let content = "Copy me!";

    // Create source file
    let _ = fs::write(source, content);

    // Copy file
    let copy_result = fs::copy(source, dest);
    assert_true(copy_result.is_ok(), "Should copy file");

    // Verify both files exist
    assert_true(fs::exists(source), "Source should exist");
    assert_true(fs::exists(dest), "Destination should exist");

    // Verify content matches
    let dest_content = fs::read_to_string(dest).unwrap();
    assert_eq(dest_content, content, "Content should match");

    // Clean up
    let _ = fs::remove_file(source);
    let _ = fs::remove_file(dest);
}

// Test renaming files
fn test_rename_file() {
    let old_name = "test_old.txt";
    let new_name = "test_new.txt";
    let content = "Rename me!";

    // Create file
    let _ = fs::write(old_name, content);

    // Rename file
    let rename_result = fs::rename(old_name, new_name);
    assert_true(rename_result.is_ok(), "Should rename file");

    // Verify old name doesn't exist
    assert_false(fs::exists(old_name), "Old file should not exist");

    // Verify new name exists
    assert_true(fs::exists(new_name), "New file should exist");

    // Verify content preserved
    let new_content = fs::read_to_string(new_name).unwrap();
    assert_eq(new_content, content, "Content should be preserved");

    // Clean up
    let _ = fs::remove_file(new_name);
}

// Test creating nested directories
fn test_create_dir_all() {
    let nested_dir = "test_parent/test_child";

    // Create nested directories
    let create_result = fs::create_dir_all(nested_dir);
    assert_true(create_result.is_ok(), "Should create nested directories");

    // Verify both exist
    assert_true(fs::exists("test_parent"), "Parent directory should exist");
    assert_true(fs::exists(nested_dir), "Child directory should exist");

    // Clean up
    let _ = fs::remove_dir_all("test_parent");
}


// File System Tests for Jounce
// Tests basic file and directory operations

// Test writing and reading a text file
fn test_write_and_read() {
    let test_file = "test_temp.txt";
    let content = "Hello, Jounce File I/O!";

    // Write file
    let write_result = fs::write(test_file, content);
    assert_true(write_result.is_ok(), "Should write file successfully");

    // Read file
    let read_result = fs::read_to_string(test_file);
    assert_true(read_result.is_ok(), "Should read file successfully");

    let read_content = read_result.unwrap();
    assert_eq(read_content, content, "Content should match");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test file exists check
fn test_file_exists() {
    let test_file = "test_exists.txt";

    // File should not exist initially
    assert_false(fs::exists(test_file), "File should not exist initially");

    // Create file
    let _ = fs::write(test_file, "test");

    // File should exist now
    assert_true(fs::exists(test_file), "File should exist after creation");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test file metadata
fn test_metadata() {
    let test_file = "test_metadata.txt";
    let content = "Hello World";

    // Create file
    let _ = fs::write(test_file, content);

    // Get metadata
    let meta_result = fs::metadata(test_file);
    assert_true(meta_result.is_ok(), "Should get metadata");

    let meta = meta_result.unwrap();
    assert_true(meta.is_file(), "Should be a file");
    assert_false(meta.is_directory(), "Should not be a directory");
    assert_true(meta.len() > 0, "File size should be greater than 0");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test appending to file
fn test_append() {
    let test_file = "test_append.txt";

    // Write initial content
    let _ = fs::write(test_file, "Line 1\n");

    // Append more content
    let append_result = fs::append(test_file, "Line 2\n");
    assert_true(append_result.is_ok(), "Should append successfully");

    // Read and verify
    let content = fs::read_to_string(test_file).unwrap();
    assert_true(content.contains("Line 1"), "Should contain Line 1");
    assert_true(content.contains("Line 2"), "Should contain Line 2");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test directory creation
fn test_create_directory() {
    let test_dir = "test_temp_dir";

    // Create directory
    let create_result = fs::create_dir(test_dir);
    assert_true(create_result.is_ok(), "Should create directory");

    // Check it exists
    assert_true(fs::exists(test_dir), "Directory should exist");

    // Get metadata
    let meta = fs::metadata(test_dir).unwrap();
    assert_true(meta.is_directory(), "Should be a directory");
    assert_false(meta.is_file(), "Should not be a file");

    // Clean up
    let _ = fs::remove_dir(test_dir);
}

// Test reading directory contents
fn test_read_directory() {
    let test_dir = "test_read_dir";
    let test_file1 = "test_read_dir/file1.txt";
    let test_file2 = "test_read_dir/file2.txt";

    // Create directory
    let _ = fs::create_dir(test_dir);

    // Create files in directory
    let _ = fs::write(test_file1, "File 1");
    let _ = fs::write(test_file2, "File 2");

    // Read directory
    let entries_result = fs::read_dir(test_dir);
    assert_true(entries_result.is_ok(), "Should read directory");

    let entries = entries_result.unwrap();
    assert_eq(entries.len(), 2, "Should have 2 entries");

    // Check entry names
    let entry1 = entries[0];
    let entry2 = entries[1];
    assert_true(entry1.is_file(), "Entry should be a file");
    assert_true(entry2.is_file(), "Entry should be a file");

    // Clean up
    let _ = fs::remove_file(test_file1);
    let _ = fs::remove_file(test_file2);
    let _ = fs::remove_dir(test_dir);
}

// Test file removal
fn test_remove_file() {
    let test_file = "test_remove.txt";

    // Create file
    let _ = fs::write(test_file, "Remove me");
    assert_true(fs::exists(test_file), "File should exist");

    // Remove file
    let remove_result = fs::remove_file(test_file);
    assert_true(remove_result.is_ok(), "Should remove file");

    // Verify removed
    assert_false(fs::exists(test_file), "File should not exist");
}

// Test copying files
fn test_copy_file() {
    let source = "test_source.txt";
    let dest = "test_dest.txt";
    let content = "Copy me!";

    // Create source file
    let _ = fs::write(source, content);

    // Copy file
    let copy_result = fs::copy(source, dest);
    assert_true(copy_result.is_ok(), "Should copy file");

    // Verify both files exist
    assert_true(fs::exists(source), "Source should exist");
    assert_true(fs::exists(dest), "Destination should exist");

    // Verify content matches
    let dest_content = fs::read_to_string(dest).unwrap();
    assert_eq(dest_content, content, "Content should match");

    // Clean up
    let _ = fs::remove_file(source);
    let _ = fs::remove_file(dest);
}

// Test renaming files
fn test_rename_file() {
    let old_name = "test_old.txt";
    let new_name = "test_new.txt";
    let content = "Rename me!";

    // Create file
    let _ = fs::write(old_name, content);

    // Rename file
    let rename_result = fs::rename(old_name, new_name);
    assert_true(rename_result.is_ok(), "Should rename file");

    // Verify old name doesn't exist
    assert_false(fs::exists(old_name), "Old file should not exist");

    // Verify new name exists
    assert_true(fs::exists(new_name), "New file should exist");

    // Verify content preserved
    let new_content = fs::read_to_string(new_name).unwrap();
    assert_eq(new_content, content, "Content should be preserved");

    // Clean up
    let _ = fs::remove_file(new_name);
}

// Test creating nested directories
fn test_create_dir_all() {
    let nested_dir = "test_parent/test_child";

    // Create nested directories
    let create_result = fs::create_dir_all(nested_dir);
    assert_true(create_result.is_ok(), "Should create nested directories");

    // Verify both exist
    assert_true(fs::exists("test_parent"), "Parent directory should exist");
    assert_true(fs::exists(nested_dir), "Child directory should exist");

    // Clean up
    let _ = fs::remove_dir_all("test_parent");
}


// File System Tests for Jounce
// Tests basic file and directory operations

// Test writing and reading a text file
fn test_write_and_read() {
    let test_file = "test_temp.txt";
    let content = "Hello, Jounce File I/O!";

    // Write file
    let write_result = fs::write(test_file, content);
    assert_true(write_result.is_ok(), "Should write file successfully");

    // Read file
    let read_result = fs::read_to_string(test_file);
    assert_true(read_result.is_ok(), "Should read file successfully");

    let read_content = read_result.unwrap();
    assert_eq(read_content, content, "Content should match");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test file exists check
fn test_file_exists() {
    let test_file = "test_exists.txt";

    // File should not exist initially
    assert_false(fs::exists(test_file), "File should not exist initially");

    // Create file
    let _ = fs::write(test_file, "test");

    // File should exist now
    assert_true(fs::exists(test_file), "File should exist after creation");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test file metadata
fn test_metadata() {
    let test_file = "test_metadata.txt";
    let content = "Hello World";

    // Create file
    let _ = fs::write(test_file, content);

    // Get metadata
    let meta_result = fs::metadata(test_file);
    assert_true(meta_result.is_ok(), "Should get metadata");

    let meta = meta_result.unwrap();
    assert_true(meta.is_file(), "Should be a file");
    assert_false(meta.is_directory(), "Should not be a directory");
    assert_true(meta.len() > 0, "File size should be greater than 0");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test appending to file
fn test_append() {
    let test_file = "test_append.txt";

    // Write initial content
    let _ = fs::write(test_file, "Line 1\n");

    // Append more content
    let append_result = fs::append(test_file, "Line 2\n");
    assert_true(append_result.is_ok(), "Should append successfully");

    // Read and verify
    let content = fs::read_to_string(test_file).unwrap();
    assert_true(content.contains("Line 1"), "Should contain Line 1");
    assert_true(content.contains("Line 2"), "Should contain Line 2");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test directory creation
fn test_create_directory() {
    let test_dir = "test_temp_dir";

    // Create directory
    let create_result = fs::create_dir(test_dir);
    assert_true(create_result.is_ok(), "Should create directory");

    // Check it exists
    assert_true(fs::exists(test_dir), "Directory should exist");

    // Get metadata
    let meta = fs::metadata(test_dir).unwrap();
    assert_true(meta.is_directory(), "Should be a directory");
    assert_false(meta.is_file(), "Should not be a file");

    // Clean up
    let _ = fs::remove_dir(test_dir);
}

// Test reading directory contents
fn test_read_directory() {
    let test_dir = "test_read_dir";
    let test_file1 = "test_read_dir/file1.txt";
    let test_file2 = "test_read_dir/file2.txt";

    // Create directory
    let _ = fs::create_dir(test_dir);

    // Create files in directory
    let _ = fs::write(test_file1, "File 1");
    let _ = fs::write(test_file2, "File 2");

    // Read directory
    let entries_result = fs::read_dir(test_dir);
    assert_true(entries_result.is_ok(), "Should read directory");

    let entries = entries_result.unwrap();
    assert_eq(entries.len(), 2, "Should have 2 entries");

    // Check entry names
    let entry1 = entries[0];
    let entry2 = entries[1];
    assert_true(entry1.is_file(), "Entry should be a file");
    assert_true(entry2.is_file(), "Entry should be a file");

    // Clean up
    let _ = fs::remove_file(test_file1);
    let _ = fs::remove_file(test_file2);
    let _ = fs::remove_dir(test_dir);
}

// Test file removal
fn test_remove_file() {
    let test_file = "test_remove.txt";

    // Create file
    let _ = fs::write(test_file, "Remove me");
    assert_true(fs::exists(test_file), "File should exist");

    // Remove file
    let remove_result = fs::remove_file(test_file);
    assert_true(remove_result.is_ok(), "Should remove file");

    // Verify removed
    assert_false(fs::exists(test_file), "File should not exist");
}

// Test copying files
fn test_copy_file() {
    let source = "test_source.txt";
    let dest = "test_dest.txt";
    let content = "Copy me!";

    // Create source file
    let _ = fs::write(source, content);

    // Copy file
    let copy_result = fs::copy(source, dest);
    assert_true(copy_result.is_ok(), "Should copy file");

    // Verify both files exist
    assert_true(fs::exists(source), "Source should exist");
    assert_true(fs::exists(dest), "Destination should exist");

    // Verify content matches
    let dest_content = fs::read_to_string(dest).unwrap();
    assert_eq(dest_content, content, "Content should match");

    // Clean up
    let _ = fs::remove_file(source);
    let _ = fs::remove_file(dest);
}

// Test renaming files
fn test_rename_file() {
    let old_name = "test_old.txt";
    let new_name = "test_new.txt";
    let content = "Rename me!";

    // Create file
    let _ = fs::write(old_name, content);

    // Rename file
    let rename_result = fs::rename(old_name, new_name);
    assert_true(rename_result.is_ok(), "Should rename file");

    // Verify old name doesn't exist
    assert_false(fs::exists(old_name), "Old file should not exist");

    // Verify new name exists
    assert_true(fs::exists(new_name), "New file should exist");

    // Verify content preserved
    let new_content = fs::read_to_string(new_name).unwrap();
    assert_eq(new_content, content, "Content should be preserved");

    // Clean up
    let _ = fs::remove_file(new_name);
}

// Test creating nested directories
fn test_create_dir_all() {
    let nested_dir = "test_parent/test_child";

    // Create nested directories
    let create_result = fs::create_dir_all(nested_dir);
    assert_true(create_result.is_ok(), "Should create nested directories");

    // Verify both exist
    assert_true(fs::exists("test_parent"), "Parent directory should exist");
    assert_true(fs::exists(nested_dir), "Child directory should exist");

    // Clean up
    let _ = fs::remove_dir_all("test_parent");
}


// File System Tests for Jounce
// Tests basic file and directory operations

// Test writing and reading a text file
fn test_write_and_read() {
    let test_file = "test_temp.txt";
    let content = "Hello, Jounce File I/O!";

    // Write file
    let write_result = fs::write(test_file, content);
    assert_true(write_result.is_ok(), "Should write file successfully");

    // Read file
    let read_result = fs::read_to_string(test_file);
    assert_true(read_result.is_ok(), "Should read file successfully");

    let read_content = read_result.unwrap();
    assert_eq(read_content, content, "Content should match");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test file exists check
fn test_file_exists() {
    let test_file = "test_exists.txt";

    // File should not exist initially
    assert_false(fs::exists(test_file), "File should not exist initially");

    // Create file
    let _ = fs::write(test_file, "test");

    // File should exist now
    assert_true(fs::exists(test_file), "File should exist after creation");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test file metadata
fn test_metadata() {
    let test_file = "test_metadata.txt";
    let content = "Hello World";

    // Create file
    let _ = fs::write(test_file, content);

    // Get metadata
    let meta_result = fs::metadata(test_file);
    assert_true(meta_result.is_ok(), "Should get metadata");

    let meta = meta_result.unwrap();
    assert_true(meta.is_file(), "Should be a file");
    assert_false(meta.is_directory(), "Should not be a directory");
    assert_true(meta.len() > 0, "File size should be greater than 0");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test appending to file
fn test_append() {
    let test_file = "test_append.txt";

    // Write initial content
    let _ = fs::write(test_file, "Line 1\n");

    // Append more content
    let append_result = fs::append(test_file, "Line 2\n");
    assert_true(append_result.is_ok(), "Should append successfully");

    // Read and verify
    let content = fs::read_to_string(test_file).unwrap();
    assert_true(content.contains("Line 1"), "Should contain Line 1");
    assert_true(content.contains("Line 2"), "Should contain Line 2");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test directory creation
fn test_create_directory() {
    let test_dir = "test_temp_dir";

    // Create directory
    let create_result = fs::create_dir(test_dir);
    assert_true(create_result.is_ok(), "Should create directory");

    // Check it exists
    assert_true(fs::exists(test_dir), "Directory should exist");

    // Get metadata
    let meta = fs::metadata(test_dir).unwrap();
    assert_true(meta.is_directory(), "Should be a directory");
    assert_false(meta.is_file(), "Should not be a file");

    // Clean up
    let _ = fs::remove_dir(test_dir);
}

// Test reading directory contents
fn test_read_directory() {
    let test_dir = "test_read_dir";
    let test_file1 = "test_read_dir/file1.txt";
    let test_file2 = "test_read_dir/file2.txt";

    // Create directory
    let _ = fs::create_dir(test_dir);

    // Create files in directory
    let _ = fs::write(test_file1, "File 1");
    let _ = fs::write(test_file2, "File 2");

    // Read directory
    let entries_result = fs::read_dir(test_dir);
    assert_true(entries_result.is_ok(), "Should read directory");

    let entries = entries_result.unwrap();
    assert_eq(entries.len(), 2, "Should have 2 entries");

    // Check entry names
    let entry1 = entries[0];
    let entry2 = entries[1];
    assert_true(entry1.is_file(), "Entry should be a file");
    assert_true(entry2.is_file(), "Entry should be a file");

    // Clean up
    let _ = fs::remove_file(test_file1);
    let _ = fs::remove_file(test_file2);
    let _ = fs::remove_dir(test_dir);
}

// Test file removal
fn test_remove_file() {
    let test_file = "test_remove.txt";

    // Create file
    let _ = fs::write(test_file, "Remove me");
    assert_true(fs::exists(test_file), "File should exist");

    // Remove file
    let remove_result = fs::remove_file(test_file);
    assert_true(remove_result.is_ok(), "Should remove file");

    // Verify removed
    assert_false(fs::exists(test_file), "File should not exist");
}

// Test copying files
fn test_copy_file() {
    let source = "test_source.txt";
    let dest = "test_dest.txt";
    let content = "Copy me!";

    // Create source file
    let _ = fs::write(source, content);

    // Copy file
    let copy_result = fs::copy(source, dest);
    assert_true(copy_result.is_ok(), "Should copy file");

    // Verify both files exist
    assert_true(fs::exists(source), "Source should exist");
    assert_true(fs::exists(dest), "Destination should exist");

    // Verify content matches
    let dest_content = fs::read_to_string(dest).unwrap();
    assert_eq(dest_content, content, "Content should match");

    // Clean up
    let _ = fs::remove_file(source);
    let _ = fs::remove_file(dest);
}

// Test renaming files
fn test_rename_file() {
    let old_name = "test_old.txt";
    let new_name = "test_new.txt";
    let content = "Rename me!";

    // Create file
    let _ = fs::write(old_name, content);

    // Rename file
    let rename_result = fs::rename(old_name, new_name);
    assert_true(rename_result.is_ok(), "Should rename file");

    // Verify old name doesn't exist
    assert_false(fs::exists(old_name), "Old file should not exist");

    // Verify new name exists
    assert_true(fs::exists(new_name), "New file should exist");

    // Verify content preserved
    let new_content = fs::read_to_string(new_name).unwrap();
    assert_eq(new_content, content, "Content should be preserved");

    // Clean up
    let _ = fs::remove_file(new_name);
}

// Test creating nested directories
fn test_create_dir_all() {
    let nested_dir = "test_parent/test_child";

    // Create nested directories
    let create_result = fs::create_dir_all(nested_dir);
    assert_true(create_result.is_ok(), "Should create nested directories");

    // Verify both exist
    assert_true(fs::exists("test_parent"), "Parent directory should exist");
    assert_true(fs::exists(nested_dir), "Child directory should exist");

    // Clean up
    let _ = fs::remove_dir_all("test_parent");
}


// File System Tests for Jounce
// Tests basic file and directory operations

// Test writing and reading a text file
fn test_write_and_read() {
    let test_file = "test_temp.txt";
    let content = "Hello, Jounce File I/O!";

    // Write file
    let write_result = fs::write(test_file, content);
    assert_true(write_result.is_ok(), "Should write file successfully");

    // Read file
    let read_result = fs::read_to_string(test_file);
    assert_true(read_result.is_ok(), "Should read file successfully");

    let read_content = read_result.unwrap();
    assert_eq(read_content, content, "Content should match");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test file exists check
fn test_file_exists() {
    let test_file = "test_exists.txt";

    // File should not exist initially
    assert_false(fs::exists(test_file), "File should not exist initially");

    // Create file
    let _ = fs::write(test_file, "test");

    // File should exist now
    assert_true(fs::exists(test_file), "File should exist after creation");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test file metadata
fn test_metadata() {
    let test_file = "test_metadata.txt";
    let content = "Hello World";

    // Create file
    let _ = fs::write(test_file, content);

    // Get metadata
    let meta_result = fs::metadata(test_file);
    assert_true(meta_result.is_ok(), "Should get metadata");

    let meta = meta_result.unwrap();
    assert_true(meta.is_file(), "Should be a file");
    assert_false(meta.is_directory(), "Should not be a directory");
    assert_true(meta.len() > 0, "File size should be greater than 0");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test appending to file
fn test_append() {
    let test_file = "test_append.txt";

    // Write initial content
    let _ = fs::write(test_file, "Line 1\n");

    // Append more content
    let append_result = fs::append(test_file, "Line 2\n");
    assert_true(append_result.is_ok(), "Should append successfully");

    // Read and verify
    let content = fs::read_to_string(test_file).unwrap();
    assert_true(content.contains("Line 1"), "Should contain Line 1");
    assert_true(content.contains("Line 2"), "Should contain Line 2");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test directory creation
fn test_create_directory() {
    let test_dir = "test_temp_dir";

    // Create directory
    let create_result = fs::create_dir(test_dir);
    assert_true(create_result.is_ok(), "Should create directory");

    // Check it exists
    assert_true(fs::exists(test_dir), "Directory should exist");

    // Get metadata
    let meta = fs::metadata(test_dir).unwrap();
    assert_true(meta.is_directory(), "Should be a directory");
    assert_false(meta.is_file(), "Should not be a file");

    // Clean up
    let _ = fs::remove_dir(test_dir);
}

// Test reading directory contents
fn test_read_directory() {
    let test_dir = "test_read_dir";
    let test_file1 = "test_read_dir/file1.txt";
    let test_file2 = "test_read_dir/file2.txt";

    // Create directory
    let _ = fs::create_dir(test_dir);

    // Create files in directory
    let _ = fs::write(test_file1, "File 1");
    let _ = fs::write(test_file2, "File 2");

    // Read directory
    let entries_result = fs::read_dir(test_dir);
    assert_true(entries_result.is_ok(), "Should read directory");

    let entries = entries_result.unwrap();
    assert_eq(entries.len(), 2, "Should have 2 entries");

    // Check entry names
    let entry1 = entries[0];
    let entry2 = entries[1];
    assert_true(entry1.is_file(), "Entry should be a file");
    assert_true(entry2.is_file(), "Entry should be a file");

    // Clean up
    let _ = fs::remove_file(test_file1);
    let _ = fs::remove_file(test_file2);
    let _ = fs::remove_dir(test_dir);
}

// Test file removal
fn test_remove_file() {
    let test_file = "test_remove.txt";

    // Create file
    let _ = fs::write(test_file, "Remove me");
    assert_true(fs::exists(test_file), "File should exist");

    // Remove file
    let remove_result = fs::remove_file(test_file);
    assert_true(remove_result.is_ok(), "Should remove file");

    // Verify removed
    assert_false(fs::exists(test_file), "File should not exist");
}

// Test copying files
fn test_copy_file() {
    let source = "test_source.txt";
    let dest = "test_dest.txt";
    let content = "Copy me!";

    // Create source file
    let _ = fs::write(source, content);

    // Copy file
    let copy_result = fs::copy(source, dest);
    assert_true(copy_result.is_ok(), "Should copy file");

    // Verify both files exist
    assert_true(fs::exists(source), "Source should exist");
    assert_true(fs::exists(dest), "Destination should exist");

    // Verify content matches
    let dest_content = fs::read_to_string(dest).unwrap();
    assert_eq(dest_content, content, "Content should match");

    // Clean up
    let _ = fs::remove_file(source);
    let _ = fs::remove_file(dest);
}

// Test renaming files
fn test_rename_file() {
    let old_name = "test_old.txt";
    let new_name = "test_new.txt";
    let content = "Rename me!";

    // Create file
    let _ = fs::write(old_name, content);

    // Rename file
    let rename_result = fs::rename(old_name, new_name);
    assert_true(rename_result.is_ok(), "Should rename file");

    // Verify old name doesn't exist
    assert_false(fs::exists(old_name), "Old file should not exist");

    // Verify new name exists
    assert_true(fs::exists(new_name), "New file should exist");

    // Verify content preserved
    let new_content = fs::read_to_string(new_name).unwrap();
    assert_eq(new_content, content, "Content should be preserved");

    // Clean up
    let _ = fs::remove_file(new_name);
}

// Test creating nested directories
fn test_create_dir_all() {
    let nested_dir = "test_parent/test_child";

    // Create nested directories
    let create_result = fs::create_dir_all(nested_dir);
    assert_true(create_result.is_ok(), "Should create nested directories");

    // Verify both exist
    assert_true(fs::exists("test_parent"), "Parent directory should exist");
    assert_true(fs::exists(nested_dir), "Child directory should exist");

    // Clean up
    let _ = fs::remove_dir_all("test_parent");
}


// File System Tests for Jounce
// Tests basic file and directory operations

// Test writing and reading a text file
fn test_write_and_read() {
    let test_file = "test_temp.txt";
    let content = "Hello, Jounce File I/O!";

    // Write file
    let write_result = fs::write(test_file, content);
    assert_true(write_result.is_ok(), "Should write file successfully");

    // Read file
    let read_result = fs::read_to_string(test_file);
    assert_true(read_result.is_ok(), "Should read file successfully");

    let read_content = read_result.unwrap();
    assert_eq(read_content, content, "Content should match");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test file exists check
fn test_file_exists() {
    let test_file = "test_exists.txt";

    // File should not exist initially
    assert_false(fs::exists(test_file), "File should not exist initially");

    // Create file
    let _ = fs::write(test_file, "test");

    // File should exist now
    assert_true(fs::exists(test_file), "File should exist after creation");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test file metadata
fn test_metadata() {
    let test_file = "test_metadata.txt";
    let content = "Hello World";

    // Create file
    let _ = fs::write(test_file, content);

    // Get metadata
    let meta_result = fs::metadata(test_file);
    assert_true(meta_result.is_ok(), "Should get metadata");

    let meta = meta_result.unwrap();
    assert_true(meta.is_file(), "Should be a file");
    assert_false(meta.is_directory(), "Should not be a directory");
    assert_true(meta.len() > 0, "File size should be greater than 0");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test appending to file
fn test_append() {
    let test_file = "test_append.txt";

    // Write initial content
    let _ = fs::write(test_file, "Line 1\n");

    // Append more content
    let append_result = fs::append(test_file, "Line 2\n");
    assert_true(append_result.is_ok(), "Should append successfully");

    // Read and verify
    let content = fs::read_to_string(test_file).unwrap();
    assert_true(content.contains("Line 1"), "Should contain Line 1");
    assert_true(content.contains("Line 2"), "Should contain Line 2");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test directory creation
fn test_create_directory() {
    let test_dir = "test_temp_dir";

    // Create directory
    let create_result = fs::create_dir(test_dir);
    assert_true(create_result.is_ok(), "Should create directory");

    // Check it exists
    assert_true(fs::exists(test_dir), "Directory should exist");

    // Get metadata
    let meta = fs::metadata(test_dir).unwrap();
    assert_true(meta.is_directory(), "Should be a directory");
    assert_false(meta.is_file(), "Should not be a file");

    // Clean up
    let _ = fs::remove_dir(test_dir);
}

// Test reading directory contents
fn test_read_directory() {
    let test_dir = "test_read_dir";
    let test_file1 = "test_read_dir/file1.txt";
    let test_file2 = "test_read_dir/file2.txt";

    // Create directory
    let _ = fs::create_dir(test_dir);

    // Create files in directory
    let _ = fs::write(test_file1, "File 1");
    let _ = fs::write(test_file2, "File 2");

    // Read directory
    let entries_result = fs::read_dir(test_dir);
    assert_true(entries_result.is_ok(), "Should read directory");

    let entries = entries_result.unwrap();
    assert_eq(entries.len(), 2, "Should have 2 entries");

    // Check entry names
    let entry1 = entries[0];
    let entry2 = entries[1];
    assert_true(entry1.is_file(), "Entry should be a file");
    assert_true(entry2.is_file(), "Entry should be a file");

    // Clean up
    let _ = fs::remove_file(test_file1);
    let _ = fs::remove_file(test_file2);
    let _ = fs::remove_dir(test_dir);
}

// Test file removal
fn test_remove_file() {
    let test_file = "test_remove.txt";

    // Create file
    let _ = fs::write(test_file, "Remove me");
    assert_true(fs::exists(test_file), "File should exist");

    // Remove file
    let remove_result = fs::remove_file(test_file);
    assert_true(remove_result.is_ok(), "Should remove file");

    // Verify removed
    assert_false(fs::exists(test_file), "File should not exist");
}

// Test copying files
fn test_copy_file() {
    let source = "test_source.txt";
    let dest = "test_dest.txt";
    let content = "Copy me!";

    // Create source file
    let _ = fs::write(source, content);

    // Copy file
    let copy_result = fs::copy(source, dest);
    assert_true(copy_result.is_ok(), "Should copy file");

    // Verify both files exist
    assert_true(fs::exists(source), "Source should exist");
    assert_true(fs::exists(dest), "Destination should exist");

    // Verify content matches
    let dest_content = fs::read_to_string(dest).unwrap();
    assert_eq(dest_content, content, "Content should match");

    // Clean up
    let _ = fs::remove_file(source);
    let _ = fs::remove_file(dest);
}

// Test renaming files
fn test_rename_file() {
    let old_name = "test_old.txt";
    let new_name = "test_new.txt";
    let content = "Rename me!";

    // Create file
    let _ = fs::write(old_name, content);

    // Rename file
    let rename_result = fs::rename(old_name, new_name);
    assert_true(rename_result.is_ok(), "Should rename file");

    // Verify old name doesn't exist
    assert_false(fs::exists(old_name), "Old file should not exist");

    // Verify new name exists
    assert_true(fs::exists(new_name), "New file should exist");

    // Verify content preserved
    let new_content = fs::read_to_string(new_name).unwrap();
    assert_eq(new_content, content, "Content should be preserved");

    // Clean up
    let _ = fs::remove_file(new_name);
}

// Test creating nested directories
fn test_create_dir_all() {
    let nested_dir = "test_parent/test_child";

    // Create nested directories
    let create_result = fs::create_dir_all(nested_dir);
    assert_true(create_result.is_ok(), "Should create nested directories");

    // Verify both exist
    assert_true(fs::exists("test_parent"), "Parent directory should exist");
    assert_true(fs::exists(nested_dir), "Child directory should exist");

    // Clean up
    let _ = fs::remove_dir_all("test_parent");
}


// File System Tests for Jounce
// Tests basic file and directory operations

// Test writing and reading a text file
fn test_write_and_read() {
    let test_file = "test_temp.txt";
    let content = "Hello, Jounce File I/O!";

    // Write file
    let write_result = fs::write(test_file, content);
    assert_true(write_result.is_ok(), "Should write file successfully");

    // Read file
    let read_result = fs::read_to_string(test_file);
    assert_true(read_result.is_ok(), "Should read file successfully");

    let read_content = read_result.unwrap();
    assert_eq(read_content, content, "Content should match");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test file exists check
fn test_file_exists() {
    let test_file = "test_exists.txt";

    // File should not exist initially
    assert_false(fs::exists(test_file), "File should not exist initially");

    // Create file
    let _ = fs::write(test_file, "test");

    // File should exist now
    assert_true(fs::exists(test_file), "File should exist after creation");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test file metadata
fn test_metadata() {
    let test_file = "test_metadata.txt";
    let content = "Hello World";

    // Create file
    let _ = fs::write(test_file, content);

    // Get metadata
    let meta_result = fs::metadata(test_file);
    assert_true(meta_result.is_ok(), "Should get metadata");

    let meta = meta_result.unwrap();
    assert_true(meta.is_file(), "Should be a file");
    assert_false(meta.is_directory(), "Should not be a directory");
    assert_true(meta.len() > 0, "File size should be greater than 0");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test appending to file
fn test_append() {
    let test_file = "test_append.txt";

    // Write initial content
    let _ = fs::write(test_file, "Line 1\n");

    // Append more content
    let append_result = fs::append(test_file, "Line 2\n");
    assert_true(append_result.is_ok(), "Should append successfully");

    // Read and verify
    let content = fs::read_to_string(test_file).unwrap();
    assert_true(content.contains("Line 1"), "Should contain Line 1");
    assert_true(content.contains("Line 2"), "Should contain Line 2");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test directory creation
fn test_create_directory() {
    let test_dir = "test_temp_dir";

    // Create directory
    let create_result = fs::create_dir(test_dir);
    assert_true(create_result.is_ok(), "Should create directory");

    // Check it exists
    assert_true(fs::exists(test_dir), "Directory should exist");

    // Get metadata
    let meta = fs::metadata(test_dir).unwrap();
    assert_true(meta.is_directory(), "Should be a directory");
    assert_false(meta.is_file(), "Should not be a file");

    // Clean up
    let _ = fs::remove_dir(test_dir);
}

// Test reading directory contents
fn test_read_directory() {
    let test_dir = "test_read_dir";
    let test_file1 = "test_read_dir/file1.txt";
    let test_file2 = "test_read_dir/file2.txt";

    // Create directory
    let _ = fs::create_dir(test_dir);

    // Create files in directory
    let _ = fs::write(test_file1, "File 1");
    let _ = fs::write(test_file2, "File 2");

    // Read directory
    let entries_result = fs::read_dir(test_dir);
    assert_true(entries_result.is_ok(), "Should read directory");

    let entries = entries_result.unwrap();
    assert_eq(entries.len(), 2, "Should have 2 entries");

    // Check entry names
    let entry1 = entries[0];
    let entry2 = entries[1];
    assert_true(entry1.is_file(), "Entry should be a file");
    assert_true(entry2.is_file(), "Entry should be a file");

    // Clean up
    let _ = fs::remove_file(test_file1);
    let _ = fs::remove_file(test_file2);
    let _ = fs::remove_dir(test_dir);
}

// Test file removal
fn test_remove_file() {
    let test_file = "test_remove.txt";

    // Create file
    let _ = fs::write(test_file, "Remove me");
    assert_true(fs::exists(test_file), "File should exist");

    // Remove file
    let remove_result = fs::remove_file(test_file);
    assert_true(remove_result.is_ok(), "Should remove file");

    // Verify removed
    assert_false(fs::exists(test_file), "File should not exist");
}

// Test copying files
fn test_copy_file() {
    let source = "test_source.txt";
    let dest = "test_dest.txt";
    let content = "Copy me!";

    // Create source file
    let _ = fs::write(source, content);

    // Copy file
    let copy_result = fs::copy(source, dest);
    assert_true(copy_result.is_ok(), "Should copy file");

    // Verify both files exist
    assert_true(fs::exists(source), "Source should exist");
    assert_true(fs::exists(dest), "Destination should exist");

    // Verify content matches
    let dest_content = fs::read_to_string(dest).unwrap();
    assert_eq(dest_content, content, "Content should match");

    // Clean up
    let _ = fs::remove_file(source);
    let _ = fs::remove_file(dest);
}

// Test renaming files
fn test_rename_file() {
    let old_name = "test_old.txt";
    let new_name = "test_new.txt";
    let content = "Rename me!";

    // Create file
    let _ = fs::write(old_name, content);

    // Rename file
    let rename_result = fs::rename(old_name, new_name);
    assert_true(rename_result.is_ok(), "Should rename file");

    // Verify old name doesn't exist
    assert_false(fs::exists(old_name), "Old file should not exist");

    // Verify new name exists
    assert_true(fs::exists(new_name), "New file should exist");

    // Verify content preserved
    let new_content = fs::read_to_string(new_name).unwrap();
    assert_eq(new_content, content, "Content should be preserved");

    // Clean up
    let _ = fs::remove_file(new_name);
}

// Test creating nested directories
fn test_create_dir_all() {
    let nested_dir = "test_parent/test_child";

    // Create nested directories
    let create_result = fs::create_dir_all(nested_dir);
    assert_true(create_result.is_ok(), "Should create nested directories");

    // Verify both exist
    assert_true(fs::exists("test_parent"), "Parent directory should exist");
    assert_true(fs::exists(nested_dir), "Child directory should exist");

    // Clean up
    let _ = fs::remove_dir_all("test_parent");
}


// File System Tests for Jounce
// Tests basic file and directory operations

// Test writing and reading a text file
fn test_write_and_read() {
    let test_file = "test_temp.txt";
    let content = "Hello, Jounce File I/O!";

    // Write file
    let write_result = fs::write(test_file, content);
    assert_true(write_result.is_ok(), "Should write file successfully");

    // Read file
    let read_result = fs::read_to_string(test_file);
    assert_true(read_result.is_ok(), "Should read file successfully");

    let read_content = read_result.unwrap();
    assert_eq(read_content, content, "Content should match");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test file exists check
fn test_file_exists() {
    let test_file = "test_exists.txt";

    // File should not exist initially
    assert_false(fs::exists(test_file), "File should not exist initially");

    // Create file
    let _ = fs::write(test_file, "test");

    // File should exist now
    assert_true(fs::exists(test_file), "File should exist after creation");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test file metadata
fn test_metadata() {
    let test_file = "test_metadata.txt";
    let content = "Hello World";

    // Create file
    let _ = fs::write(test_file, content);

    // Get metadata
    let meta_result = fs::metadata(test_file);
    assert_true(meta_result.is_ok(), "Should get metadata");

    let meta = meta_result.unwrap();
    assert_true(meta.is_file(), "Should be a file");
    assert_false(meta.is_directory(), "Should not be a directory");
    assert_true(meta.len() > 0, "File size should be greater than 0");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test appending to file
fn test_append() {
    let test_file = "test_append.txt";

    // Write initial content
    let _ = fs::write(test_file, "Line 1\n");

    // Append more content
    let append_result = fs::append(test_file, "Line 2\n");
    assert_true(append_result.is_ok(), "Should append successfully");

    // Read and verify
    let content = fs::read_to_string(test_file).unwrap();
    assert_true(content.contains("Line 1"), "Should contain Line 1");
    assert_true(content.contains("Line 2"), "Should contain Line 2");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test directory creation
fn test_create_directory() {
    let test_dir = "test_temp_dir";

    // Create directory
    let create_result = fs::create_dir(test_dir);
    assert_true(create_result.is_ok(), "Should create directory");

    // Check it exists
    assert_true(fs::exists(test_dir), "Directory should exist");

    // Get metadata
    let meta = fs::metadata(test_dir).unwrap();
    assert_true(meta.is_directory(), "Should be a directory");
    assert_false(meta.is_file(), "Should not be a file");

    // Clean up
    let _ = fs::remove_dir(test_dir);
}

// Test reading directory contents
fn test_read_directory() {
    let test_dir = "test_read_dir";
    let test_file1 = "test_read_dir/file1.txt";
    let test_file2 = "test_read_dir/file2.txt";

    // Create directory
    let _ = fs::create_dir(test_dir);

    // Create files in directory
    let _ = fs::write(test_file1, "File 1");
    let _ = fs::write(test_file2, "File 2");

    // Read directory
    let entries_result = fs::read_dir(test_dir);
    assert_true(entries_result.is_ok(), "Should read directory");

    let entries = entries_result.unwrap();
    assert_eq(entries.len(), 2, "Should have 2 entries");

    // Check entry names
    let entry1 = entries[0];
    let entry2 = entries[1];
    assert_true(entry1.is_file(), "Entry should be a file");
    assert_true(entry2.is_file(), "Entry should be a file");

    // Clean up
    let _ = fs::remove_file(test_file1);
    let _ = fs::remove_file(test_file2);
    let _ = fs::remove_dir(test_dir);
}

// Test file removal
fn test_remove_file() {
    let test_file = "test_remove.txt";

    // Create file
    let _ = fs::write(test_file, "Remove me");
    assert_true(fs::exists(test_file), "File should exist");

    // Remove file
    let remove_result = fs::remove_file(test_file);
    assert_true(remove_result.is_ok(), "Should remove file");

    // Verify removed
    assert_false(fs::exists(test_file), "File should not exist");
}

// Test copying files
fn test_copy_file() {
    let source = "test_source.txt";
    let dest = "test_dest.txt";
    let content = "Copy me!";

    // Create source file
    let _ = fs::write(source, content);

    // Copy file
    let copy_result = fs::copy(source, dest);
    assert_true(copy_result.is_ok(), "Should copy file");

    // Verify both files exist
    assert_true(fs::exists(source), "Source should exist");
    assert_true(fs::exists(dest), "Destination should exist");

    // Verify content matches
    let dest_content = fs::read_to_string(dest).unwrap();
    assert_eq(dest_content, content, "Content should match");

    // Clean up
    let _ = fs::remove_file(source);
    let _ = fs::remove_file(dest);
}

// Test renaming files
fn test_rename_file() {
    let old_name = "test_old.txt";
    let new_name = "test_new.txt";
    let content = "Rename me!";

    // Create file
    let _ = fs::write(old_name, content);

    // Rename file
    let rename_result = fs::rename(old_name, new_name);
    assert_true(rename_result.is_ok(), "Should rename file");

    // Verify old name doesn't exist
    assert_false(fs::exists(old_name), "Old file should not exist");

    // Verify new name exists
    assert_true(fs::exists(new_name), "New file should exist");

    // Verify content preserved
    let new_content = fs::read_to_string(new_name).unwrap();
    assert_eq(new_content, content, "Content should be preserved");

    // Clean up
    let _ = fs::remove_file(new_name);
}

// Test creating nested directories
fn test_create_dir_all() {
    let nested_dir = "test_parent/test_child";

    // Create nested directories
    let create_result = fs::create_dir_all(nested_dir);
    assert_true(create_result.is_ok(), "Should create nested directories");

    // Verify both exist
    assert_true(fs::exists("test_parent"), "Parent directory should exist");
    assert_true(fs::exists(nested_dir), "Child directory should exist");

    // Clean up
    let _ = fs::remove_dir_all("test_parent");
}


// File System Tests for Jounce
// Tests basic file and directory operations

// Test writing and reading a text file
fn test_write_and_read() {
    let test_file = "test_temp.txt";
    let content = "Hello, Jounce File I/O!";

    // Write file
    let write_result = fs::write(test_file, content);
    assert_true(write_result.is_ok(), "Should write file successfully");

    // Read file
    let read_result = fs::read_to_string(test_file);
    assert_true(read_result.is_ok(), "Should read file successfully");

    let read_content = read_result.unwrap();
    assert_eq(read_content, content, "Content should match");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test file exists check
fn test_file_exists() {
    let test_file = "test_exists.txt";

    // File should not exist initially
    assert_false(fs::exists(test_file), "File should not exist initially");

    // Create file
    let _ = fs::write(test_file, "test");

    // File should exist now
    assert_true(fs::exists(test_file), "File should exist after creation");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test file metadata
fn test_metadata() {
    let test_file = "test_metadata.txt";
    let content = "Hello World";

    // Create file
    let _ = fs::write(test_file, content);

    // Get metadata
    let meta_result = fs::metadata(test_file);
    assert_true(meta_result.is_ok(), "Should get metadata");

    let meta = meta_result.unwrap();
    assert_true(meta.is_file(), "Should be a file");
    assert_false(meta.is_directory(), "Should not be a directory");
    assert_true(meta.len() > 0, "File size should be greater than 0");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test appending to file
fn test_append() {
    let test_file = "test_append.txt";

    // Write initial content
    let _ = fs::write(test_file, "Line 1\n");

    // Append more content
    let append_result = fs::append(test_file, "Line 2\n");
    assert_true(append_result.is_ok(), "Should append successfully");

    // Read and verify
    let content = fs::read_to_string(test_file).unwrap();
    assert_true(content.contains("Line 1"), "Should contain Line 1");
    assert_true(content.contains("Line 2"), "Should contain Line 2");

    // Clean up
    let _ = fs::remove_file(test_file);
}

// Test directory creation
fn test_create_directory() {
    let test_dir = "test_temp_dir";

    // Create directory
    let create_result = fs::create_dir(test_dir);
    assert_true(create_result.is_ok(), "Should create directory");

    // Check it exists
    assert_true(fs::exists(test_dir), "Directory should exist");

    // Get metadata
    let meta = fs::metadata(test_dir).unwrap();
    assert_true(meta.is_directory(), "Should be a directory");
    assert_false(meta.is_file(), "Should not be a file");

    // Clean up
    let _ = fs::remove_dir(test_dir);
}

// Test reading directory contents
fn test_read_directory() {
    let test_dir = "test_read_dir";
    let test_file1 = "test_read_dir/file1.txt";
    let test_file2 = "test_read_dir/file2.txt";

    // Create directory
    let _ = fs::create_dir(test_dir);

    // Create files in directory
    let _ = fs::write(test_file1, "File 1");
    let _ = fs::write(test_file2, "File 2");

    // Read directory
    let entries_result = fs::read_dir(test_dir);
    assert_true(entries_result.is_ok(), "Should read directory");

    let entries = entries_result.unwrap();
    assert_eq(entries.len(), 2, "Should have 2 entries");

    // Check entry names
    let entry1 = entries[0];
    let entry2 = entries[1];
    assert_true(entry1.is_file(), "Entry should be a file");
    assert_true(entry2.is_file(), "Entry should be a file");

    // Clean up
    let _ = fs::remove_file(test_file1);
    let _ = fs::remove_file(test_file2);
    let _ = fs::remove_dir(test_dir);
}

// Test file removal
fn test_remove_file() {
    let test_file = "test_remove.txt";

    // Create file
    let _ = fs::write(test_file, "Remove me");
    assert_true(fs::exists(test_file), "File should exist");

    // Remove file
    let remove_result = fs::remove_file(test_file);
    assert_true(remove_result.is_ok(), "Should remove file");

    // Verify removed
    assert_false(fs::exists(test_file), "File should not exist");
}

// Test copying files
fn test_copy_file() {
    let source = "test_source.txt";
    let dest = "test_dest.txt";
    let content = "Copy me!";

    // Create source file
    let _ = fs::write(source, content);

    // Copy file
    let copy_result = fs::copy(source, dest);
    assert_true(copy_result.is_ok(), "Should copy file");

    // Verify both files exist
    assert_true(fs::exists(source), "Source should exist");
    assert_true(fs::exists(dest), "Destination should exist");

    // Verify content matches
    let dest_content = fs::read_to_string(dest).unwrap();
    assert_eq(dest_content, content, "Content should match");

    // Clean up
    let _ = fs::remove_file(source);
    let _ = fs::remove_file(dest);
}

// Test renaming files
fn test_rename_file() {
    let old_name = "test_old.txt";
    let new_name = "test_new.txt";
    let content = "Rename me!";

    // Create file
    let _ = fs::write(old_name, content);

    // Rename file
    let rename_result = fs::rename(old_name, new_name);
    assert_true(rename_result.is_ok(), "Should rename file");

    // Verify old name doesn't exist
    assert_false(fs::exists(old_name), "Old file should not exist");

    // Verify new name exists
    assert_true(fs::exists(new_name), "New file should exist");

    // Verify content preserved
    let new_content = fs::read_to_string(new_name).unwrap();
    assert_eq(new_content, content, "Content should be preserved");

    // Clean up
    let _ = fs::remove_file(new_name);
}

// Test creating nested directories
fn test_create_dir_all() {
    let nested_dir = "test_parent/test_child";

    // Create nested directories
    let create_result = fs::create_dir_all(nested_dir);
    assert_true(create_result.is_ok(), "Should create nested directories");

    // Verify both exist
    assert_true(fs::exists("test_parent"), "Parent directory should exist");
    assert_true(fs::exists(nested_dir), "Child directory should exist");

    // Clean up
    let _ = fs::remove_dir_all("test_parent");
}


// Test JSON Parser Implementation

// Test basic JSON parsing
fn test_parse_null() {
    let json_str = "null";
    let result = json::parse(json_str);

    match result {
        Ok(value) => {
            assert_true(value.is_null(), "Should parse null");
        },
        Err(e) => {
            assert(false, "Failed to parse null");
        },
    }
}

fn test_parse_boolean() {
    let json_true = "true";
    let json_false = "false";

    let result_true = json::parse(json_true);
    let result_false = json::parse(json_false);

    match result_true {
        Ok(value) => {
            assert_true(value.is_bool(), "Should parse true");
            let bool_val = value.as_bool();
            match bool_val {
                Ok(b) => assert_true(b, "Should be true"),
                Err(_) => assert(false, "Failed to extract bool"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse true");
        },
    }
}

fn test_parse_number() {
    let json_int = "42";
    let json_float = "3.14";
    let json_negative = "-10";

    let result = json::parse(json_int);
    match result {
        Ok(value) => {
            assert_true(value.is_number(), "Should parse number");
            let num = value.as_number();
            match num {
                Ok(n) => assert_eq(n as int, 42, "Should be 42"),
                Err(_) => assert(false, "Failed to extract number"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse number");
        },
    }
}

fn test_parse_string() {
    let json_str = "\"hello world\"";

    let result = json::parse(json_str);
    match result {
        Ok(value) => {
            assert_true(value.is_string(), "Should parse string");
            let str_val = value.as_string();
            match str_val {
                Ok(s) => assert_eq(s, "hello world", "Should be 'hello world'"),
                Err(_) => assert(false, "Failed to extract string"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse string");
        },
    }
}

fn test_parse_array() {
    let json_arr = "[1, 2, 3]";

    let result = json::parse(json_arr);
    match result {
        Ok(value) => {
            assert_true(value.is_array(), "Should parse array");
            let arr = value.as_array();
            match arr {
                Ok(a) => {
                    let len_result = value.len();
                    match len_result {
                        Ok(len) => assert_eq(len, 3, "Array should have 3 elements"),
                        Err(_) => assert(false, "Failed to get array length"),
                    }
                },
                Err(_) => assert(false, "Failed to extract array"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse array");
        },
    }
}

fn test_parse_object() {
    let json_obj = "{\"name\": \"Alice\", \"age\": 30}";

    let result = json::parse(json_obj);
    match result {
        Ok(value) => {
            assert_true(value.is_object(), "Should parse object");

            // Check if 'name' key exists
            let has_name = value.has_key("name");
            assert_true(has_name, "Object should have 'name' key");

            // Get 'name' value
            let name_value = value.get("name");
            match name_value {
                Some(val) => {
                    let name_str = val.as_string();
                    match name_str {
                        Ok(s) => assert_eq(s, "Alice", "Name should be 'Alice'"),
                        Err(_) => assert(false, "Failed to extract name string"),
                    }
                },
                None => assert(false, "'name' key not found"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse object");
        },
    }
}

fn test_stringify() {
    // Create a JSON object manually
    let obj = json::object();

    // Would need to implement set operations
    // For now, just test that stringify doesn't crash
    let json_str = json::stringify(&obj);
    assert_eq(json_str, "{}", "Empty object should stringify to '{}'");
}


// Test JSON Parser Implementation

// Test basic JSON parsing
fn test_parse_null() {
    let json_str = "null";
    let result = json::parse(json_str);

    match result {
        Ok(value) => {
            assert_true(value.is_null(), "Should parse null");
        },
        Err(e) => {
            assert(false, "Failed to parse null");
        },
    }
}

fn test_parse_boolean() {
    let json_true = "true";
    let json_false = "false";

    let result_true = json::parse(json_true);
    let result_false = json::parse(json_false);

    match result_true {
        Ok(value) => {
            assert_true(value.is_bool(), "Should parse true");
            let bool_val = value.as_bool();
            match bool_val {
                Ok(b) => assert_true(b, "Should be true"),
                Err(_) => assert(false, "Failed to extract bool"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse true");
        },
    }
}

fn test_parse_number() {
    let json_int = "42";
    let json_float = "3.14";
    let json_negative = "-10";

    let result = json::parse(json_int);
    match result {
        Ok(value) => {
            assert_true(value.is_number(), "Should parse number");
            let num = value.as_number();
            match num {
                Ok(n) => assert_eq(n as int, 42, "Should be 42"),
                Err(_) => assert(false, "Failed to extract number"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse number");
        },
    }
}

fn test_parse_string() {
    let json_str = "\"hello world\"";

    let result = json::parse(json_str);
    match result {
        Ok(value) => {
            assert_true(value.is_string(), "Should parse string");
            let str_val = value.as_string();
            match str_val {
                Ok(s) => assert_eq(s, "hello world", "Should be 'hello world'"),
                Err(_) => assert(false, "Failed to extract string"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse string");
        },
    }
}

fn test_parse_array() {
    let json_arr = "[1, 2, 3]";

    let result = json::parse(json_arr);
    match result {
        Ok(value) => {
            assert_true(value.is_array(), "Should parse array");
            let arr = value.as_array();
            match arr {
                Ok(a) => {
                    let len_result = value.len();
                    match len_result {
                        Ok(len) => assert_eq(len, 3, "Array should have 3 elements"),
                        Err(_) => assert(false, "Failed to get array length"),
                    }
                },
                Err(_) => assert(false, "Failed to extract array"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse array");
        },
    }
}

fn test_parse_object() {
    let json_obj = "{\"name\": \"Alice\", \"age\": 30}";

    let result = json::parse(json_obj);
    match result {
        Ok(value) => {
            assert_true(value.is_object(), "Should parse object");

            // Check if 'name' key exists
            let has_name = value.has_key("name");
            assert_true(has_name, "Object should have 'name' key");

            // Get 'name' value
            let name_value = value.get("name");
            match name_value {
                Some(val) => {
                    let name_str = val.as_string();
                    match name_str {
                        Ok(s) => assert_eq(s, "Alice", "Name should be 'Alice'"),
                        Err(_) => assert(false, "Failed to extract name string"),
                    }
                },
                None => assert(false, "'name' key not found"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse object");
        },
    }
}

fn test_stringify() {
    // Create a JSON object manually
    let obj = json::object();

    // Would need to implement set operations
    // For now, just test that stringify doesn't crash
    let json_str = json::stringify(&obj);
    assert_eq(json_str, "{}", "Empty object should stringify to '{}'");
}


// Test JSON Parser Implementation

// Test basic JSON parsing
fn test_parse_null() {
    let json_str = "null";
    let result = json::parse(json_str);

    match result {
        Ok(value) => {
            assert_true(value.is_null(), "Should parse null");
        },
        Err(e) => {
            assert(false, "Failed to parse null");
        },
    }
}

fn test_parse_boolean() {
    let json_true = "true";
    let json_false = "false";

    let result_true = json::parse(json_true);
    let result_false = json::parse(json_false);

    match result_true {
        Ok(value) => {
            assert_true(value.is_bool(), "Should parse true");
            let bool_val = value.as_bool();
            match bool_val {
                Ok(b) => assert_true(b, "Should be true"),
                Err(_) => assert(false, "Failed to extract bool"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse true");
        },
    }
}

fn test_parse_number() {
    let json_int = "42";
    let json_float = "3.14";
    let json_negative = "-10";

    let result = json::parse(json_int);
    match result {
        Ok(value) => {
            assert_true(value.is_number(), "Should parse number");
            let num = value.as_number();
            match num {
                Ok(n) => assert_eq(n as int, 42, "Should be 42"),
                Err(_) => assert(false, "Failed to extract number"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse number");
        },
    }
}

fn test_parse_string() {
    let json_str = "\"hello world\"";

    let result = json::parse(json_str);
    match result {
        Ok(value) => {
            assert_true(value.is_string(), "Should parse string");
            let str_val = value.as_string();
            match str_val {
                Ok(s) => assert_eq(s, "hello world", "Should be 'hello world'"),
                Err(_) => assert(false, "Failed to extract string"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse string");
        },
    }
}

fn test_parse_array() {
    let json_arr = "[1, 2, 3]";

    let result = json::parse(json_arr);
    match result {
        Ok(value) => {
            assert_true(value.is_array(), "Should parse array");
            let arr = value.as_array();
            match arr {
                Ok(a) => {
                    let len_result = value.len();
                    match len_result {
                        Ok(len) => assert_eq(len, 3, "Array should have 3 elements"),
                        Err(_) => assert(false, "Failed to get array length"),
                    }
                },
                Err(_) => assert(false, "Failed to extract array"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse array");
        },
    }
}

fn test_parse_object() {
    let json_obj = "{\"name\": \"Alice\", \"age\": 30}";

    let result = json::parse(json_obj);
    match result {
        Ok(value) => {
            assert_true(value.is_object(), "Should parse object");

            // Check if 'name' key exists
            let has_name = value.has_key("name");
            assert_true(has_name, "Object should have 'name' key");

            // Get 'name' value
            let name_value = value.get("name");
            match name_value {
                Some(val) => {
                    let name_str = val.as_string();
                    match name_str {
                        Ok(s) => assert_eq(s, "Alice", "Name should be 'Alice'"),
                        Err(_) => assert(false, "Failed to extract name string"),
                    }
                },
                None => assert(false, "'name' key not found"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse object");
        },
    }
}

fn test_stringify() {
    // Create a JSON object manually
    let obj = json::object();

    // Would need to implement set operations
    // For now, just test that stringify doesn't crash
    let json_str = json::stringify(&obj);
    assert_eq(json_str, "{}", "Empty object should stringify to '{}'");
}


// Test JSON Parser Implementation

// Test basic JSON parsing
fn test_parse_null() {
    let json_str = "null";
    let result = json::parse(json_str);

    match result {
        Ok(value) => {
            assert_true(value.is_null(), "Should parse null");
        },
        Err(e) => {
            assert(false, "Failed to parse null");
        },
    }
}

fn test_parse_boolean() {
    let json_true = "true";
    let json_false = "false";

    let result_true = json::parse(json_true);
    let result_false = json::parse(json_false);

    match result_true {
        Ok(value) => {
            assert_true(value.is_bool(), "Should parse true");
            let bool_val = value.as_bool();
            match bool_val {
                Ok(b) => assert_true(b, "Should be true"),
                Err(_) => assert(false, "Failed to extract bool"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse true");
        },
    }
}

fn test_parse_number() {
    let json_int = "42";
    let json_float = "3.14";
    let json_negative = "-10";

    let result = json::parse(json_int);
    match result {
        Ok(value) => {
            assert_true(value.is_number(), "Should parse number");
            let num = value.as_number();
            match num {
                Ok(n) => assert_eq(n as int, 42, "Should be 42"),
                Err(_) => assert(false, "Failed to extract number"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse number");
        },
    }
}

fn test_parse_string() {
    let json_str = "\"hello world\"";

    let result = json::parse(json_str);
    match result {
        Ok(value) => {
            assert_true(value.is_string(), "Should parse string");
            let str_val = value.as_string();
            match str_val {
                Ok(s) => assert_eq(s, "hello world", "Should be 'hello world'"),
                Err(_) => assert(false, "Failed to extract string"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse string");
        },
    }
}

fn test_parse_array() {
    let json_arr = "[1, 2, 3]";

    let result = json::parse(json_arr);
    match result {
        Ok(value) => {
            assert_true(value.is_array(), "Should parse array");
            let arr = value.as_array();
            match arr {
                Ok(a) => {
                    let len_result = value.len();
                    match len_result {
                        Ok(len) => assert_eq(len, 3, "Array should have 3 elements"),
                        Err(_) => assert(false, "Failed to get array length"),
                    }
                },
                Err(_) => assert(false, "Failed to extract array"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse array");
        },
    }
}

fn test_parse_object() {
    let json_obj = "{\"name\": \"Alice\", \"age\": 30}";

    let result = json::parse(json_obj);
    match result {
        Ok(value) => {
            assert_true(value.is_object(), "Should parse object");

            // Check if 'name' key exists
            let has_name = value.has_key("name");
            assert_true(has_name, "Object should have 'name' key");

            // Get 'name' value
            let name_value = value.get("name");
            match name_value {
                Some(val) => {
                    let name_str = val.as_string();
                    match name_str {
                        Ok(s) => assert_eq(s, "Alice", "Name should be 'Alice'"),
                        Err(_) => assert(false, "Failed to extract name string"),
                    }
                },
                None => assert(false, "'name' key not found"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse object");
        },
    }
}

fn test_stringify() {
    // Create a JSON object manually
    let obj = json::object();

    // Would need to implement set operations
    // For now, just test that stringify doesn't crash
    let json_str = json::stringify(&obj);
    assert_eq(json_str, "{}", "Empty object should stringify to '{}'");
}


// Test JSON Parser Implementation

// Test basic JSON parsing
fn test_parse_null() {
    let json_str = "null";
    let result = json::parse(json_str);

    match result {
        Ok(value) => {
            assert_true(value.is_null(), "Should parse null");
        },
        Err(e) => {
            assert(false, "Failed to parse null");
        },
    }
}

fn test_parse_boolean() {
    let json_true = "true";
    let json_false = "false";

    let result_true = json::parse(json_true);
    let result_false = json::parse(json_false);

    match result_true {
        Ok(value) => {
            assert_true(value.is_bool(), "Should parse true");
            let bool_val = value.as_bool();
            match bool_val {
                Ok(b) => assert_true(b, "Should be true"),
                Err(_) => assert(false, "Failed to extract bool"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse true");
        },
    }
}

fn test_parse_number() {
    let json_int = "42";
    let json_float = "3.14";
    let json_negative = "-10";

    let result = json::parse(json_int);
    match result {
        Ok(value) => {
            assert_true(value.is_number(), "Should parse number");
            let num = value.as_number();
            match num {
                Ok(n) => assert_eq(n as int, 42, "Should be 42"),
                Err(_) => assert(false, "Failed to extract number"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse number");
        },
    }
}

fn test_parse_string() {
    let json_str = "\"hello world\"";

    let result = json::parse(json_str);
    match result {
        Ok(value) => {
            assert_true(value.is_string(), "Should parse string");
            let str_val = value.as_string();
            match str_val {
                Ok(s) => assert_eq(s, "hello world", "Should be 'hello world'"),
                Err(_) => assert(false, "Failed to extract string"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse string");
        },
    }
}

fn test_parse_array() {
    let json_arr = "[1, 2, 3]";

    let result = json::parse(json_arr);
    match result {
        Ok(value) => {
            assert_true(value.is_array(), "Should parse array");
            let arr = value.as_array();
            match arr {
                Ok(a) => {
                    let len_result = value.len();
                    match len_result {
                        Ok(len) => assert_eq(len, 3, "Array should have 3 elements"),
                        Err(_) => assert(false, "Failed to get array length"),
                    }
                },
                Err(_) => assert(false, "Failed to extract array"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse array");
        },
    }
}

fn test_parse_object() {
    let json_obj = "{\"name\": \"Alice\", \"age\": 30}";

    let result = json::parse(json_obj);
    match result {
        Ok(value) => {
            assert_true(value.is_object(), "Should parse object");

            // Check if 'name' key exists
            let has_name = value.has_key("name");
            assert_true(has_name, "Object should have 'name' key");

            // Get 'name' value
            let name_value = value.get("name");
            match name_value {
                Some(val) => {
                    let name_str = val.as_string();
                    match name_str {
                        Ok(s) => assert_eq(s, "Alice", "Name should be 'Alice'"),
                        Err(_) => assert(false, "Failed to extract name string"),
                    }
                },
                None => assert(false, "'name' key not found"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse object");
        },
    }
}

fn test_stringify() {
    // Create a JSON object manually
    let obj = json::object();

    // Would need to implement set operations
    // For now, just test that stringify doesn't crash
    let json_str = json::stringify(&obj);
    assert_eq(json_str, "{}", "Empty object should stringify to '{}'");
}


// Test JSON Parser Implementation

// Test basic JSON parsing
fn test_parse_null() {
    let json_str = "null";
    let result = json::parse(json_str);

    match result {
        Ok(value) => {
            assert_true(value.is_null(), "Should parse null");
        },
        Err(e) => {
            assert(false, "Failed to parse null");
        },
    }
}

fn test_parse_boolean() {
    let json_true = "true";
    let json_false = "false";

    let result_true = json::parse(json_true);
    let result_false = json::parse(json_false);

    match result_true {
        Ok(value) => {
            assert_true(value.is_bool(), "Should parse true");
            let bool_val = value.as_bool();
            match bool_val {
                Ok(b) => assert_true(b, "Should be true"),
                Err(_) => assert(false, "Failed to extract bool"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse true");
        },
    }
}

fn test_parse_number() {
    let json_int = "42";
    let json_float = "3.14";
    let json_negative = "-10";

    let result = json::parse(json_int);
    match result {
        Ok(value) => {
            assert_true(value.is_number(), "Should parse number");
            let num = value.as_number();
            match num {
                Ok(n) => assert_eq(n as int, 42, "Should be 42"),
                Err(_) => assert(false, "Failed to extract number"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse number");
        },
    }
}

fn test_parse_string() {
    let json_str = "\"hello world\"";

    let result = json::parse(json_str);
    match result {
        Ok(value) => {
            assert_true(value.is_string(), "Should parse string");
            let str_val = value.as_string();
            match str_val {
                Ok(s) => assert_eq(s, "hello world", "Should be 'hello world'"),
                Err(_) => assert(false, "Failed to extract string"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse string");
        },
    }
}

fn test_parse_array() {
    let json_arr = "[1, 2, 3]";

    let result = json::parse(json_arr);
    match result {
        Ok(value) => {
            assert_true(value.is_array(), "Should parse array");
            let arr = value.as_array();
            match arr {
                Ok(a) => {
                    let len_result = value.len();
                    match len_result {
                        Ok(len) => assert_eq(len, 3, "Array should have 3 elements"),
                        Err(_) => assert(false, "Failed to get array length"),
                    }
                },
                Err(_) => assert(false, "Failed to extract array"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse array");
        },
    }
}

fn test_parse_object() {
    let json_obj = "{\"name\": \"Alice\", \"age\": 30}";

    let result = json::parse(json_obj);
    match result {
        Ok(value) => {
            assert_true(value.is_object(), "Should parse object");

            // Check if 'name' key exists
            let has_name = value.has_key("name");
            assert_true(has_name, "Object should have 'name' key");

            // Get 'name' value
            let name_value = value.get("name");
            match name_value {
                Some(val) => {
                    let name_str = val.as_string();
                    match name_str {
                        Ok(s) => assert_eq(s, "Alice", "Name should be 'Alice'"),
                        Err(_) => assert(false, "Failed to extract name string"),
                    }
                },
                None => assert(false, "'name' key not found"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse object");
        },
    }
}

fn test_stringify() {
    // Create a JSON object manually
    let obj = json::object();

    // Would need to implement set operations
    // For now, just test that stringify doesn't crash
    let json_str = json::stringify(&obj);
    assert_eq(json_str, "{}", "Empty object should stringify to '{}'");
}


// Test JSON Parser Implementation

// Test basic JSON parsing
fn test_parse_null() {
    let json_str = "null";
    let result = json::parse(json_str);

    match result {
        Ok(value) => {
            assert_true(value.is_null(), "Should parse null");
        },
        Err(e) => {
            assert(false, "Failed to parse null");
        },
    }
}

fn test_parse_boolean() {
    let json_true = "true";
    let json_false = "false";

    let result_true = json::parse(json_true);
    let result_false = json::parse(json_false);

    match result_true {
        Ok(value) => {
            assert_true(value.is_bool(), "Should parse true");
            let bool_val = value.as_bool();
            match bool_val {
                Ok(b) => assert_true(b, "Should be true"),
                Err(_) => assert(false, "Failed to extract bool"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse true");
        },
    }
}

fn test_parse_number() {
    let json_int = "42";
    let json_float = "3.14";
    let json_negative = "-10";

    let result = json::parse(json_int);
    match result {
        Ok(value) => {
            assert_true(value.is_number(), "Should parse number");
            let num = value.as_number();
            match num {
                Ok(n) => assert_eq(n as int, 42, "Should be 42"),
                Err(_) => assert(false, "Failed to extract number"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse number");
        },
    }
}

fn test_parse_string() {
    let json_str = "\"hello world\"";

    let result = json::parse(json_str);
    match result {
        Ok(value) => {
            assert_true(value.is_string(), "Should parse string");
            let str_val = value.as_string();
            match str_val {
                Ok(s) => assert_eq(s, "hello world", "Should be 'hello world'"),
                Err(_) => assert(false, "Failed to extract string"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse string");
        },
    }
}

fn test_parse_array() {
    let json_arr = "[1, 2, 3]";

    let result = json::parse(json_arr);
    match result {
        Ok(value) => {
            assert_true(value.is_array(), "Should parse array");
            let arr = value.as_array();
            match arr {
                Ok(a) => {
                    let len_result = value.len();
                    match len_result {
                        Ok(len) => assert_eq(len, 3, "Array should have 3 elements"),
                        Err(_) => assert(false, "Failed to get array length"),
                    }
                },
                Err(_) => assert(false, "Failed to extract array"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse array");
        },
    }
}

fn test_parse_object() {
    let json_obj = "{\"name\": \"Alice\", \"age\": 30}";

    let result = json::parse(json_obj);
    match result {
        Ok(value) => {
            assert_true(value.is_object(), "Should parse object");

            // Check if 'name' key exists
            let has_name = value.has_key("name");
            assert_true(has_name, "Object should have 'name' key");

            // Get 'name' value
            let name_value = value.get("name");
            match name_value {
                Some(val) => {
                    let name_str = val.as_string();
                    match name_str {
                        Ok(s) => assert_eq(s, "Alice", "Name should be 'Alice'"),
                        Err(_) => assert(false, "Failed to extract name string"),
                    }
                },
                None => assert(false, "'name' key not found"),
            }
        },
        Err(e) => {
            assert(false, "Failed to parse object");
        },
    }
}

fn test_stringify() {
    // Create a JSON object manually
    let obj = json::object();

    // Would need to implement set operations
    // For now, just test that stringify doesn't crash
    let json_str = json::stringify(&obj);
    assert_eq(json_str, "{}", "Empty object should stringify to '{}'");
}


// Test DateTime Implementation

// Test Duration creation and conversion
fn test_duration_creation() {
    let duration_s = Duration::from_seconds(60);
    let duration_m = Duration::from_minutes(1);

    assert_eq(duration_s.as_seconds(), 60, "60 seconds should be 60 seconds");
    assert_eq(duration_m.as_seconds(), 60, "1 minute should be 60 seconds");
    assert_eq(duration_s.as_millis(), 60000, "60 seconds should be 60000 ms");
}

fn test_duration_arithmetic() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);

    let sum = dur1.add(&dur2);
    let diff = dur1.sub(&dur2);

    assert_eq(sum.as_seconds(), 50, "30s + 20s should be 50s");
    assert_eq(diff.as_seconds(), 10, "30s - 20s should be 10s");
}

fn test_duration_comparison() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);
    let dur3 = Duration::from_seconds(30);

    assert_true(dur1.eq(&dur3), "30s should equal 30s");
    assert_true(dur1.gt(&dur2), "30s should be greater than 20s");
    assert_true(dur2.lt(&dur1), "20s should be less than 30s");
}

fn test_datetime_creation() {
    // Create from timestamp
    let dt1 = DateTime::from_timestamp(0);
    assert_eq(dt1.timestamp_millis(), 0, "Epoch should be 0");

    // Create from components (Jan 1, 2024, 00:00:00)
    let dt2 = DateTime::from_components(2024, 1, 1, 0, 0, 0);
    assert_true(dt2.year() >= 2020, "Year should be 2024 or close");
}

fn test_datetime_components() {
    // Create a specific datetime (Jan 15, 2024, 14:30:45)
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Note: These may be approximate due to simplified calendar calculations
    let year = dt.year();
    let month = dt.month();
    let day = dt.day();

    assert_true(year >= 2020 && year <= 2025, "Year should be around 2024");
}

fn test_datetime_formatting() {
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Test ISO string format
    let iso = dt.to_iso_string();
    assert_true(iso.len() > 0, "ISO string should not be empty");

    // Test custom format
    let formatted = dt.format("%Y-%m-%d");
    assert_true(formatted.len() > 0, "Formatted string should not be empty");
}

fn test_datetime_arithmetic() {
    let dt = DateTime::from_timestamp(1000000);
    let dur = Duration::from_seconds(60);

    let later = dt.add_duration(&dur);
    let earlier = dt.sub_duration(&dur);

    assert_eq(later.timestamp_millis(), 1000000 + 60000, "Should add 60 seconds");
    assert_eq(earlier.timestamp_millis(), 1000000 - 60000, "Should subtract 60 seconds");
}

fn test_datetime_comparison() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);
    let dt3 = DateTime::from_timestamp(1000000);

    assert_true(dt1.eq(&dt3), "Same timestamps should be equal");
    assert_true(dt1.lt(&dt2), "Earlier should be less than later");
    assert_true(dt2.gt(&dt1), "Later should be greater than earlier");
    assert_true(dt1.is_before(&dt2), "Should be before");
    assert_true(dt2.is_after(&dt1), "Should be after");
}

fn test_duration_between() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);

    let dur = dt2.duration_since(&dt1);

    assert_eq(dur.as_millis(), 1000000, "Duration should be 1000000 ms");
    assert_eq(dur.as_seconds(), 1000, "Duration should be 1000 seconds");
}

fn test_parse_duration() {
    let dur_s = parse_duration("5s");
    match dur_s {
        Ok(d) => assert_eq(d.as_seconds(), 5, "Should parse 5s"),
        Err(_) => assert(false, "Failed to parse 5s"),
    }

    let dur_m = parse_duration("2m");
    match dur_m {
        Ok(d) => assert_eq(d.as_minutes(), 2, "Should parse 2m"),
        Err(_) => assert(false, "Failed to parse 2m"),
    }

    let dur_h = parse_duration("1h");
    match dur_h {
        Ok(d) => assert_eq(d.as_hours(), 1, "Should parse 1h"),
        Err(_) => assert(false, "Failed to parse 1h"),
    }
}

fn test_timer() {
    let timer = Timer::start();
    let elapsed = timer.elapsed();

    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_stopwatch() {
    let mut sw = Stopwatch::new();
    sw.start();

    // Record a lap
    let lap1 = sw.lap();
    assert_true(lap1.as_millis() >= 0, "Lap time should be non-negative");

    let elapsed = sw.stop();
    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_helper_functions() {
    let sec = seconds(30);
    let min = minutes(2);
    let hr = hours(1);
    let dy = days(1);

    assert_eq(sec.as_seconds(), 30, "seconds() helper should work");
    assert_eq(min.as_minutes(), 2, "minutes() helper should work");
    assert_eq(hr.as_hours(), 1, "hours() helper should work");
    assert_eq(dy.as_days(), 1, "days() helper should work");
}


// Test DateTime Implementation

// Test Duration creation and conversion
fn test_duration_creation() {
    let duration_s = Duration::from_seconds(60);
    let duration_m = Duration::from_minutes(1);

    assert_eq(duration_s.as_seconds(), 60, "60 seconds should be 60 seconds");
    assert_eq(duration_m.as_seconds(), 60, "1 minute should be 60 seconds");
    assert_eq(duration_s.as_millis(), 60000, "60 seconds should be 60000 ms");
}

fn test_duration_arithmetic() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);

    let sum = dur1.add(&dur2);
    let diff = dur1.sub(&dur2);

    assert_eq(sum.as_seconds(), 50, "30s + 20s should be 50s");
    assert_eq(diff.as_seconds(), 10, "30s - 20s should be 10s");
}

fn test_duration_comparison() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);
    let dur3 = Duration::from_seconds(30);

    assert_true(dur1.eq(&dur3), "30s should equal 30s");
    assert_true(dur1.gt(&dur2), "30s should be greater than 20s");
    assert_true(dur2.lt(&dur1), "20s should be less than 30s");
}

fn test_datetime_creation() {
    // Create from timestamp
    let dt1 = DateTime::from_timestamp(0);
    assert_eq(dt1.timestamp_millis(), 0, "Epoch should be 0");

    // Create from components (Jan 1, 2024, 00:00:00)
    let dt2 = DateTime::from_components(2024, 1, 1, 0, 0, 0);
    assert_true(dt2.year() >= 2020, "Year should be 2024 or close");
}

fn test_datetime_components() {
    // Create a specific datetime (Jan 15, 2024, 14:30:45)
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Note: These may be approximate due to simplified calendar calculations
    let year = dt.year();
    let month = dt.month();
    let day = dt.day();

    assert_true(year >= 2020 && year <= 2025, "Year should be around 2024");
}

fn test_datetime_formatting() {
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Test ISO string format
    let iso = dt.to_iso_string();
    assert_true(iso.len() > 0, "ISO string should not be empty");

    // Test custom format
    let formatted = dt.format("%Y-%m-%d");
    assert_true(formatted.len() > 0, "Formatted string should not be empty");
}

fn test_datetime_arithmetic() {
    let dt = DateTime::from_timestamp(1000000);
    let dur = Duration::from_seconds(60);

    let later = dt.add_duration(&dur);
    let earlier = dt.sub_duration(&dur);

    assert_eq(later.timestamp_millis(), 1000000 + 60000, "Should add 60 seconds");
    assert_eq(earlier.timestamp_millis(), 1000000 - 60000, "Should subtract 60 seconds");
}

fn test_datetime_comparison() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);
    let dt3 = DateTime::from_timestamp(1000000);

    assert_true(dt1.eq(&dt3), "Same timestamps should be equal");
    assert_true(dt1.lt(&dt2), "Earlier should be less than later");
    assert_true(dt2.gt(&dt1), "Later should be greater than earlier");
    assert_true(dt1.is_before(&dt2), "Should be before");
    assert_true(dt2.is_after(&dt1), "Should be after");
}

fn test_duration_between() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);

    let dur = dt2.duration_since(&dt1);

    assert_eq(dur.as_millis(), 1000000, "Duration should be 1000000 ms");
    assert_eq(dur.as_seconds(), 1000, "Duration should be 1000 seconds");
}

fn test_parse_duration() {
    let dur_s = parse_duration("5s");
    match dur_s {
        Ok(d) => assert_eq(d.as_seconds(), 5, "Should parse 5s"),
        Err(_) => assert(false, "Failed to parse 5s"),
    }

    let dur_m = parse_duration("2m");
    match dur_m {
        Ok(d) => assert_eq(d.as_minutes(), 2, "Should parse 2m"),
        Err(_) => assert(false, "Failed to parse 2m"),
    }

    let dur_h = parse_duration("1h");
    match dur_h {
        Ok(d) => assert_eq(d.as_hours(), 1, "Should parse 1h"),
        Err(_) => assert(false, "Failed to parse 1h"),
    }
}

fn test_timer() {
    let timer = Timer::start();
    let elapsed = timer.elapsed();

    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_stopwatch() {
    let mut sw = Stopwatch::new();
    sw.start();

    // Record a lap
    let lap1 = sw.lap();
    assert_true(lap1.as_millis() >= 0, "Lap time should be non-negative");

    let elapsed = sw.stop();
    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_helper_functions() {
    let sec = seconds(30);
    let min = minutes(2);
    let hr = hours(1);
    let dy = days(1);

    assert_eq(sec.as_seconds(), 30, "seconds() helper should work");
    assert_eq(min.as_minutes(), 2, "minutes() helper should work");
    assert_eq(hr.as_hours(), 1, "hours() helper should work");
    assert_eq(dy.as_days(), 1, "days() helper should work");
}


// Test DateTime Implementation

// Test Duration creation and conversion
fn test_duration_creation() {
    let duration_s = Duration::from_seconds(60);
    let duration_m = Duration::from_minutes(1);

    assert_eq(duration_s.as_seconds(), 60, "60 seconds should be 60 seconds");
    assert_eq(duration_m.as_seconds(), 60, "1 minute should be 60 seconds");
    assert_eq(duration_s.as_millis(), 60000, "60 seconds should be 60000 ms");
}

fn test_duration_arithmetic() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);

    let sum = dur1.add(&dur2);
    let diff = dur1.sub(&dur2);

    assert_eq(sum.as_seconds(), 50, "30s + 20s should be 50s");
    assert_eq(diff.as_seconds(), 10, "30s - 20s should be 10s");
}

fn test_duration_comparison() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);
    let dur3 = Duration::from_seconds(30);

    assert_true(dur1.eq(&dur3), "30s should equal 30s");
    assert_true(dur1.gt(&dur2), "30s should be greater than 20s");
    assert_true(dur2.lt(&dur1), "20s should be less than 30s");
}

fn test_datetime_creation() {
    // Create from timestamp
    let dt1 = DateTime::from_timestamp(0);
    assert_eq(dt1.timestamp_millis(), 0, "Epoch should be 0");

    // Create from components (Jan 1, 2024, 00:00:00)
    let dt2 = DateTime::from_components(2024, 1, 1, 0, 0, 0);
    assert_true(dt2.year() >= 2020, "Year should be 2024 or close");
}

fn test_datetime_components() {
    // Create a specific datetime (Jan 15, 2024, 14:30:45)
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Note: These may be approximate due to simplified calendar calculations
    let year = dt.year();
    let month = dt.month();
    let day = dt.day();

    assert_true(year >= 2020 && year <= 2025, "Year should be around 2024");
}

fn test_datetime_formatting() {
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Test ISO string format
    let iso = dt.to_iso_string();
    assert_true(iso.len() > 0, "ISO string should not be empty");

    // Test custom format
    let formatted = dt.format("%Y-%m-%d");
    assert_true(formatted.len() > 0, "Formatted string should not be empty");
}

fn test_datetime_arithmetic() {
    let dt = DateTime::from_timestamp(1000000);
    let dur = Duration::from_seconds(60);

    let later = dt.add_duration(&dur);
    let earlier = dt.sub_duration(&dur);

    assert_eq(later.timestamp_millis(), 1000000 + 60000, "Should add 60 seconds");
    assert_eq(earlier.timestamp_millis(), 1000000 - 60000, "Should subtract 60 seconds");
}

fn test_datetime_comparison() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);
    let dt3 = DateTime::from_timestamp(1000000);

    assert_true(dt1.eq(&dt3), "Same timestamps should be equal");
    assert_true(dt1.lt(&dt2), "Earlier should be less than later");
    assert_true(dt2.gt(&dt1), "Later should be greater than earlier");
    assert_true(dt1.is_before(&dt2), "Should be before");
    assert_true(dt2.is_after(&dt1), "Should be after");
}

fn test_duration_between() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);

    let dur = dt2.duration_since(&dt1);

    assert_eq(dur.as_millis(), 1000000, "Duration should be 1000000 ms");
    assert_eq(dur.as_seconds(), 1000, "Duration should be 1000 seconds");
}

fn test_parse_duration() {
    let dur_s = parse_duration("5s");
    match dur_s {
        Ok(d) => assert_eq(d.as_seconds(), 5, "Should parse 5s"),
        Err(_) => assert(false, "Failed to parse 5s"),
    }

    let dur_m = parse_duration("2m");
    match dur_m {
        Ok(d) => assert_eq(d.as_minutes(), 2, "Should parse 2m"),
        Err(_) => assert(false, "Failed to parse 2m"),
    }

    let dur_h = parse_duration("1h");
    match dur_h {
        Ok(d) => assert_eq(d.as_hours(), 1, "Should parse 1h"),
        Err(_) => assert(false, "Failed to parse 1h"),
    }
}

fn test_timer() {
    let timer = Timer::start();
    let elapsed = timer.elapsed();

    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_stopwatch() {
    let mut sw = Stopwatch::new();
    sw.start();

    // Record a lap
    let lap1 = sw.lap();
    assert_true(lap1.as_millis() >= 0, "Lap time should be non-negative");

    let elapsed = sw.stop();
    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_helper_functions() {
    let sec = seconds(30);
    let min = minutes(2);
    let hr = hours(1);
    let dy = days(1);

    assert_eq(sec.as_seconds(), 30, "seconds() helper should work");
    assert_eq(min.as_minutes(), 2, "minutes() helper should work");
    assert_eq(hr.as_hours(), 1, "hours() helper should work");
    assert_eq(dy.as_days(), 1, "days() helper should work");
}


// Test DateTime Implementation

// Test Duration creation and conversion
fn test_duration_creation() {
    let duration_s = Duration::from_seconds(60);
    let duration_m = Duration::from_minutes(1);

    assert_eq(duration_s.as_seconds(), 60, "60 seconds should be 60 seconds");
    assert_eq(duration_m.as_seconds(), 60, "1 minute should be 60 seconds");
    assert_eq(duration_s.as_millis(), 60000, "60 seconds should be 60000 ms");
}

fn test_duration_arithmetic() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);

    let sum = dur1.add(&dur2);
    let diff = dur1.sub(&dur2);

    assert_eq(sum.as_seconds(), 50, "30s + 20s should be 50s");
    assert_eq(diff.as_seconds(), 10, "30s - 20s should be 10s");
}

fn test_duration_comparison() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);
    let dur3 = Duration::from_seconds(30);

    assert_true(dur1.eq(&dur3), "30s should equal 30s");
    assert_true(dur1.gt(&dur2), "30s should be greater than 20s");
    assert_true(dur2.lt(&dur1), "20s should be less than 30s");
}

fn test_datetime_creation() {
    // Create from timestamp
    let dt1 = DateTime::from_timestamp(0);
    assert_eq(dt1.timestamp_millis(), 0, "Epoch should be 0");

    // Create from components (Jan 1, 2024, 00:00:00)
    let dt2 = DateTime::from_components(2024, 1, 1, 0, 0, 0);
    assert_true(dt2.year() >= 2020, "Year should be 2024 or close");
}

fn test_datetime_components() {
    // Create a specific datetime (Jan 15, 2024, 14:30:45)
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Note: These may be approximate due to simplified calendar calculations
    let year = dt.year();
    let month = dt.month();
    let day = dt.day();

    assert_true(year >= 2020 && year <= 2025, "Year should be around 2024");
}

fn test_datetime_formatting() {
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Test ISO string format
    let iso = dt.to_iso_string();
    assert_true(iso.len() > 0, "ISO string should not be empty");

    // Test custom format
    let formatted = dt.format("%Y-%m-%d");
    assert_true(formatted.len() > 0, "Formatted string should not be empty");
}

fn test_datetime_arithmetic() {
    let dt = DateTime::from_timestamp(1000000);
    let dur = Duration::from_seconds(60);

    let later = dt.add_duration(&dur);
    let earlier = dt.sub_duration(&dur);

    assert_eq(later.timestamp_millis(), 1000000 + 60000, "Should add 60 seconds");
    assert_eq(earlier.timestamp_millis(), 1000000 - 60000, "Should subtract 60 seconds");
}

fn test_datetime_comparison() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);
    let dt3 = DateTime::from_timestamp(1000000);

    assert_true(dt1.eq(&dt3), "Same timestamps should be equal");
    assert_true(dt1.lt(&dt2), "Earlier should be less than later");
    assert_true(dt2.gt(&dt1), "Later should be greater than earlier");
    assert_true(dt1.is_before(&dt2), "Should be before");
    assert_true(dt2.is_after(&dt1), "Should be after");
}

fn test_duration_between() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);

    let dur = dt2.duration_since(&dt1);

    assert_eq(dur.as_millis(), 1000000, "Duration should be 1000000 ms");
    assert_eq(dur.as_seconds(), 1000, "Duration should be 1000 seconds");
}

fn test_parse_duration() {
    let dur_s = parse_duration("5s");
    match dur_s {
        Ok(d) => assert_eq(d.as_seconds(), 5, "Should parse 5s"),
        Err(_) => assert(false, "Failed to parse 5s"),
    }

    let dur_m = parse_duration("2m");
    match dur_m {
        Ok(d) => assert_eq(d.as_minutes(), 2, "Should parse 2m"),
        Err(_) => assert(false, "Failed to parse 2m"),
    }

    let dur_h = parse_duration("1h");
    match dur_h {
        Ok(d) => assert_eq(d.as_hours(), 1, "Should parse 1h"),
        Err(_) => assert(false, "Failed to parse 1h"),
    }
}

fn test_timer() {
    let timer = Timer::start();
    let elapsed = timer.elapsed();

    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_stopwatch() {
    let mut sw = Stopwatch::new();
    sw.start();

    // Record a lap
    let lap1 = sw.lap();
    assert_true(lap1.as_millis() >= 0, "Lap time should be non-negative");

    let elapsed = sw.stop();
    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_helper_functions() {
    let sec = seconds(30);
    let min = minutes(2);
    let hr = hours(1);
    let dy = days(1);

    assert_eq(sec.as_seconds(), 30, "seconds() helper should work");
    assert_eq(min.as_minutes(), 2, "minutes() helper should work");
    assert_eq(hr.as_hours(), 1, "hours() helper should work");
    assert_eq(dy.as_days(), 1, "days() helper should work");
}


// Test DateTime Implementation

// Test Duration creation and conversion
fn test_duration_creation() {
    let duration_s = Duration::from_seconds(60);
    let duration_m = Duration::from_minutes(1);

    assert_eq(duration_s.as_seconds(), 60, "60 seconds should be 60 seconds");
    assert_eq(duration_m.as_seconds(), 60, "1 minute should be 60 seconds");
    assert_eq(duration_s.as_millis(), 60000, "60 seconds should be 60000 ms");
}

fn test_duration_arithmetic() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);

    let sum = dur1.add(&dur2);
    let diff = dur1.sub(&dur2);

    assert_eq(sum.as_seconds(), 50, "30s + 20s should be 50s");
    assert_eq(diff.as_seconds(), 10, "30s - 20s should be 10s");
}

fn test_duration_comparison() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);
    let dur3 = Duration::from_seconds(30);

    assert_true(dur1.eq(&dur3), "30s should equal 30s");
    assert_true(dur1.gt(&dur2), "30s should be greater than 20s");
    assert_true(dur2.lt(&dur1), "20s should be less than 30s");
}

fn test_datetime_creation() {
    // Create from timestamp
    let dt1 = DateTime::from_timestamp(0);
    assert_eq(dt1.timestamp_millis(), 0, "Epoch should be 0");

    // Create from components (Jan 1, 2024, 00:00:00)
    let dt2 = DateTime::from_components(2024, 1, 1, 0, 0, 0);
    assert_true(dt2.year() >= 2020, "Year should be 2024 or close");
}

fn test_datetime_components() {
    // Create a specific datetime (Jan 15, 2024, 14:30:45)
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Note: These may be approximate due to simplified calendar calculations
    let year = dt.year();
    let month = dt.month();
    let day = dt.day();

    assert_true(year >= 2020 && year <= 2025, "Year should be around 2024");
}

fn test_datetime_formatting() {
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Test ISO string format
    let iso = dt.to_iso_string();
    assert_true(iso.len() > 0, "ISO string should not be empty");

    // Test custom format
    let formatted = dt.format("%Y-%m-%d");
    assert_true(formatted.len() > 0, "Formatted string should not be empty");
}

fn test_datetime_arithmetic() {
    let dt = DateTime::from_timestamp(1000000);
    let dur = Duration::from_seconds(60);

    let later = dt.add_duration(&dur);
    let earlier = dt.sub_duration(&dur);

    assert_eq(later.timestamp_millis(), 1000000 + 60000, "Should add 60 seconds");
    assert_eq(earlier.timestamp_millis(), 1000000 - 60000, "Should subtract 60 seconds");
}

fn test_datetime_comparison() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);
    let dt3 = DateTime::from_timestamp(1000000);

    assert_true(dt1.eq(&dt3), "Same timestamps should be equal");
    assert_true(dt1.lt(&dt2), "Earlier should be less than later");
    assert_true(dt2.gt(&dt1), "Later should be greater than earlier");
    assert_true(dt1.is_before(&dt2), "Should be before");
    assert_true(dt2.is_after(&dt1), "Should be after");
}

fn test_duration_between() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);

    let dur = dt2.duration_since(&dt1);

    assert_eq(dur.as_millis(), 1000000, "Duration should be 1000000 ms");
    assert_eq(dur.as_seconds(), 1000, "Duration should be 1000 seconds");
}

fn test_parse_duration() {
    let dur_s = parse_duration("5s");
    match dur_s {
        Ok(d) => assert_eq(d.as_seconds(), 5, "Should parse 5s"),
        Err(_) => assert(false, "Failed to parse 5s"),
    }

    let dur_m = parse_duration("2m");
    match dur_m {
        Ok(d) => assert_eq(d.as_minutes(), 2, "Should parse 2m"),
        Err(_) => assert(false, "Failed to parse 2m"),
    }

    let dur_h = parse_duration("1h");
    match dur_h {
        Ok(d) => assert_eq(d.as_hours(), 1, "Should parse 1h"),
        Err(_) => assert(false, "Failed to parse 1h"),
    }
}

fn test_timer() {
    let timer = Timer::start();
    let elapsed = timer.elapsed();

    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_stopwatch() {
    let mut sw = Stopwatch::new();
    sw.start();

    // Record a lap
    let lap1 = sw.lap();
    assert_true(lap1.as_millis() >= 0, "Lap time should be non-negative");

    let elapsed = sw.stop();
    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_helper_functions() {
    let sec = seconds(30);
    let min = minutes(2);
    let hr = hours(1);
    let dy = days(1);

    assert_eq(sec.as_seconds(), 30, "seconds() helper should work");
    assert_eq(min.as_minutes(), 2, "minutes() helper should work");
    assert_eq(hr.as_hours(), 1, "hours() helper should work");
    assert_eq(dy.as_days(), 1, "days() helper should work");
}


// Test DateTime Implementation

// Test Duration creation and conversion
fn test_duration_creation() {
    let duration_s = Duration::from_seconds(60);
    let duration_m = Duration::from_minutes(1);

    assert_eq(duration_s.as_seconds(), 60, "60 seconds should be 60 seconds");
    assert_eq(duration_m.as_seconds(), 60, "1 minute should be 60 seconds");
    assert_eq(duration_s.as_millis(), 60000, "60 seconds should be 60000 ms");
}

fn test_duration_arithmetic() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);

    let sum = dur1.add(&dur2);
    let diff = dur1.sub(&dur2);

    assert_eq(sum.as_seconds(), 50, "30s + 20s should be 50s");
    assert_eq(diff.as_seconds(), 10, "30s - 20s should be 10s");
}

fn test_duration_comparison() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);
    let dur3 = Duration::from_seconds(30);

    assert_true(dur1.eq(&dur3), "30s should equal 30s");
    assert_true(dur1.gt(&dur2), "30s should be greater than 20s");
    assert_true(dur2.lt(&dur1), "20s should be less than 30s");
}

fn test_datetime_creation() {
    // Create from timestamp
    let dt1 = DateTime::from_timestamp(0);
    assert_eq(dt1.timestamp_millis(), 0, "Epoch should be 0");

    // Create from components (Jan 1, 2024, 00:00:00)
    let dt2 = DateTime::from_components(2024, 1, 1, 0, 0, 0);
    assert_true(dt2.year() >= 2020, "Year should be 2024 or close");
}

fn test_datetime_components() {
    // Create a specific datetime (Jan 15, 2024, 14:30:45)
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Note: These may be approximate due to simplified calendar calculations
    let year = dt.year();
    let month = dt.month();
    let day = dt.day();

    assert_true(year >= 2020 && year <= 2025, "Year should be around 2024");
}

fn test_datetime_formatting() {
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Test ISO string format
    let iso = dt.to_iso_string();
    assert_true(iso.len() > 0, "ISO string should not be empty");

    // Test custom format
    let formatted = dt.format("%Y-%m-%d");
    assert_true(formatted.len() > 0, "Formatted string should not be empty");
}

fn test_datetime_arithmetic() {
    let dt = DateTime::from_timestamp(1000000);
    let dur = Duration::from_seconds(60);

    let later = dt.add_duration(&dur);
    let earlier = dt.sub_duration(&dur);

    assert_eq(later.timestamp_millis(), 1000000 + 60000, "Should add 60 seconds");
    assert_eq(earlier.timestamp_millis(), 1000000 - 60000, "Should subtract 60 seconds");
}

fn test_datetime_comparison() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);
    let dt3 = DateTime::from_timestamp(1000000);

    assert_true(dt1.eq(&dt3), "Same timestamps should be equal");
    assert_true(dt1.lt(&dt2), "Earlier should be less than later");
    assert_true(dt2.gt(&dt1), "Later should be greater than earlier");
    assert_true(dt1.is_before(&dt2), "Should be before");
    assert_true(dt2.is_after(&dt1), "Should be after");
}

fn test_duration_between() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);

    let dur = dt2.duration_since(&dt1);

    assert_eq(dur.as_millis(), 1000000, "Duration should be 1000000 ms");
    assert_eq(dur.as_seconds(), 1000, "Duration should be 1000 seconds");
}

fn test_parse_duration() {
    let dur_s = parse_duration("5s");
    match dur_s {
        Ok(d) => assert_eq(d.as_seconds(), 5, "Should parse 5s"),
        Err(_) => assert(false, "Failed to parse 5s"),
    }

    let dur_m = parse_duration("2m");
    match dur_m {
        Ok(d) => assert_eq(d.as_minutes(), 2, "Should parse 2m"),
        Err(_) => assert(false, "Failed to parse 2m"),
    }

    let dur_h = parse_duration("1h");
    match dur_h {
        Ok(d) => assert_eq(d.as_hours(), 1, "Should parse 1h"),
        Err(_) => assert(false, "Failed to parse 1h"),
    }
}

fn test_timer() {
    let timer = Timer::start();
    let elapsed = timer.elapsed();

    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_stopwatch() {
    let mut sw = Stopwatch::new();
    sw.start();

    // Record a lap
    let lap1 = sw.lap();
    assert_true(lap1.as_millis() >= 0, "Lap time should be non-negative");

    let elapsed = sw.stop();
    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_helper_functions() {
    let sec = seconds(30);
    let min = minutes(2);
    let hr = hours(1);
    let dy = days(1);

    assert_eq(sec.as_seconds(), 30, "seconds() helper should work");
    assert_eq(min.as_minutes(), 2, "minutes() helper should work");
    assert_eq(hr.as_hours(), 1, "hours() helper should work");
    assert_eq(dy.as_days(), 1, "days() helper should work");
}


// Test DateTime Implementation

// Test Duration creation and conversion
fn test_duration_creation() {
    let duration_s = Duration::from_seconds(60);
    let duration_m = Duration::from_minutes(1);

    assert_eq(duration_s.as_seconds(), 60, "60 seconds should be 60 seconds");
    assert_eq(duration_m.as_seconds(), 60, "1 minute should be 60 seconds");
    assert_eq(duration_s.as_millis(), 60000, "60 seconds should be 60000 ms");
}

fn test_duration_arithmetic() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);

    let sum = dur1.add(&dur2);
    let diff = dur1.sub(&dur2);

    assert_eq(sum.as_seconds(), 50, "30s + 20s should be 50s");
    assert_eq(diff.as_seconds(), 10, "30s - 20s should be 10s");
}

fn test_duration_comparison() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);
    let dur3 = Duration::from_seconds(30);

    assert_true(dur1.eq(&dur3), "30s should equal 30s");
    assert_true(dur1.gt(&dur2), "30s should be greater than 20s");
    assert_true(dur2.lt(&dur1), "20s should be less than 30s");
}

fn test_datetime_creation() {
    // Create from timestamp
    let dt1 = DateTime::from_timestamp(0);
    assert_eq(dt1.timestamp_millis(), 0, "Epoch should be 0");

    // Create from components (Jan 1, 2024, 00:00:00)
    let dt2 = DateTime::from_components(2024, 1, 1, 0, 0, 0);
    assert_true(dt2.year() >= 2020, "Year should be 2024 or close");
}

fn test_datetime_components() {
    // Create a specific datetime (Jan 15, 2024, 14:30:45)
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Note: These may be approximate due to simplified calendar calculations
    let year = dt.year();
    let month = dt.month();
    let day = dt.day();

    assert_true(year >= 2020 && year <= 2025, "Year should be around 2024");
}

fn test_datetime_formatting() {
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Test ISO string format
    let iso = dt.to_iso_string();
    assert_true(iso.len() > 0, "ISO string should not be empty");

    // Test custom format
    let formatted = dt.format("%Y-%m-%d");
    assert_true(formatted.len() > 0, "Formatted string should not be empty");
}

fn test_datetime_arithmetic() {
    let dt = DateTime::from_timestamp(1000000);
    let dur = Duration::from_seconds(60);

    let later = dt.add_duration(&dur);
    let earlier = dt.sub_duration(&dur);

    assert_eq(later.timestamp_millis(), 1000000 + 60000, "Should add 60 seconds");
    assert_eq(earlier.timestamp_millis(), 1000000 - 60000, "Should subtract 60 seconds");
}

fn test_datetime_comparison() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);
    let dt3 = DateTime::from_timestamp(1000000);

    assert_true(dt1.eq(&dt3), "Same timestamps should be equal");
    assert_true(dt1.lt(&dt2), "Earlier should be less than later");
    assert_true(dt2.gt(&dt1), "Later should be greater than earlier");
    assert_true(dt1.is_before(&dt2), "Should be before");
    assert_true(dt2.is_after(&dt1), "Should be after");
}

fn test_duration_between() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);

    let dur = dt2.duration_since(&dt1);

    assert_eq(dur.as_millis(), 1000000, "Duration should be 1000000 ms");
    assert_eq(dur.as_seconds(), 1000, "Duration should be 1000 seconds");
}

fn test_parse_duration() {
    let dur_s = parse_duration("5s");
    match dur_s {
        Ok(d) => assert_eq(d.as_seconds(), 5, "Should parse 5s"),
        Err(_) => assert(false, "Failed to parse 5s"),
    }

    let dur_m = parse_duration("2m");
    match dur_m {
        Ok(d) => assert_eq(d.as_minutes(), 2, "Should parse 2m"),
        Err(_) => assert(false, "Failed to parse 2m"),
    }

    let dur_h = parse_duration("1h");
    match dur_h {
        Ok(d) => assert_eq(d.as_hours(), 1, "Should parse 1h"),
        Err(_) => assert(false, "Failed to parse 1h"),
    }
}

fn test_timer() {
    let timer = Timer::start();
    let elapsed = timer.elapsed();

    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_stopwatch() {
    let mut sw = Stopwatch::new();
    sw.start();

    // Record a lap
    let lap1 = sw.lap();
    assert_true(lap1.as_millis() >= 0, "Lap time should be non-negative");

    let elapsed = sw.stop();
    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_helper_functions() {
    let sec = seconds(30);
    let min = minutes(2);
    let hr = hours(1);
    let dy = days(1);

    assert_eq(sec.as_seconds(), 30, "seconds() helper should work");
    assert_eq(min.as_minutes(), 2, "minutes() helper should work");
    assert_eq(hr.as_hours(), 1, "hours() helper should work");
    assert_eq(dy.as_days(), 1, "days() helper should work");
}


// Test DateTime Implementation

// Test Duration creation and conversion
fn test_duration_creation() {
    let duration_s = Duration::from_seconds(60);
    let duration_m = Duration::from_minutes(1);

    assert_eq(duration_s.as_seconds(), 60, "60 seconds should be 60 seconds");
    assert_eq(duration_m.as_seconds(), 60, "1 minute should be 60 seconds");
    assert_eq(duration_s.as_millis(), 60000, "60 seconds should be 60000 ms");
}

fn test_duration_arithmetic() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);

    let sum = dur1.add(&dur2);
    let diff = dur1.sub(&dur2);

    assert_eq(sum.as_seconds(), 50, "30s + 20s should be 50s");
    assert_eq(diff.as_seconds(), 10, "30s - 20s should be 10s");
}

fn test_duration_comparison() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);
    let dur3 = Duration::from_seconds(30);

    assert_true(dur1.eq(&dur3), "30s should equal 30s");
    assert_true(dur1.gt(&dur2), "30s should be greater than 20s");
    assert_true(dur2.lt(&dur1), "20s should be less than 30s");
}

fn test_datetime_creation() {
    // Create from timestamp
    let dt1 = DateTime::from_timestamp(0);
    assert_eq(dt1.timestamp_millis(), 0, "Epoch should be 0");

    // Create from components (Jan 1, 2024, 00:00:00)
    let dt2 = DateTime::from_components(2024, 1, 1, 0, 0, 0);
    assert_true(dt2.year() >= 2020, "Year should be 2024 or close");
}

fn test_datetime_components() {
    // Create a specific datetime (Jan 15, 2024, 14:30:45)
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Note: These may be approximate due to simplified calendar calculations
    let year = dt.year();
    let month = dt.month();
    let day = dt.day();

    assert_true(year >= 2020 && year <= 2025, "Year should be around 2024");
}

fn test_datetime_formatting() {
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Test ISO string format
    let iso = dt.to_iso_string();
    assert_true(iso.len() > 0, "ISO string should not be empty");

    // Test custom format
    let formatted = dt.format("%Y-%m-%d");
    assert_true(formatted.len() > 0, "Formatted string should not be empty");
}

fn test_datetime_arithmetic() {
    let dt = DateTime::from_timestamp(1000000);
    let dur = Duration::from_seconds(60);

    let later = dt.add_duration(&dur);
    let earlier = dt.sub_duration(&dur);

    assert_eq(later.timestamp_millis(), 1000000 + 60000, "Should add 60 seconds");
    assert_eq(earlier.timestamp_millis(), 1000000 - 60000, "Should subtract 60 seconds");
}

fn test_datetime_comparison() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);
    let dt3 = DateTime::from_timestamp(1000000);

    assert_true(dt1.eq(&dt3), "Same timestamps should be equal");
    assert_true(dt1.lt(&dt2), "Earlier should be less than later");
    assert_true(dt2.gt(&dt1), "Later should be greater than earlier");
    assert_true(dt1.is_before(&dt2), "Should be before");
    assert_true(dt2.is_after(&dt1), "Should be after");
}

fn test_duration_between() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);

    let dur = dt2.duration_since(&dt1);

    assert_eq(dur.as_millis(), 1000000, "Duration should be 1000000 ms");
    assert_eq(dur.as_seconds(), 1000, "Duration should be 1000 seconds");
}

fn test_parse_duration() {
    let dur_s = parse_duration("5s");
    match dur_s {
        Ok(d) => assert_eq(d.as_seconds(), 5, "Should parse 5s"),
        Err(_) => assert(false, "Failed to parse 5s"),
    }

    let dur_m = parse_duration("2m");
    match dur_m {
        Ok(d) => assert_eq(d.as_minutes(), 2, "Should parse 2m"),
        Err(_) => assert(false, "Failed to parse 2m"),
    }

    let dur_h = parse_duration("1h");
    match dur_h {
        Ok(d) => assert_eq(d.as_hours(), 1, "Should parse 1h"),
        Err(_) => assert(false, "Failed to parse 1h"),
    }
}

fn test_timer() {
    let timer = Timer::start();
    let elapsed = timer.elapsed();

    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_stopwatch() {
    let mut sw = Stopwatch::new();
    sw.start();

    // Record a lap
    let lap1 = sw.lap();
    assert_true(lap1.as_millis() >= 0, "Lap time should be non-negative");

    let elapsed = sw.stop();
    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_helper_functions() {
    let sec = seconds(30);
    let min = minutes(2);
    let hr = hours(1);
    let dy = days(1);

    assert_eq(sec.as_seconds(), 30, "seconds() helper should work");
    assert_eq(min.as_minutes(), 2, "minutes() helper should work");
    assert_eq(hr.as_hours(), 1, "hours() helper should work");
    assert_eq(dy.as_days(), 1, "days() helper should work");
}


// Test DateTime Implementation

// Test Duration creation and conversion
fn test_duration_creation() {
    let duration_s = Duration::from_seconds(60);
    let duration_m = Duration::from_minutes(1);

    assert_eq(duration_s.as_seconds(), 60, "60 seconds should be 60 seconds");
    assert_eq(duration_m.as_seconds(), 60, "1 minute should be 60 seconds");
    assert_eq(duration_s.as_millis(), 60000, "60 seconds should be 60000 ms");
}

fn test_duration_arithmetic() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);

    let sum = dur1.add(&dur2);
    let diff = dur1.sub(&dur2);

    assert_eq(sum.as_seconds(), 50, "30s + 20s should be 50s");
    assert_eq(diff.as_seconds(), 10, "30s - 20s should be 10s");
}

fn test_duration_comparison() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);
    let dur3 = Duration::from_seconds(30);

    assert_true(dur1.eq(&dur3), "30s should equal 30s");
    assert_true(dur1.gt(&dur2), "30s should be greater than 20s");
    assert_true(dur2.lt(&dur1), "20s should be less than 30s");
}

fn test_datetime_creation() {
    // Create from timestamp
    let dt1 = DateTime::from_timestamp(0);
    assert_eq(dt1.timestamp_millis(), 0, "Epoch should be 0");

    // Create from components (Jan 1, 2024, 00:00:00)
    let dt2 = DateTime::from_components(2024, 1, 1, 0, 0, 0);
    assert_true(dt2.year() >= 2020, "Year should be 2024 or close");
}

fn test_datetime_components() {
    // Create a specific datetime (Jan 15, 2024, 14:30:45)
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Note: These may be approximate due to simplified calendar calculations
    let year = dt.year();
    let month = dt.month();
    let day = dt.day();

    assert_true(year >= 2020 && year <= 2025, "Year should be around 2024");
}

fn test_datetime_formatting() {
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Test ISO string format
    let iso = dt.to_iso_string();
    assert_true(iso.len() > 0, "ISO string should not be empty");

    // Test custom format
    let formatted = dt.format("%Y-%m-%d");
    assert_true(formatted.len() > 0, "Formatted string should not be empty");
}

fn test_datetime_arithmetic() {
    let dt = DateTime::from_timestamp(1000000);
    let dur = Duration::from_seconds(60);

    let later = dt.add_duration(&dur);
    let earlier = dt.sub_duration(&dur);

    assert_eq(later.timestamp_millis(), 1000000 + 60000, "Should add 60 seconds");
    assert_eq(earlier.timestamp_millis(), 1000000 - 60000, "Should subtract 60 seconds");
}

fn test_datetime_comparison() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);
    let dt3 = DateTime::from_timestamp(1000000);

    assert_true(dt1.eq(&dt3), "Same timestamps should be equal");
    assert_true(dt1.lt(&dt2), "Earlier should be less than later");
    assert_true(dt2.gt(&dt1), "Later should be greater than earlier");
    assert_true(dt1.is_before(&dt2), "Should be before");
    assert_true(dt2.is_after(&dt1), "Should be after");
}

fn test_duration_between() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);

    let dur = dt2.duration_since(&dt1);

    assert_eq(dur.as_millis(), 1000000, "Duration should be 1000000 ms");
    assert_eq(dur.as_seconds(), 1000, "Duration should be 1000 seconds");
}

fn test_parse_duration() {
    let dur_s = parse_duration("5s");
    match dur_s {
        Ok(d) => assert_eq(d.as_seconds(), 5, "Should parse 5s"),
        Err(_) => assert(false, "Failed to parse 5s"),
    }

    let dur_m = parse_duration("2m");
    match dur_m {
        Ok(d) => assert_eq(d.as_minutes(), 2, "Should parse 2m"),
        Err(_) => assert(false, "Failed to parse 2m"),
    }

    let dur_h = parse_duration("1h");
    match dur_h {
        Ok(d) => assert_eq(d.as_hours(), 1, "Should parse 1h"),
        Err(_) => assert(false, "Failed to parse 1h"),
    }
}

fn test_timer() {
    let timer = Timer::start();
    let elapsed = timer.elapsed();

    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_stopwatch() {
    let mut sw = Stopwatch::new();
    sw.start();

    // Record a lap
    let lap1 = sw.lap();
    assert_true(lap1.as_millis() >= 0, "Lap time should be non-negative");

    let elapsed = sw.stop();
    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_helper_functions() {
    let sec = seconds(30);
    let min = minutes(2);
    let hr = hours(1);
    let dy = days(1);

    assert_eq(sec.as_seconds(), 30, "seconds() helper should work");
    assert_eq(min.as_minutes(), 2, "minutes() helper should work");
    assert_eq(hr.as_hours(), 1, "hours() helper should work");
    assert_eq(dy.as_days(), 1, "days() helper should work");
}


// Test DateTime Implementation

// Test Duration creation and conversion
fn test_duration_creation() {
    let duration_s = Duration::from_seconds(60);
    let duration_m = Duration::from_minutes(1);

    assert_eq(duration_s.as_seconds(), 60, "60 seconds should be 60 seconds");
    assert_eq(duration_m.as_seconds(), 60, "1 minute should be 60 seconds");
    assert_eq(duration_s.as_millis(), 60000, "60 seconds should be 60000 ms");
}

fn test_duration_arithmetic() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);

    let sum = dur1.add(&dur2);
    let diff = dur1.sub(&dur2);

    assert_eq(sum.as_seconds(), 50, "30s + 20s should be 50s");
    assert_eq(diff.as_seconds(), 10, "30s - 20s should be 10s");
}

fn test_duration_comparison() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);
    let dur3 = Duration::from_seconds(30);

    assert_true(dur1.eq(&dur3), "30s should equal 30s");
    assert_true(dur1.gt(&dur2), "30s should be greater than 20s");
    assert_true(dur2.lt(&dur1), "20s should be less than 30s");
}

fn test_datetime_creation() {
    // Create from timestamp
    let dt1 = DateTime::from_timestamp(0);
    assert_eq(dt1.timestamp_millis(), 0, "Epoch should be 0");

    // Create from components (Jan 1, 2024, 00:00:00)
    let dt2 = DateTime::from_components(2024, 1, 1, 0, 0, 0);
    assert_true(dt2.year() >= 2020, "Year should be 2024 or close");
}

fn test_datetime_components() {
    // Create a specific datetime (Jan 15, 2024, 14:30:45)
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Note: These may be approximate due to simplified calendar calculations
    let year = dt.year();
    let month = dt.month();
    let day = dt.day();

    assert_true(year >= 2020 && year <= 2025, "Year should be around 2024");
}

fn test_datetime_formatting() {
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Test ISO string format
    let iso = dt.to_iso_string();
    assert_true(iso.len() > 0, "ISO string should not be empty");

    // Test custom format
    let formatted = dt.format("%Y-%m-%d");
    assert_true(formatted.len() > 0, "Formatted string should not be empty");
}

fn test_datetime_arithmetic() {
    let dt = DateTime::from_timestamp(1000000);
    let dur = Duration::from_seconds(60);

    let later = dt.add_duration(&dur);
    let earlier = dt.sub_duration(&dur);

    assert_eq(later.timestamp_millis(), 1000000 + 60000, "Should add 60 seconds");
    assert_eq(earlier.timestamp_millis(), 1000000 - 60000, "Should subtract 60 seconds");
}

fn test_datetime_comparison() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);
    let dt3 = DateTime::from_timestamp(1000000);

    assert_true(dt1.eq(&dt3), "Same timestamps should be equal");
    assert_true(dt1.lt(&dt2), "Earlier should be less than later");
    assert_true(dt2.gt(&dt1), "Later should be greater than earlier");
    assert_true(dt1.is_before(&dt2), "Should be before");
    assert_true(dt2.is_after(&dt1), "Should be after");
}

fn test_duration_between() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);

    let dur = dt2.duration_since(&dt1);

    assert_eq(dur.as_millis(), 1000000, "Duration should be 1000000 ms");
    assert_eq(dur.as_seconds(), 1000, "Duration should be 1000 seconds");
}

fn test_parse_duration() {
    let dur_s = parse_duration("5s");
    match dur_s {
        Ok(d) => assert_eq(d.as_seconds(), 5, "Should parse 5s"),
        Err(_) => assert(false, "Failed to parse 5s"),
    }

    let dur_m = parse_duration("2m");
    match dur_m {
        Ok(d) => assert_eq(d.as_minutes(), 2, "Should parse 2m"),
        Err(_) => assert(false, "Failed to parse 2m"),
    }

    let dur_h = parse_duration("1h");
    match dur_h {
        Ok(d) => assert_eq(d.as_hours(), 1, "Should parse 1h"),
        Err(_) => assert(false, "Failed to parse 1h"),
    }
}

fn test_timer() {
    let timer = Timer::start();
    let elapsed = timer.elapsed();

    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_stopwatch() {
    let mut sw = Stopwatch::new();
    sw.start();

    // Record a lap
    let lap1 = sw.lap();
    assert_true(lap1.as_millis() >= 0, "Lap time should be non-negative");

    let elapsed = sw.stop();
    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_helper_functions() {
    let sec = seconds(30);
    let min = minutes(2);
    let hr = hours(1);
    let dy = days(1);

    assert_eq(sec.as_seconds(), 30, "seconds() helper should work");
    assert_eq(min.as_minutes(), 2, "minutes() helper should work");
    assert_eq(hr.as_hours(), 1, "hours() helper should work");
    assert_eq(dy.as_days(), 1, "days() helper should work");
}


// Test DateTime Implementation

// Test Duration creation and conversion
fn test_duration_creation() {
    let duration_s = Duration::from_seconds(60);
    let duration_m = Duration::from_minutes(1);

    assert_eq(duration_s.as_seconds(), 60, "60 seconds should be 60 seconds");
    assert_eq(duration_m.as_seconds(), 60, "1 minute should be 60 seconds");
    assert_eq(duration_s.as_millis(), 60000, "60 seconds should be 60000 ms");
}

fn test_duration_arithmetic() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);

    let sum = dur1.add(&dur2);
    let diff = dur1.sub(&dur2);

    assert_eq(sum.as_seconds(), 50, "30s + 20s should be 50s");
    assert_eq(diff.as_seconds(), 10, "30s - 20s should be 10s");
}

fn test_duration_comparison() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);
    let dur3 = Duration::from_seconds(30);

    assert_true(dur1.eq(&dur3), "30s should equal 30s");
    assert_true(dur1.gt(&dur2), "30s should be greater than 20s");
    assert_true(dur2.lt(&dur1), "20s should be less than 30s");
}

fn test_datetime_creation() {
    // Create from timestamp
    let dt1 = DateTime::from_timestamp(0);
    assert_eq(dt1.timestamp_millis(), 0, "Epoch should be 0");

    // Create from components (Jan 1, 2024, 00:00:00)
    let dt2 = DateTime::from_components(2024, 1, 1, 0, 0, 0);
    assert_true(dt2.year() >= 2020, "Year should be 2024 or close");
}

fn test_datetime_components() {
    // Create a specific datetime (Jan 15, 2024, 14:30:45)
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Note: These may be approximate due to simplified calendar calculations
    let year = dt.year();
    let month = dt.month();
    let day = dt.day();

    assert_true(year >= 2020 && year <= 2025, "Year should be around 2024");
}

fn test_datetime_formatting() {
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Test ISO string format
    let iso = dt.to_iso_string();
    assert_true(iso.len() > 0, "ISO string should not be empty");

    // Test custom format
    let formatted = dt.format("%Y-%m-%d");
    assert_true(formatted.len() > 0, "Formatted string should not be empty");
}

fn test_datetime_arithmetic() {
    let dt = DateTime::from_timestamp(1000000);
    let dur = Duration::from_seconds(60);

    let later = dt.add_duration(&dur);
    let earlier = dt.sub_duration(&dur);

    assert_eq(later.timestamp_millis(), 1000000 + 60000, "Should add 60 seconds");
    assert_eq(earlier.timestamp_millis(), 1000000 - 60000, "Should subtract 60 seconds");
}

fn test_datetime_comparison() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);
    let dt3 = DateTime::from_timestamp(1000000);

    assert_true(dt1.eq(&dt3), "Same timestamps should be equal");
    assert_true(dt1.lt(&dt2), "Earlier should be less than later");
    assert_true(dt2.gt(&dt1), "Later should be greater than earlier");
    assert_true(dt1.is_before(&dt2), "Should be before");
    assert_true(dt2.is_after(&dt1), "Should be after");
}

fn test_duration_between() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);

    let dur = dt2.duration_since(&dt1);

    assert_eq(dur.as_millis(), 1000000, "Duration should be 1000000 ms");
    assert_eq(dur.as_seconds(), 1000, "Duration should be 1000 seconds");
}

fn test_parse_duration() {
    let dur_s = parse_duration("5s");
    match dur_s {
        Ok(d) => assert_eq(d.as_seconds(), 5, "Should parse 5s"),
        Err(_) => assert(false, "Failed to parse 5s"),
    }

    let dur_m = parse_duration("2m");
    match dur_m {
        Ok(d) => assert_eq(d.as_minutes(), 2, "Should parse 2m"),
        Err(_) => assert(false, "Failed to parse 2m"),
    }

    let dur_h = parse_duration("1h");
    match dur_h {
        Ok(d) => assert_eq(d.as_hours(), 1, "Should parse 1h"),
        Err(_) => assert(false, "Failed to parse 1h"),
    }
}

fn test_timer() {
    let timer = Timer::start();
    let elapsed = timer.elapsed();

    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_stopwatch() {
    let mut sw = Stopwatch::new();
    sw.start();

    // Record a lap
    let lap1 = sw.lap();
    assert_true(lap1.as_millis() >= 0, "Lap time should be non-negative");

    let elapsed = sw.stop();
    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_helper_functions() {
    let sec = seconds(30);
    let min = minutes(2);
    let hr = hours(1);
    let dy = days(1);

    assert_eq(sec.as_seconds(), 30, "seconds() helper should work");
    assert_eq(min.as_minutes(), 2, "minutes() helper should work");
    assert_eq(hr.as_hours(), 1, "hours() helper should work");
    assert_eq(dy.as_days(), 1, "days() helper should work");
}


// Test DateTime Implementation

// Test Duration creation and conversion
fn test_duration_creation() {
    let duration_s = Duration::from_seconds(60);
    let duration_m = Duration::from_minutes(1);

    assert_eq(duration_s.as_seconds(), 60, "60 seconds should be 60 seconds");
    assert_eq(duration_m.as_seconds(), 60, "1 minute should be 60 seconds");
    assert_eq(duration_s.as_millis(), 60000, "60 seconds should be 60000 ms");
}

fn test_duration_arithmetic() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);

    let sum = dur1.add(&dur2);
    let diff = dur1.sub(&dur2);

    assert_eq(sum.as_seconds(), 50, "30s + 20s should be 50s");
    assert_eq(diff.as_seconds(), 10, "30s - 20s should be 10s");
}

fn test_duration_comparison() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);
    let dur3 = Duration::from_seconds(30);

    assert_true(dur1.eq(&dur3), "30s should equal 30s");
    assert_true(dur1.gt(&dur2), "30s should be greater than 20s");
    assert_true(dur2.lt(&dur1), "20s should be less than 30s");
}

fn test_datetime_creation() {
    // Create from timestamp
    let dt1 = DateTime::from_timestamp(0);
    assert_eq(dt1.timestamp_millis(), 0, "Epoch should be 0");

    // Create from components (Jan 1, 2024, 00:00:00)
    let dt2 = DateTime::from_components(2024, 1, 1, 0, 0, 0);
    assert_true(dt2.year() >= 2020, "Year should be 2024 or close");
}

fn test_datetime_components() {
    // Create a specific datetime (Jan 15, 2024, 14:30:45)
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Note: These may be approximate due to simplified calendar calculations
    let year = dt.year();
    let month = dt.month();
    let day = dt.day();

    assert_true(year >= 2020 && year <= 2025, "Year should be around 2024");
}

fn test_datetime_formatting() {
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Test ISO string format
    let iso = dt.to_iso_string();
    assert_true(iso.len() > 0, "ISO string should not be empty");

    // Test custom format
    let formatted = dt.format("%Y-%m-%d");
    assert_true(formatted.len() > 0, "Formatted string should not be empty");
}

fn test_datetime_arithmetic() {
    let dt = DateTime::from_timestamp(1000000);
    let dur = Duration::from_seconds(60);

    let later = dt.add_duration(&dur);
    let earlier = dt.sub_duration(&dur);

    assert_eq(later.timestamp_millis(), 1000000 + 60000, "Should add 60 seconds");
    assert_eq(earlier.timestamp_millis(), 1000000 - 60000, "Should subtract 60 seconds");
}

fn test_datetime_comparison() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);
    let dt3 = DateTime::from_timestamp(1000000);

    assert_true(dt1.eq(&dt3), "Same timestamps should be equal");
    assert_true(dt1.lt(&dt2), "Earlier should be less than later");
    assert_true(dt2.gt(&dt1), "Later should be greater than earlier");
    assert_true(dt1.is_before(&dt2), "Should be before");
    assert_true(dt2.is_after(&dt1), "Should be after");
}

fn test_duration_between() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);

    let dur = dt2.duration_since(&dt1);

    assert_eq(dur.as_millis(), 1000000, "Duration should be 1000000 ms");
    assert_eq(dur.as_seconds(), 1000, "Duration should be 1000 seconds");
}

fn test_parse_duration() {
    let dur_s = parse_duration("5s");
    match dur_s {
        Ok(d) => assert_eq(d.as_seconds(), 5, "Should parse 5s"),
        Err(_) => assert(false, "Failed to parse 5s"),
    }

    let dur_m = parse_duration("2m");
    match dur_m {
        Ok(d) => assert_eq(d.as_minutes(), 2, "Should parse 2m"),
        Err(_) => assert(false, "Failed to parse 2m"),
    }

    let dur_h = parse_duration("1h");
    match dur_h {
        Ok(d) => assert_eq(d.as_hours(), 1, "Should parse 1h"),
        Err(_) => assert(false, "Failed to parse 1h"),
    }
}

fn test_timer() {
    let timer = Timer::start();
    let elapsed = timer.elapsed();

    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_stopwatch() {
    let mut sw = Stopwatch::new();
    sw.start();

    // Record a lap
    let lap1 = sw.lap();
    assert_true(lap1.as_millis() >= 0, "Lap time should be non-negative");

    let elapsed = sw.stop();
    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_helper_functions() {
    let sec = seconds(30);
    let min = minutes(2);
    let hr = hours(1);
    let dy = days(1);

    assert_eq(sec.as_seconds(), 30, "seconds() helper should work");
    assert_eq(min.as_minutes(), 2, "minutes() helper should work");
    assert_eq(hr.as_hours(), 1, "hours() helper should work");
    assert_eq(dy.as_days(), 1, "days() helper should work");
}


// Test DateTime Implementation

// Test Duration creation and conversion
fn test_duration_creation() {
    let duration_s = Duration::from_seconds(60);
    let duration_m = Duration::from_minutes(1);

    assert_eq(duration_s.as_seconds(), 60, "60 seconds should be 60 seconds");
    assert_eq(duration_m.as_seconds(), 60, "1 minute should be 60 seconds");
    assert_eq(duration_s.as_millis(), 60000, "60 seconds should be 60000 ms");
}

fn test_duration_arithmetic() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);

    let sum = dur1.add(&dur2);
    let diff = dur1.sub(&dur2);

    assert_eq(sum.as_seconds(), 50, "30s + 20s should be 50s");
    assert_eq(diff.as_seconds(), 10, "30s - 20s should be 10s");
}

fn test_duration_comparison() {
    let dur1 = Duration::from_seconds(30);
    let dur2 = Duration::from_seconds(20);
    let dur3 = Duration::from_seconds(30);

    assert_true(dur1.eq(&dur3), "30s should equal 30s");
    assert_true(dur1.gt(&dur2), "30s should be greater than 20s");
    assert_true(dur2.lt(&dur1), "20s should be less than 30s");
}

fn test_datetime_creation() {
    // Create from timestamp
    let dt1 = DateTime::from_timestamp(0);
    assert_eq(dt1.timestamp_millis(), 0, "Epoch should be 0");

    // Create from components (Jan 1, 2024, 00:00:00)
    let dt2 = DateTime::from_components(2024, 1, 1, 0, 0, 0);
    assert_true(dt2.year() >= 2020, "Year should be 2024 or close");
}

fn test_datetime_components() {
    // Create a specific datetime (Jan 15, 2024, 14:30:45)
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Note: These may be approximate due to simplified calendar calculations
    let year = dt.year();
    let month = dt.month();
    let day = dt.day();

    assert_true(year >= 2020 && year <= 2025, "Year should be around 2024");
}

fn test_datetime_formatting() {
    let dt = DateTime::from_components(2024, 1, 15, 14, 30, 45);

    // Test ISO string format
    let iso = dt.to_iso_string();
    assert_true(iso.len() > 0, "ISO string should not be empty");

    // Test custom format
    let formatted = dt.format("%Y-%m-%d");
    assert_true(formatted.len() > 0, "Formatted string should not be empty");
}

fn test_datetime_arithmetic() {
    let dt = DateTime::from_timestamp(1000000);
    let dur = Duration::from_seconds(60);

    let later = dt.add_duration(&dur);
    let earlier = dt.sub_duration(&dur);

    assert_eq(later.timestamp_millis(), 1000000 + 60000, "Should add 60 seconds");
    assert_eq(earlier.timestamp_millis(), 1000000 - 60000, "Should subtract 60 seconds");
}

fn test_datetime_comparison() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);
    let dt3 = DateTime::from_timestamp(1000000);

    assert_true(dt1.eq(&dt3), "Same timestamps should be equal");
    assert_true(dt1.lt(&dt2), "Earlier should be less than later");
    assert_true(dt2.gt(&dt1), "Later should be greater than earlier");
    assert_true(dt1.is_before(&dt2), "Should be before");
    assert_true(dt2.is_after(&dt1), "Should be after");
}

fn test_duration_between() {
    let dt1 = DateTime::from_timestamp(1000000);
    let dt2 = DateTime::from_timestamp(2000000);

    let dur = dt2.duration_since(&dt1);

    assert_eq(dur.as_millis(), 1000000, "Duration should be 1000000 ms");
    assert_eq(dur.as_seconds(), 1000, "Duration should be 1000 seconds");
}

fn test_parse_duration() {
    let dur_s = parse_duration("5s");
    match dur_s {
        Ok(d) => assert_eq(d.as_seconds(), 5, "Should parse 5s"),
        Err(_) => assert(false, "Failed to parse 5s"),
    }

    let dur_m = parse_duration("2m");
    match dur_m {
        Ok(d) => assert_eq(d.as_minutes(), 2, "Should parse 2m"),
        Err(_) => assert(false, "Failed to parse 2m"),
    }

    let dur_h = parse_duration("1h");
    match dur_h {
        Ok(d) => assert_eq(d.as_hours(), 1, "Should parse 1h"),
        Err(_) => assert(false, "Failed to parse 1h"),
    }
}

fn test_timer() {
    let timer = Timer::start();
    let elapsed = timer.elapsed();

    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_stopwatch() {
    let mut sw = Stopwatch::new();
    sw.start();

    // Record a lap
    let lap1 = sw.lap();
    assert_true(lap1.as_millis() >= 0, "Lap time should be non-negative");

    let elapsed = sw.stop();
    assert_true(elapsed.as_millis() >= 0, "Elapsed time should be non-negative");
}

fn test_helper_functions() {
    let sec = seconds(30);
    let min = minutes(2);
    let hr = hours(1);
    let dy = days(1);

    assert_eq(sec.as_seconds(), 30, "seconds() helper should work");
    assert_eq(min.as_minutes(), 2, "minutes() helper should work");
    assert_eq(hr.as_hours(), 1, "hours() helper should work");
    assert_eq(dy.as_days(), 1, "days() helper should work");
}


// Basic Test Examples for Jounce Test Framework
// Functions starting with "test_" are automatically discovered and run

// Helper functions to test
fn add(a: int, b: int) -> int {
    return a + b;
}

fn subtract(a: int, b: int) -> int {
    return a - b;
}

fn multiply(a: int, b: int) -> int {
    return a * b;
}

fn is_even(n: int) -> bool {
    return n % 2 == 0;
}

// Test functions (discovered automatically)
fn test_addition() {
    let result = add(2, 3);
    assert_eq(result, 5, "2 + 3 should equal 5");
}

fn test_subtraction() {
    let result = subtract(10, 3);
    assert_eq(result, 7, "10 - 3 should equal 7");
}

fn test_multiplication() {
    let result = multiply(4, 5);
    assert_eq(result, 20, "4 * 5 should equal 20");
}

fn test_is_even() {
    assert_true(is_even(4), "4 is even");
    assert_false(is_even(5), "5 is not even");
}

fn test_boolean_assertions() {
    let x = 10;
    assert(x > 5, "x should be greater than 5");
    assert(x < 20, "x should be less than 20");
}

fn test_not_equal() {
    let a = 5;
    let b = 10;
    assert_ne(a, b, "a and b should be different");
}

// Async test example
async fn test_async_operation() {
    let result = await async_add(3, 4);
    assert_eq(result, 7, "async_add(3, 4) should equal 7");
}

async fn async_add(a: int, b: int) -> int {
    // Simulates an async operation
    return a + b;
}


// Basic Test Examples for Jounce Test Framework
// Functions starting with "test_" are automatically discovered and run

// Helper functions to test
fn add(a: int, b: int) -> int {
    return a + b;
}

fn subtract(a: int, b: int) -> int {
    return a - b;
}

fn multiply(a: int, b: int) -> int {
    return a * b;
}

fn is_even(n: int) -> bool {
    return n % 2 == 0;
}

// Test functions (discovered automatically)
fn test_addition() {
    let result = add(2, 3);
    assert_eq(result, 5, "2 + 3 should equal 5");
}

fn test_subtraction() {
    let result = subtract(10, 3);
    assert_eq(result, 7, "10 - 3 should equal 7");
}

fn test_multiplication() {
    let result = multiply(4, 5);
    assert_eq(result, 20, "4 * 5 should equal 20");
}

fn test_is_even() {
    assert_true(is_even(4), "4 is even");
    assert_false(is_even(5), "5 is not even");
}

fn test_boolean_assertions() {
    let x = 10;
    assert(x > 5, "x should be greater than 5");
    assert(x < 20, "x should be less than 20");
}

fn test_not_equal() {
    let a = 5;
    let b = 10;
    assert_ne(a, b, "a and b should be different");
}

// Async test example
async fn test_async_operation() {
    let result = await async_add(3, 4);
    assert_eq(result, 7, "async_add(3, 4) should equal 7");
}

async fn async_add(a: int, b: int) -> int {
    // Simulates an async operation
    return a + b;
}


// Basic Test Examples for Jounce Test Framework
// Functions starting with "test_" are automatically discovered and run

// Helper functions to test
fn add(a: int, b: int) -> int {
    return a + b;
}

fn subtract(a: int, b: int) -> int {
    return a - b;
}

fn multiply(a: int, b: int) -> int {
    return a * b;
}

fn is_even(n: int) -> bool {
    return n % 2 == 0;
}

// Test functions (discovered automatically)
fn test_addition() {
    let result = add(2, 3);
    assert_eq(result, 5, "2 + 3 should equal 5");
}

fn test_subtraction() {
    let result = subtract(10, 3);
    assert_eq(result, 7, "10 - 3 should equal 7");
}

fn test_multiplication() {
    let result = multiply(4, 5);
    assert_eq(result, 20, "4 * 5 should equal 20");
}

fn test_is_even() {
    assert_true(is_even(4), "4 is even");
    assert_false(is_even(5), "5 is not even");
}

fn test_boolean_assertions() {
    let x = 10;
    assert(x > 5, "x should be greater than 5");
    assert(x < 20, "x should be less than 20");
}

fn test_not_equal() {
    let a = 5;
    let b = 10;
    assert_ne(a, b, "a and b should be different");
}

// Async test example
async fn test_async_operation() {
    let result = await async_add(3, 4);
    assert_eq(result, 7, "async_add(3, 4) should equal 7");
}

async fn async_add(a: int, b: int) -> int {
    // Simulates an async operation
    return a + b;
}


// Basic Test Examples for Jounce Test Framework
// Functions starting with "test_" are automatically discovered and run

// Helper functions to test
fn add(a: int, b: int) -> int {
    return a + b;
}

fn subtract(a: int, b: int) -> int {
    return a - b;
}

fn multiply(a: int, b: int) -> int {
    return a * b;
}

fn is_even(n: int) -> bool {
    return n % 2 == 0;
}

// Test functions (discovered automatically)
fn test_addition() {
    let result = add(2, 3);
    assert_eq(result, 5, "2 + 3 should equal 5");
}

fn test_subtraction() {
    let result = subtract(10, 3);
    assert_eq(result, 7, "10 - 3 should equal 7");
}

fn test_multiplication() {
    let result = multiply(4, 5);
    assert_eq(result, 20, "4 * 5 should equal 20");
}

fn test_is_even() {
    assert_true(is_even(4), "4 is even");
    assert_false(is_even(5), "5 is not even");
}

fn test_boolean_assertions() {
    let x = 10;
    assert(x > 5, "x should be greater than 5");
    assert(x < 20, "x should be less than 20");
}

fn test_not_equal() {
    let a = 5;
    let b = 10;
    assert_ne(a, b, "a and b should be different");
}

// Async test example
async fn test_async_operation() {
    let result = await async_add(3, 4);
    assert_eq(result, 7, "async_add(3, 4) should equal 7");
}

async fn async_add(a: int, b: int) -> int {
    // Simulates an async operation
    return a + b;
}


// Basic Test Examples for Jounce Test Framework
// Functions starting with "test_" are automatically discovered and run

// Helper functions to test
fn add(a: int, b: int) -> int {
    return a + b;
}

fn subtract(a: int, b: int) -> int {
    return a - b;
}

fn multiply(a: int, b: int) -> int {
    return a * b;
}

fn is_even(n: int) -> bool {
    return n % 2 == 0;
}

// Test functions (discovered automatically)
fn test_addition() {
    let result = add(2, 3);
    assert_eq(result, 5, "2 + 3 should equal 5");
}

fn test_subtraction() {
    let result = subtract(10, 3);
    assert_eq(result, 7, "10 - 3 should equal 7");
}

fn test_multiplication() {
    let result = multiply(4, 5);
    assert_eq(result, 20, "4 * 5 should equal 20");
}

fn test_is_even() {
    assert_true(is_even(4), "4 is even");
    assert_false(is_even(5), "5 is not even");
}

fn test_boolean_assertions() {
    let x = 10;
    assert(x > 5, "x should be greater than 5");
    assert(x < 20, "x should be less than 20");
}

fn test_not_equal() {
    let a = 5;
    let b = 10;
    assert_ne(a, b, "a and b should be different");
}

// Async test example
async fn test_async_operation() {
    let result = await async_add(3, 4);
    assert_eq(result, 7, "async_add(3, 4) should equal 7");
}

async fn async_add(a: int, b: int) -> int {
    // Simulates an async operation
    return a + b;
}


// Basic Test Examples for Jounce Test Framework
// Functions starting with "test_" are automatically discovered and run

// Helper functions to test
fn add(a: int, b: int) -> int {
    return a + b;
}

fn subtract(a: int, b: int) -> int {
    return a - b;
}

fn multiply(a: int, b: int) -> int {
    return a * b;
}

fn is_even(n: int) -> bool {
    return n % 2 == 0;
}

// Test functions (discovered automatically)
fn test_addition() {
    let result = add(2, 3);
    assert_eq(result, 5, "2 + 3 should equal 5");
}

fn test_subtraction() {
    let result = subtract(10, 3);
    assert_eq(result, 7, "10 - 3 should equal 7");
}

fn test_multiplication() {
    let result = multiply(4, 5);
    assert_eq(result, 20, "4 * 5 should equal 20");
}

fn test_is_even() {
    assert_true(is_even(4), "4 is even");
    assert_false(is_even(5), "5 is not even");
}

fn test_boolean_assertions() {
    let x = 10;
    assert(x > 5, "x should be greater than 5");
    assert(x < 20, "x should be less than 20");
}

fn test_not_equal() {
    let a = 5;
    let b = 10;
    assert_ne(a, b, "a and b should be different");
}

// Async test example
async fn test_async_operation() {
    let result = await async_add(3, 4);
    assert_eq(result, 7, "async_add(3, 4) should equal 7");
}

async fn async_add(a: int, b: int) -> int {
    // Simulates an async operation
    return a + b;
}


// Basic Test Examples for Jounce Test Framework
// Functions starting with "test_" are automatically discovered and run

// Helper functions to test
fn add(a: int, b: int) -> int {
    return a + b;
}

fn subtract(a: int, b: int) -> int {
    return a - b;
}

fn multiply(a: int, b: int) -> int {
    return a * b;
}

fn is_even(n: int) -> bool {
    return n % 2 == 0;
}

// Test functions (discovered automatically)
fn test_addition() {
    let result = add(2, 3);
    assert_eq(result, 5, "2 + 3 should equal 5");
}

fn test_subtraction() {
    let result = subtract(10, 3);
    assert_eq(result, 7, "10 - 3 should equal 7");
}

fn test_multiplication() {
    let result = multiply(4, 5);
    assert_eq(result, 20, "4 * 5 should equal 20");
}

fn test_is_even() {
    assert_true(is_even(4), "4 is even");
    assert_false(is_even(5), "5 is not even");
}

fn test_boolean_assertions() {
    let x = 10;
    assert(x > 5, "x should be greater than 5");
    assert(x < 20, "x should be less than 20");
}

fn test_not_equal() {
    let a = 5;
    let b = 10;
    assert_ne(a, b, "a and b should be different");
}

// Async test example
async fn test_async_operation() {
    let result = await async_add(3, 4);
    assert_eq(result, 7, "async_add(3, 4) should equal 7");
}

async fn async_add(a: int, b: int) -> int {
    // Simulates an async operation
    return a + b;
}


